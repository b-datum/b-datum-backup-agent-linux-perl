#!/usr/bin/env perl
#
# Copyright (c) 2013-2014 b-datum, http://www.b-datum.com
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Config/Any.pm"} = <<'CONFIG_ANY';
  package Config::Any;
  
  use strict;
  use warnings;
  
  use Carp;
  use Module::Pluggable::Object ();
  
  our $VERSION = '0.23';
  
  =head1 NAME
  
  Config::Any - Load configuration from different file formats, transparently
  
  =head1 SYNOPSIS
  
      use Config::Any;
  
      my $cfg = Config::Any->load_stems({stems => \@filepath_stems, ... });
      # or
      my $cfg = Config::Any->load_files({files => \@filepaths, ... });
  
      for (@$cfg) {
          my ($filename, $config) = %$_;
          $class->config($config);
          warn "loaded config from file: $filename";
      }
  
  =head1 DESCRIPTION
  
  L<Config::Any|Config::Any> provides a facility for Perl applications and libraries
  to load configuration data from multiple different file formats. It supports XML, YAML,
  JSON, Apache-style configuration, Windows INI files, and even Perl code.
  
  The rationale for this module is as follows: Perl programs are deployed on many different
  platforms and integrated with many different systems. Systems administrators and end 
  users may prefer different configuration formats than the developers. The flexibility
  inherent in a multiple format configuration loader allows different users to make 
  different choices, without generating extra work for the developers. As a developer
  you only need to learn a single interface to be able to use the power of different
  configuration formats.
  
  =head1 INTERFACE 
  
  =cut
  
  =head2 load_files( \%args )
  
      Config::Any->load_files( { files => \@files } );
      Config::Any->load_files( { files => \@files, filter  => \&filter } );
      Config::Any->load_files( { files => \@files, use_ext => 1 } );
      Config::Any->load_files( { files => \@files, flatten_to_hash => 1 } );
  
  C<load_files()> attempts to load configuration from the list of files passed in
  the C<files> parameter, if the file exists.
  
  If the C<filter> parameter is set, it is used as a callback to modify the configuration 
  data before it is returned. It will be passed a single hash-reference parameter which 
  it should modify in-place.
  
  If the C<use_ext> parameter is defined, the loader will attempt to parse the file
  extension from each filename and will skip the file unless it matches a standard
  extension for the loading plugins. Only plugins whose standard extensions match the
  file extension will be used. For efficiency reasons, its use is encouraged, but
  be aware that you will lose flexibility -- for example, a file called C<myapp.cfg> 
  containing YAML data will not be offered to the YAML plugin, whereas C<myapp.yml>
  or C<myapp.yaml> would be.
  
  When the C<flatten_to_hash> parameter is defined, the loader will return a hash
  keyed on the file names, as opposed to the usual list of single-key hashes.
  
  C<load_files()> also supports a 'force_plugins' parameter, whose value should be an
  arrayref of plugin names like C<Config::Any::INI>. Its intended use is to allow the use 
  of a non-standard file extension while forcing it to be offered to a particular parser.
  It is not compatible with 'use_ext'. 
  
  You can supply a C<driver_args> hashref to pass special options to a particular
  parser object. Example:
  
      Config::Any->load_files( { files => \@files, driver_args => {
          General => { -LowerCaseNames => 1 }
      } )
  
  =cut
  
  sub load_files {
      my ( $class, $args ) = @_;
  
      unless ( $args && exists $args->{ files } ) {
          warn "No files specified!";
          return;
      }
  
      return $class->_load( $args );
  }
  
  =head2 load_stems( \%args )
  
      Config::Any->load_stems( { stems => \@stems } );
      Config::Any->load_stems( { stems => \@stems, filter  => \&filter } );
      Config::Any->load_stems( { stems => \@stems, use_ext => 1 } );
      Config::Any->load_stems( { stems => \@stems, flatten_to_hash => 1 } );
  
  C<load_stems()> attempts to load configuration from a list of files which it generates
  by combining the filename stems list passed in the C<stems> parameter with the 
  potential filename extensions from each loader, which you can check with the
  C<extensions()> classmethod described below. Once this list of possible filenames is
  built it is treated exactly as in C<load_files()> above, as which it takes the same
  parameters. Please read the C<load_files()> documentation before using this method.
  
  =cut
  
  sub load_stems {
      my ( $class, $args ) = @_;
  
      unless ( $args && exists $args->{ stems } ) {
          warn "No stems specified!";
          return;
      }
  
      my $stems = delete $args->{ stems };
      my @files;
      for my $s ( @$stems ) {
          for my $ext ( $class->extensions ) {
              push @files, "$s.$ext";
          }
      }
  
      $args->{ files } = \@files;
      return $class->_load( $args );
  }
  
  sub _load {
      my ( $class, $args ) = @_;
      croak "_load requires a arrayref of file paths" unless $args->{ files };
  
      my $force = defined $args->{ force_plugins };
      if ( !$force and !defined $args->{ use_ext } ) {
          warn
              "use_ext argument was not explicitly set, as of 0.09, this is true by default";
          $args->{ use_ext } = 1;
      }
  
      # figure out what plugins we're using
      my @plugins = $force
          ? map { eval "require $_;"; $_; } @{ $args->{ force_plugins } }
          : $class->plugins;
  
      # map extensions if we have to
      my ( %extension_lut, $extension_re );
      my $use_ext_lut = !$force && $args->{ use_ext };
      if ( $use_ext_lut ) {
          for my $plugin ( @plugins ) {
              for ( $plugin->extensions ) {
                  $extension_lut{ $_ } ||= [];
                  push @{ $extension_lut{ $_ } }, $plugin;
              }
          }
  
          $extension_re = join( '|', keys %extension_lut );
      }
  
      # map args to plugins
      my $base_class = __PACKAGE__;
      my %loader_args;
      for my $plugin ( @plugins ) {
          $plugin =~ m{^$base_class\::(.+)};
          $loader_args{ $plugin } = $args->{ driver_args }->{ $1 } || {};
      }
  
      my @results;
  
      for my $filename ( @{ $args->{ files } } ) {
  
          # don't even bother if it's not there
          next unless -f $filename;
  
          my @try_plugins = @plugins;
  
          if ( $use_ext_lut ) {
              $filename =~ m{\.($extension_re)\z};
  
              if ( !$1 ) {
                  $filename =~ m{\.([^.]+)\z};
                  croak "There are no loaders available for .${1} files";
              }
  
              @try_plugins = @{ $extension_lut{ $1 } };
          }
  
          # not using use_ext means we try all plugins anyway, so we'll
          # ignore it for the "unsupported" error
          my $supported = $use_ext_lut ? 0 : 1;
          for my $loader ( @try_plugins ) {
              next unless $loader->is_supported;
              $supported = 1;
              my @configs
                  = eval { $loader->load( $filename, $loader_args{ $loader } ); };
  
              # fatal error if we used extension matching
              croak "Error parsing $filename: $@" if $@ and $use_ext_lut;
              next if $@ or !@configs;
  
              # post-process config with a filter callback
              if ( $args->{ filter } ) {
                  $args->{ filter }->( $_ ) for @configs;
              }
  
              push @results,
                  { $filename => @configs == 1 ? $configs[ 0 ] : \@configs };
              last;
          }
  
          if ( !$supported ) {
              croak
                  "Cannot load $filename: required support modules are not available.\nPlease install "
                  . join( " OR ", map { _support_error( $_ ) } @try_plugins );
          }
      }
  
      if ( defined $args->{ flatten_to_hash } ) {
          my %flattened = map { %$_ } @results;
          return \%flattened;
      }
  
      return \@results;
  }
  
  sub _support_error {
      my $module = shift;
      if ( $module->can( 'requires_all_of' ) ) {
          return join( ' and ',
              map { ref $_ ? join( ' ', @$_ ) : $_ } $module->requires_all_of );
      }
      if ( $module->can( 'requires_any_of' ) ) {
          return 'one of '
              . join( ' or ',
              map { ref $_ ? join( ' ', @$_ ) : $_ } $module->requires_any_of );
      }
  }
  
  =head2 finder( )
  
  The C<finder()> classmethod returns the 
  L<Module::Pluggable::Object|Module::Pluggable::Object>
  object which is used to load the plugins. See the documentation for that module for
  more information.
  
  =cut
  
  sub finder {
      my $class  = shift;
      my $finder = Module::Pluggable::Object->new(
          search_path => [ __PACKAGE__ ],
          except      => [ __PACKAGE__ . '::Base' ],
          require     => 1
      );
      return $finder;
  }
  
  =head2 plugins( )
  
  The C<plugins()> classmethod returns the names of configuration loading plugins as 
  found by L<Module::Pluggable::Object|Module::Pluggable::Object>.
  
  =cut
  
  sub plugins {
      my $class = shift;
  
      # filter out things that don't look like our plugins
      return grep { $_->isa( 'Config::Any::Base' ) } $class->finder->plugins;
  }
  
  =head2 extensions( )
  
  The C<extensions()> classmethod returns the possible file extensions which can be loaded
  by C<load_stems()> and C<load_files()>. This may be useful if you set the C<use_ext>
  parameter to those methods.
  
  =cut
  
  sub extensions {
      my $class = shift;
      my @ext
          = map { $_->extensions } $class->plugins;
      return wantarray ? @ext : \@ext;
  }
  
  =head1 DIAGNOSTICS
  
  =over
  
  =item C<No files specified!> or C<No stems specified!>
  
  The C<load_files()> and C<load_stems()> methods will issue this warning if
  called with an empty list of files/stems to load.
  
  =item C<_load requires a arrayref of file paths>
  
  This fatal error will be thrown by the internal C<_load> method. It should not occur
  but is specified here for completeness. If your code dies with this error, please
  email a failing test case to the authors below.
  
  =back
  
  =head1 CONFIGURATION AND ENVIRONMENT
  
  Config::Any requires no configuration files or environment variables.
  
  =head1 DEPENDENCIES
  
  L<Module::Pluggable|Module::Pluggable>
  
  And at least one of the following:
  L<Config::General|Config::General>
  L<Config::Tiny|Config::Tiny>
  L<JSON|JSON>
  L<YAML|YAML>
  L<JSON::Syck|JSON::Syck>
  L<YAML::Syck|YAML::Syck>
  L<XML::Simple|XML::Simple>
  
  =head1 INCOMPATIBILITIES
  
  None reported.
  
  =head1 BUGS AND LIMITATIONS
  
  No bugs have been reported.
  
  Please report any bugs or feature requests to
  C<bug-config-any@rt.cpan.org>, or through the web interface at
  L<http://rt.cpan.org>.
  
  =head1 AUTHOR
  
  Joel Bernstein E<lt>rataxis@cpan.orgE<gt>
  
  =head1 CONTRIBUTORS
  
  This module was based on the original 
  L<Catalyst::Plugin::ConfigLoader|Catalyst::Plugin::ConfigLoader>
  module by Brian Cassidy C<< <bricas@cpan.org> >>.
  
  With ideas and support from Matt S Trout C<< <mst@shadowcatsystems.co.uk> >>.
  
  Further enhancements suggested by Evan Kaufman C<< <evank@cpan.org> >>.
  
  =head1 LICENCE AND COPYRIGHT
  
  Copyright (c) 2006, Portugal Telecom C<< http://www.sapo.pt/ >>. All rights reserved.
  Portions copyright 2007, Joel Bernstein C<< <rataxis@cpan.org> >>.
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself. See L<perlartistic>.
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
  
  =head1 SEE ALSO
  
  L<Catalyst::Plugin::ConfigLoader|Catalyst::Plugin::ConfigLoader> 
  -- now a wrapper around this module.
  
  =cut
  
  "Drink more beer";
CONFIG_ANY

$fatpacked{"Config/Any/Base.pm"} = <<'CONFIG_ANY_BASE';
  package Config::Any::Base;
  
  use strict;
  use warnings;
  
  =head1 NAME
  
  Config::Any::Base - Base class for loaders
  
  =head1 DESCRIPTION
  
  This is a base class for all loaders. It currently handles the specification
  of dependencies in order to ensure the subclass can load the config file
  format.
  
  =head1 METHODS
  
  =head2 is_supported( )
  
  Allows us to determine if the file format can be loaded. The can be done via
  one of two subclass methds:
  
  =over 4
  
  =item * C<requires_all_of()> - returns an array of items that must all be present in order to work
  
  =item * C<requires_any_of()> - returns an array of items in which at least one must be present
  
  =back
  
  You can specify a module version by passing an array reference in the return.
  
      sub requires_all_of { [ 'My::Module', '1.1' ], 'My::OtherModule' }
  
  Lack of specifying these subs will assume you require no extra modules to function.
  
  =cut
  
  sub is_supported {
      my ( $class ) = shift;
      if ( $class->can( 'requires_all_of' ) ) {
          eval join( '', map { _require_line( $_ ) } $class->requires_all_of );
          return $@ ? 0 : 1;
      }
      if ( $class->can( 'requires_any_of' ) ) {
          for ( $class->requires_any_of ) {
              eval _require_line( $_ );
              return 1 unless $@;
          }
          return 0;
      }
  
      # requires nothing!
      return 1;
  }
  
  sub _require_line {
      my ( $input ) = shift;
      my ( $module, $version ) = ( ref $input ? @$input : $input );
      return "require $module;"
          . ( $version ? "${module}->VERSION('${version}');" : '' );
  }
  
  =head1 AUTHOR
  
  Brian Cassidy E<lt>bricas@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2008-2009 by Brian Cassidy
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 SEE ALSO
  
  =over 4 
  
  =item * L<Config::Any>
  
  =back
  
  =cut
  
  1;
CONFIG_ANY_BASE

$fatpacked{"Config/Any/General.pm"} = <<'CONFIG_ANY_GENERAL';
  package Config::Any::General;
  
  use strict;
  use warnings;
  
  use base 'Config::Any::Base';
  
  =head1 NAME
  
  Config::Any::General - Load Config::General files
  
  =head1 DESCRIPTION
  
  Loads Config::General files. Example:
  
      name = TestApp
      <Component Controller::Foo>
          foo bar
          bar [ arrayref-value ]
      </Component>
      <Model Baz>
          qux xyzzy
      </Model>
  
  =head1 METHODS
  
  =head2 extensions( )
  
  return an array of valid extensions (C<cnf>, C<conf>).
  
  =cut
  
  sub extensions {
      return qw( cnf conf );
  }
  
  =head2 load( $file )
  
  Attempts to load C<$file> via Config::General.
  
  =cut
  
  sub load {
      my $class = shift;
      my $file  = shift;
      my $args  = shift || {};
  
      $args->{ -ConfigFile } = $file;
  
      require Config::General;
      Config::General->VERSION( '2.47' );
  
      $args->{ -ForceArray } = 1 unless exists $args->{ -ForceArray };
  
      my $configfile = Config::General->new( %$args );
      my $config     = { $configfile->getall };
  
      return $config;
  }
  
  =head2 requires_all_of( )
  
  Specifies that this module requires L<Config::General> in order to work.
  
  =cut
  
  sub requires_all_of { [ 'Config::General' ] }
  
  =head1 AUTHOR
  
  Brian Cassidy E<lt>bricas@cpan.orgE<gt>
  
  =head1 CONTRIBUTORS
  
  Joel Bernstein E<lt>rataxis@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2006-2011 by Brian Cassidy
  
  Portions Copyright 2006 Portugal Telecom
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 SEE ALSO
  
  =over 4 
  
  =item * L<Catalyst>
  
  =item * L<Config::Any>
  
  =item * L<Config::General>
  
  =back
  
  =cut
  
  1;
CONFIG_ANY_GENERAL

$fatpacked{"Config/Any/INI.pm"} = <<'CONFIG_ANY_INI';
  package Config::Any::INI;
  
  use strict;
  use warnings;
  
  use base 'Config::Any::Base';
  
  our $MAP_SECTION_SPACE_TO_NESTED_KEY = 1;
  
  =head1 NAME
  
  Config::Any::INI - Load INI config files
  
  =head1 DESCRIPTION
  
  Loads INI files. Example:
  
      name=TestApp
      
      [Controller::Foo]
      foo=bar
      
      [Model::Baz]
      qux=xyzzy
  
  =head1 METHODS
  
  =head2 extensions( )
  
  return an array of valid extensions (C<ini>).
  
  =cut
  
  sub extensions {
      return qw( ini );
  }
  
  =head2 load( $file )
  
  Attempts to load C<$file> as an INI file.
  
  =cut
  
  sub load {
      my $class = shift;
      my $file  = shift;
  
      require Config::Tiny;
      my $config = Config::Tiny->read( $file );
  
      die $Config::Tiny::errstr if not defined $config;
  
      my $out = delete $config->{ _ } || {};
  
      for my $k ( keys %$config ) {
          my @keys = split /\s+/, $k;
          my $ref = $config->{ $k };
  
          if ( $MAP_SECTION_SPACE_TO_NESTED_KEY && @keys > 1 ) {
              my ( $a, $b ) = @keys[ 0, 1 ];
              $out->{ $a }->{ $b } = $ref;
          }
          else {
              $out->{ $k } = { %{ $out->{ $k } || {} }, %$ref };
          }
      }
  
      return $out;
  }
  
  =head2 requires_all_of( )
  
  Specifies that this module requires L<Config::Tiny> in order to work.
  
  =cut
  
  sub requires_all_of { 'Config::Tiny' }
  
  =head1 PACKAGE VARIABLES
  
  =over 4
  
  =item $MAP_SECTION_SPACE_TO_NESTED_KEY (boolean)
  
  This variable controls whether spaces in INI section headings will be expanded into nested hash keys.
  e.g. it controls whether [Full Power] maps to $config->{'Full Power'} or $config->{'Full'}->{'Power'}
  
  By default it is set to 1 (i.e. true). 
  
  Set it to 0 to preserve literal spaces in section headings:
  
      use Config::Any;
      use Config::Any::INI;
      $Config::Any::INI::MAP_SECTION_SPACE_TO_NESTED_KEY = 0;
  
  =back
  
  =head1 AUTHORS
  
  Brian Cassidy E<lt>bricas@cpan.orgE<gt>
  
  Joel Bernstein E<lt>rataxis@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2006-2011 by Brian Cassidy, portions copyright 2006, 2007 by Joel Bernstein
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 SEE ALSO
  
  =over 4 
  
  =item * L<Catalyst>
  
  =item * L<Config::Any>
  
  =item * L<Config::Tiny>
  
  =back
  
  =cut
  
  1;
CONFIG_ANY_INI

$fatpacked{"Config/Any/JSON.pm"} = <<'CONFIG_ANY_JSON';
  package Config::Any::JSON;
  
  use strict;
  use warnings;
  
  use base 'Config::Any::Base';
  
  =head1 NAME
  
  Config::Any::JSON - Load JSON config files
  
  =head1 DESCRIPTION
  
  Loads JSON files. Example:
  
      {
          "name": "TestApp",
          "Controller::Foo": {
              "foo": "bar"
          },
          "Model::Baz": {
              "qux": "xyzzy"
          }
      }
  
  =head1 METHODS
  
  =head2 extensions( )
  
  return an array of valid extensions (C<json>, C<jsn>).
  
  =cut
  
  sub extensions {
      return qw( json jsn );
  }
  
  =head2 load( $file )
  
  Attempts to load C<$file> as a JSON file.
  
  =cut
  
  sub load {
      my $class = shift;
      my $file  = shift;
  
      open( my $fh, $file ) or die $!;
      my $content = do { local $/; <$fh> };
      close $fh;
  
      eval { require JSON::DWIW; };
      unless( $@ ) {
          my $decoder = JSON::DWIW->new;
          my ( $data, $error ) = $decoder->from_json( $content );
          die $error if $error;
          return $data;
      }
  
      eval { require JSON::XS; };
      unless( $@ ) {
          my $decoder = JSON::XS->new->relaxed;
          return $decoder->decode( $content );
      }
  
      eval { require JSON::Syck; };
      unless( $@ ) {
          return JSON::Syck::Load( $content );
      }
  
      require JSON;
      eval { JSON->VERSION( 2 ); };
      return $@ ? JSON::jsonToObj( $content ) : JSON::from_json( $content );
  }
  
  =head2 requires_any_of( )
  
  Specifies that this modules requires one of,  L<JSON::DWIW>, L<JSON::XS>,
  L<JSON::Syck> or L<JSON> in order to work.
  
  =cut
  
  sub requires_any_of { 'JSON::DWIW', 'JSON::XS', 'JSON::Syck', 'JSON' }
  
  =head1 AUTHOR
  
  Brian Cassidy E<lt>bricas@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2006-2011 by Brian Cassidy
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 SEE ALSO
  
  =over 4 
  
  =item * L<Catalyst>
  
  =item * L<Config::Any>
  
  =item * L<JSON::DWIW>
  
  =item * L<JSON::XS>
  
  =item * L<JSON::Syck>
  
  =item * L<JSON>
  
  =back
  
  =cut
  
  1;
CONFIG_ANY_JSON

$fatpacked{"Config/Any/Perl.pm"} = <<'CONFIG_ANY_PERL';
  package Config::Any::Perl;
  
  use strict;
  use warnings;
  
  use base 'Config::Any::Base';
  
  =head1 NAME
  
  Config::Any::Perl - Load Perl config files
  
  =head1 DESCRIPTION
  
  Loads Perl files. Example:
  
      {
          name => 'TestApp',
          'Controller::Foo' => {
              foo => 'bar'
          },
          'Model::Baz' => {
              qux => 'xyzzy'
          }
      }
  
  =head1 METHODS
  
  =head2 extensions( )
  
  return an array of valid extensions (C<pl>, C<perl>).
  
  =cut
  
  sub extensions {
      return qw( pl perl );
  }
  
  =head2 load( $file )
  
  Attempts to load C<$file> as a Perl file.
  
  =cut
  
  sub load {
      my $class = shift;
      my $file  = shift;
  
      my( $exception, $content );
      {
          local $@;
          $content = do $file;
          $exception = $@;
      }
      die $exception if $exception;
  
      return $content;
  }
  
  =head1 AUTHOR
  
  Brian Cassidy E<lt>bricas@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2006-2011 by Brian Cassidy
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 SEE ALSO
  
  =over 4 
  
  =item * L<Catalyst>
  
  =item * L<Config::Any>
  
  =back
  
  =cut
  
  1;
CONFIG_ANY_PERL

$fatpacked{"Config/Any/XML.pm"} = <<'CONFIG_ANY_XML';
  package Config::Any::XML;
  
  use strict;
  use warnings;
  
  use base 'Config::Any::Base';
  
  =head1 NAME
  
  Config::Any::XML - Load XML config files
  
  =head1 DESCRIPTION
  
  Loads XML files. Example:
  
      <config>
          <name>TestApp</name>
          <component name="Controller::Foo">
              <foo>bar</foo>
          </component>
          <model name="Baz">
              <qux>xyzzy</qux>
          </model>
      </config>
  
  =head1 METHODS
  
  =head2 extensions( )
  
  return an array of valid extensions (C<xml>).
  
  =cut
  
  sub extensions {
      return qw( xml );
  }
  
  =head2 load( $file )
  
  Attempts to load C<$file> as an XML file.
  
  =cut
  
  sub load {
      my $class = shift;
      my $file  = shift;
      my $args  = shift || {};
  
      require XML::Simple;
      my $config = XML::Simple::XMLin(
          $file,
          ForceArray => [ qw( component model view controller ) ],
          %$args
      );
  
      return $class->_coerce( $config );
  }
  
  sub _coerce {
      # coerce the XML-parsed config into the correct format
      my $class  = shift;
      my $config = shift;
      my $out;
      for my $k ( keys %$config ) {
          my $ref = $config->{ $k };
          my $name = ref $ref eq 'HASH' ? delete $ref->{ name } : undef;
          if ( defined $name ) {
              $out->{ $k }->{ $name } = $ref;
          }
          else {
              $out->{ $k } = $ref;
          }
      }
      $out;
  }
  
  =head2 requires_all_of( )
  
  Specifies that this module requires L<XML::Simple> and L<XML::NamespaceSupport>
  in order to work.
  
  =cut
  
  sub requires_all_of { 'XML::Simple', 'XML::NamespaceSupport' }
  
  =head1 CAVEATS
  
  =head2 Strict Mode
  
  If, by some chance, L<XML::Simple> has already been loaded with the strict
  flag turned on, then you will likely get errors as warnings will become
  fatal exceptions and certain arguments to XMLin() will no longer be optional.
  
  See L<XML::Simple's strict mode documentation|XML::Simple/STRICT_MODE> for
  more information.
  
  =head1 AUTHORS
  
  Brian Cassidy E<lt>bricas@cpan.orgE<gt>
  
  Joel Bernstein E<lt>rataxis@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2006-2011 by Brian Cassidy
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 SEE ALSO
  
  =over 4 
  
  =item * L<Catalyst>
  
  =item * L<Config::Any>
  
  =item * L<XML::Simple>
  
  =back
  
  =cut
  
  1;
CONFIG_ANY_XML

$fatpacked{"Config/Any/YAML.pm"} = <<'CONFIG_ANY_YAML';
  package Config::Any::YAML;
  
  use strict;
  use warnings;
  
  use base 'Config::Any::Base';
  
  use Carp ();
  
  =head1 NAME
  
  Config::Any::YAML - Load YAML config files
  
  =head1 DESCRIPTION
  
  Loads YAML files. Example:
  
      ---
      name: TestApp
      Controller::Foo:
          foo: bar
      Model::Baz:
          qux: xyzzy
      
  
  =head1 METHODS
  
  =head2 extensions( )
  
  return an array of valid extensions (C<yml>, C<yaml>).
  
  =cut
  
  sub extensions {
      return qw( yml yaml );
  }
  
  =head2 load( $file )
  
  Attempts to load C<$file> as a YAML file.
  
  =cut
  
  our $NO_YAML_XS_WARNING;
  
  sub load {
      my $class = shift;
      my $file  = shift;
  
      eval { require YAML::XS };
      unless ( $@ ) {
          return YAML::XS::LoadFile( $file );
      }
  
      Carp::carp
          'Use of YAML::Syck or YAML to parse config files is DEPRECATED. '
          . 'Please install YAML::XS for proper YAML support'
              unless $NO_YAML_XS_WARNING;
  
      eval { require YAML::Syck; YAML::Syck->VERSION( '0.70' ) };
      unless ( $@ ) {
          open( my $fh, $file ) or die $!;
          my $content = do { local $/; <$fh> };
          close $fh;
          return YAML::Syck::Load( $content );
      }
  
      require YAML;
      return YAML::LoadFile( $file );
  }
  
  =head2 requires_any_of( )
  
  Specifies that this modules requires one of L<YAML::XS>, L<YAML::Syck> (0.70) or
  L<YAML> in order to work.
  
  =cut
  
  sub requires_any_of { 'YAML::XS', [ 'YAML::Syck', '0.70' ], 'YAML' }
  
  =head1 AUTHOR
  
  Brian Cassidy E<lt>bricas@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2006-2011 by Brian Cassidy
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =head1 SEE ALSO
  
  =over 4 
  
  =item * L<Catalyst>
  
  =item * L<Config::Any>
  
  =item * L<YAML::XS>
  
  =item * L<YAML>
  
  =item * L<YAML::Syck>
  
  =back
  
  =cut
  
  1;
CONFIG_ANY_YAML

$fatpacked{"Config/Tiny.pm"} = <<'CONFIG_TINY';
  package Config::Tiny;
  
  # If you thought Config::Simple was small...
  
  use strict;
  our $VERSION = '2.16';
  BEGIN {
  	require 5.008001;
  	$Config::Tiny::errstr  = '';
  }
  
  # Create an empty object
  sub new { bless {}, shift }
  
  # Create an object from a file
  sub read {
  	my $class = ref $_[0] ? ref shift : shift;
  
  	# Check the file
  	my $file = shift or return $class->_error( 'You did not specify a file name' );
  	return $class->_error( "File '$file' does not exist" )              unless -e $file;
  	return $class->_error( "'$file' is a directory, not a file" )       unless -f _;
  	return $class->_error( "Insufficient permissions to read '$file'" ) unless -r _;
  
  	# Slurp in the file.
  
  	my $encoding = shift;
  	$encoding    = $encoding ? "<:$encoding" : '<';
  	local $/     = undef;
  
  	open( CFG, $encoding, $file ) or return $class->_error( "Failed to open file '$file': $!" );
  	my $contents = <CFG>;
  	close( CFG );
  
  	return $class->read_string( $contents );
  }
  
  # Create an object from a string
  sub read_string {
  	my $class = ref $_[0] ? ref shift : shift;
  	my $self  = bless {}, $class;
  	return undef unless defined $_[0];
  
  	# Parse the file
  	my $ns      = '_';
  	my $counter = 0;
  	foreach ( split /(?:\015{1,2}\012|\015|\012)/, shift ) {
  		$counter++;
  
  		# Skip comments and empty lines
  		next if /^\s*(?:\#|\;|$)/;
  
  		# Remove inline comments
  		s/\s\;\s.+$//g;
  
  		# Handle section headers
  		if ( /^\s*\[\s*(.+?)\s*\]\s*$/ ) {
  			# Create the sub-hash if it doesn't exist.
  			# Without this sections without keys will not
  			# appear at all in the completed struct.
  			$self->{$ns = $1} ||= {};
  			next;
  		}
  
  		# Handle properties
  		if ( /^\s*([^=]+?)\s*=\s*(.*?)\s*$/ ) {
  			$self->{$ns}->{$1} = $2;
  			next;
  		}
  
  		return $self->_error( "Syntax error at line $counter: '$_'" );
  	}
  
  	$self;
  }
  
  # Save an object to a file
  sub write {
  	my $self = shift;
  	my $file = shift or return $self->_error(
  		'No file name provided'
  		);
  	my $encoding = shift;
  	$encoding    = $encoding ? ">:$encoding" : '>';
  
  	# Write it to the file
  	my $string = $self->write_string;
  	return undef unless defined $string;
  	open( CFG, $encoding, $file ) or return $self->_error(
  		"Failed to open file '$file' for writing: $!"
  		);
  	print CFG $string;
  	close CFG;
  
  	return 1;
  }
  
  # Save an object to a string
  sub write_string {
  	my $self = shift;
  
  	my $contents = '';
  	foreach my $section ( sort { (($b eq '_') <=> ($a eq '_')) || ($a cmp $b) } keys %$self ) {
  		# Check for several known-bad situations with the section
  		# 1. Leading whitespace
  		# 2. Trailing whitespace
  		# 3. Newlines in section name
  		return $self->_error(
  			"Illegal whitespace in section name '$section'"
  		) if $section =~ /(?:^\s|\n|\s$)/s;
  		my $block = $self->{$section};
  		$contents .= "\n" if length $contents;
  		$contents .= "[$section]\n" unless $section eq '_';
  		foreach my $property ( sort keys %$block ) {
  			return $self->_error(
  				"Illegal newlines in property '$section.$property'"
  			) if $block->{$property} =~ /(?:\012|\015)/s;
  			$contents .= "$property=$block->{$property}\n";
  		}
  	}
  
  	$contents;
  }
  
  # Error handling
  sub errstr { $Config::Tiny::errstr }
  sub _error { $Config::Tiny::errstr = $_[1]; undef }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Config::Tiny - Read/Write .ini style files with as little code as possible
  
  =head1 SYNOPSIS
  
  	# In your configuration file
  	rootproperty=blah
  
  	[section]
  	one=twp
  	three= four
  	Foo =Bar
  	empty=
  
  	# In your program
  	use Config::Tiny;
  
  	# Create a config
  	my $Config = Config::Tiny->new;
  
  	# Open the config
  	$Config = Config::Tiny->read( 'file.conf' );
  	$Config = Config::Tiny->read( 'file.conf', 'utf8' ); # Neither ':' nor '<:' prefix!
  	$Config = Config::Tiny->read( 'file.conf', 'encoding(iso-8859-1)');
  
  	# Reading properties
  	my $rootproperty = $Config->{_}->{rootproperty};
  	my $one = $Config->{section}->{one};
  	my $Foo = $Config->{section}->{Foo};
  
  	# Changing data
  	$Config->{newsection} = { this => 'that' }; # Add a section
  	$Config->{section}->{Foo} = 'Not Bar!';     # Change a value
  	delete $Config->{_};                        # Delete a value or section
  
  	# Save a config
  	$Config->write( 'file.conf' );
  	$Config->write( 'file.conf', 'utf8' ); # Neither ':' nor '>:' prefix!
  
  	# Shortcuts
  	my($rootproperty) = $$Config{_}{rootproperty};
  
  	my($config) = Config::Tiny -> read_string('alpha=bet');
  	my($value)  = $$config{_}{alpha}; # $value is 'bet'.
  
  	my($config) = Config::Tiny -> read_string("[init]\nalpha=bet");
  	my($value)  = $$config{init}{alpha}; # $value is 'bet'.
  
  =head1 DESCRIPTION
  
  C<Config::Tiny> is a Perl class to read and write .ini style configuration
  files with as little code as possible, reducing load time and memory
  overhead.
  
  Most of the time it is accepted that Perl applications use a lot
  of memory and modules.
  
  The C<*::Tiny> family of modules is specifically intended to provide an ultralight alternative to the
  standard modules.
  
  This module is primarily for reading human written files, and anything we write shouldn't need to have
  documentation/comments. If you need something with more power move up to L<Config::Simple>, L<Config::General>
  or one of the many other C<Config::*> modules.
  
  Lastly, L<Config::Tiny> does B<not> preserve your comments, whitespace, or the order of your config file.
  
  See L<Config::Tiny::Ordered> (and possibly others) for the preservation of the order of the entries in the file.
  
  =head1 CONFIGURATION FILE SYNTAX
  
  Files are the same format as for MS Windows C<*.ini> files. For example:
  
  	[section]
  	var1=value1
  	var2=value2
  
  If a property is outside of a section at the beginning of a file, it will
  be assigned to the C<"root section">, available at C<$Config-E<gt>{_}>.
  
  Lines starting with C<'#'> or C<';'> are considered comments and ignored,
  as are blank lines.
  
  When writing back to the config file, all comments, custom whitespace,
  and the ordering of your config file elements is discarded. If you need
  to keep the human elements of a config when writing back, upgrade to
  something better, this module is not for you.
  
  =head1 METHODS
  
  =head2 errstr()
  
  Returns a string representing the most recent error, or the empty string.
  
  You can also retrieve the error message from the C<$Config::Tiny::errstr> variable.
  
  =head2 new()
  
  The constructor C<new> creates and returns an empty C<Config::Tiny> object.
  
  =head2 read($filename, [$encoding])
  
  Here, the [] indicate an optional parameter.
  
  The C<read> constructor reads a config file, $filename, and returns a new
  C<Config::Tiny> object containing the properties in the file.
  
  $encoding may be used to indicate the encoding of the file, e.g. 'utf8' or 'encoding(iso-8859-1)'.
  
  Do not add a prefix to $encoding, such as '<' or '<:'.
  
  Returns the object on success, or C<undef> on error.
  
  When C<read> fails, C<Config::Tiny> sets an error message internally
  you can recover via C<Config::Tiny-E<gt>errstr>. Although in B<some>
  cases a failed C<read> will also set the operating system error
  variable C<$!>, not all errors do and you should not rely on using
  the C<$!> variable.
  
  See t/04.utf8.t and t/04.utf8.txt.
  
  =head2 read_string($string)
  
  The C<read_string> method takes as argument the contents of a config file
  as a string and returns the C<Config::Tiny> object for it.
  
  =head2 write($filename, [$encoding])
  
  Here, the [] indicate an optional parameter.
  
  The C<write> method generates the file content for the properties, and
  writes it to disk to the filename specified.
  
  $encoding may be used to indicate the encoding of the file, e.g. 'utf8' or 'encoding(iso-8859-1)'.
  
  Do not add a prefix to $encoding, such as '>' or '>:'.
  
  Returns true on success or C<undef> on error.
  
  See t/04.utf8.t and t/04.utf8.txt.
  
  =head2 write_string()
  
  Generates the file content for the object and returns it as a string.
  
  =head1 FAQ
  
  =head2 Why can't I put comments at the ends of lines?
  
  Because a line like:
  
  	key=value # A comment
  
  Sets key to 'value # A comment' :-(.
  
  This conforms to the syntax discussed in L</CONFIGURATION FILE SYNTAX>.
  
  =head2 Why can't I omit the '=' signs?
  
  E.g.:
  
  	[Things]
  	my =
  	list =
  	of =
  	things =
  
  Instead of:
  
  	[Things]
  	my
  	list
  	of
  	things
  
  Because the use of '=' signs is a type of mandatory documentation. It indicates that that section contains 4 items,
  and not 1 odd item split over 4 lines.
  
  =head2 Why do I have to assign the result of a method call to a variable?
  
  This question comes from RT#85386.
  
  Yes, the syntax may seem odd, but you don't have to call both new() and read_string().
  
  Try:
  
  	perl -MData::Dumper -MConfig::Tiny -E 'my $c=Config::Tiny->read_string("one=s"); say Dumper $c'
  
  Or:
  
  	my($config) = Config::Tiny -> read_string('alpha=bet');
  	my($value)  = $$config{_}{alpha}; # $value is 'bet'.
  
  Or even, a bit ridiculously:
  
  	my($value) = ${Config::Tiny -> read_string('alpha=bet')}{_}{alpha}; # $value is 'bet'.
  
  =head1 CAVEATS
  
  =head2 Unsupported Section Headers
  
  Some edge cases in section headers are not supported, and additionally may not
  be detected when writing the config file.
  
  Specifically, section headers with leading whitespace, trailing whitespace,
  or newlines anywhere in the section header, will not be written correctly
  to the file and may cause file corruption.
  
  =head2 Setting an option more than once
  
  C<Config::Tiny> will only recognize the first time an option is set in a
  config file. Any further attempts to set the same option later in the config
  file are ignored.
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker at
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Config-Tiny>
  
  For other issues, or commercial enhancement or support, contact the author.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Maintanence from V 2.15: Ron Savage L<http://savage.net.au/>.
  
  =head1 ACKNOWLEGEMENTS
  
  Thanks to Sherzod Ruzmetov E<lt>sherzodr@cpan.orgE<gt> for
  L<Config::Simple>, which inspired this module by being not quite
  "simple" enough for me :).
  
  =head1 SEE ALSO
  
  See, amongst many: L<Config::Simple> and L<Config::General>.
  
  See L<Config::Tiny::Ordered> (and possibly others) for the preservation of the order of the entries in the file.
  
  =head1 COPYRIGHT
  
  Copyright 2002 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
CONFIG_TINY

$fatpacked{"Digest/MD5/File.pm"} = <<'DIGEST_MD5_FILE';
  package Digest::MD5::File;
  
  use strict;
  use warnings;
  use Carp;
  use Digest::MD5;
  eval { require Encode; };
  use LWP::UserAgent;
  
  require Exporter;
  our @ISA = qw(Exporter Digest::MD5);
  our @EXPORT_OK = qw(dir_md5  dir_md5_hex  dir_md5_base64 
                      file_md5 file_md5_hex file_md5_base64 
                      url_md5  url_md5_hex  url_md5_base64);
  
  our $BINMODE  = 1;
  our $UTF8     = 0;
  our $NOFATALS = 0;
  
  sub import {
      my $me = shift;
      my %imp;
  
      @imp{ @_ } = ();
      for(@EXPORT_OK) {
          delete $imp{$_} if exists($imp{$_});
      }
  
      $BINMODE  = 0 if exists $imp{-nobin};
      $UTF8     = 1 if exists $imp{-utf8};
      $NOFATALS = 1 if exists $imp{-nofatals};
  
      for(keys %imp) { 
          s/^-//;
          $imp{$_}='' unless $_ =~ m/^(no)?(bin|utf8|fatals)$/;
          push @EXPORT_OK, $_ unless $_ =~ m/^(no)?(bin|utf8|fatals)$/;
          delete $imp{"-$_"} if exists $imp{"-$_"};
      }
  
      $me->export_to_level(1, $me, grep(!/^-/, @_));
      Digest::MD5->import(keys %imp);
  }
  
  our $VERSION = '0.08';
  
  my $getfh = sub {
      my $file = shift;
  
      croak "$file: Does not exist" if !-e $file && !$NOFATALS;
      croak "$file: Is a directory" if -d $file && !$NOFATALS;
  
      if(-e $file && !-d $file) {
          open my $fh, $file or return;
          binmode $fh if $BINMODE;
          return $fh;
      } 
      else { return undef; }
  };
  
  my $getur = sub {
      my $res = LWP::UserAgent->new->get(shift());
      return $res->is_success ? $res->content : undef;
  };
  
  sub Digest::MD5::adddir {
      my $md5  = shift;
      my $base = shift;
      for my $key ( sort keys %{ _dir($base, undef, undef, 3) }) {
          next if !$key;
          my $file = File::Spec->catfile($base, $key);
          $md5->addpath($file) or carp "addpath $file failed: $!" if !-d $file;
      }
      return 1;
  }
  
  sub _dir {
      my($dir, $hr, $base, $type, $cc) = @_;
      require File::Spec;  # only load it if its needed
  
      $cc   = {} if ref $cc ne 'HASH'; 
      $hr   = {} if ref $hr ne 'HASH';
      $base = $dir if !defined $base;
      $type = 0 if ! defined $type;
  
      my $_md5func = \&file_md5;
      $_md5func    = \&file_md5_hex    if $type eq '1';
      $_md5func    = \&file_md5_base64 if $type eq '2';   
  
      opendir(DIR, $dir) or return;
      my @dircont = sort grep { $_ ne '.' && $_ ne '..' } readdir(DIR);
      closedir DIR;
  
      for my $file( @dircont ) {
          my $_dirver = File::Spec->catdir($dir, $file);
          my $full    = -d $_dirver ? $_dirver 
                                    : File::Spec->catfile($dir, $file);
  
          my $short = File::Spec->abs2rel( $full, $base );
  		
          if(-l $full) {
              my $target = readlink $full;
              $full      = $target if -d $target;
          }
  
          if(exists $hr->{$full}) {
              carp "$full seen already, you may have circular links";
              $cc->{$full}++;
              croak "$full is in a circular link, bailing out." 
                  if $cc->{$full} > 4;
          }
  
          if(-d $full) {
              $hr->{ $short } = '';
              _dir($full, $hr, $base, $type, $cc) or return;
          }
          else {
              $hr->{ $short } = '';
              $hr->{ $short } = $_md5func->( $full ) or return if $type ne '3';
          } 
      }   
      return $hr;
  }
  
  sub dir_md5 {
      push @_, undef if @_ < 3;
      push @_, undef if @_ < 3;
      _dir(@_, 0);
  }
  
  sub dir_md5_hex {
      push @_, undef if @_ < 3;
      push @_, undef if @_ < 3;
      _dir(@_, 1);
  }
  
  sub dir_md5_base64 {
      push @_, undef if @_ < 3;
      push @_, undef if @_ < 3;
      _dir(@_, 2);
  }
  
  sub file_md5 {
      my ($file,$bn,$ut)   = @_;
      local $BINMODE = $bn if defined $bn;
      local $UTF8    = $ut if defined $ut;
      my $fh         = $getfh->($file) or return;
      
      my $md5 = Digest::MD5->new();
      my $buf;
      while(my $l = read($fh, $buf, 1024)) {
  	    $md5->add( $UTF8 ? Encode::encode_utf8($buf) : $buf );
      }
      return $md5->digest;
  }
  
  sub file_md5_hex {
      my ($file,$bn,$ut)   = @_;
      local $BINMODE = $bn if defined $bn;
      local $UTF8    = $ut if defined $ut;
      my $fh         = $getfh->($file) or return;
      
      my $md5 = Digest::MD5->new();
      my $buf;
      while(my $l = read($fh, $buf, 1024)) {
  	    $md5->add( $UTF8 ? Encode::encode_utf8($buf) : $buf );
      }
      return $md5->hexdigest;
  } 
  
  sub file_md5_base64 {
      my ($file,$bn,$ut)   = @_;
      local $BINMODE = $bn if defined $bn;
      local $UTF8    = $ut if defined $ut;
      my $fh         = $getfh->($file) or return;
  
      my $md5 = Digest::MD5->new();
      my $buf;
      while(my $l = read($fh, $buf, 1024)) {
  	    $md5->add( $UTF8 ? Encode::encode_utf8($buf) : $buf );
      }
      return $md5->b64digest;
  }
  
  sub url_md5 {
      my $cn      = $getur->(shift()) or return;
      my ($ut)    = shift;
      local $UTF8 = $ut if defined $ut;
      return Digest::MD5::md5($cn) if !$UTF8;
      return Digest::MD5::md5(Encode::encode_utf8($cn));
  }
  
  sub url_md5_hex {
      my $cn      = $getur->(shift()) or return;
      my ($ut)    = shift;
      local $UTF8 = $ut if defined $ut;
      return Digest::MD5::md5_hex($cn) if !$UTF8;
      return Digest::MD5::md5_hex(Encode::encode_utf8($cn));
  }
  
  sub url_md5_base64 { 
      my $cn      = $getur->(shift()) or return;
      my ($ut)    = shift;
      local $UTF8 = $ut if defined $ut;
      return Digest::MD5::md5_base64($cn) if !$UTF8;
      return Digest::MD5::md5_base64(Encode::encode_utf8($cn));
  }
  
  sub Digest::MD5::addpath {
      my $md5          = shift;
      my ($fl,$bn,$ut) = @_;
      local $BINMODE   = $bn if defined $bn;
      local $UTF8      = $ut if defined $ut;
      if(ref $fl eq 'ARRAY') {
          for my $pth (@{ $fl }) {
              $md5->addpath($pth, $bn, $ut) or return;
          }
      } 
      else {
          my $fh = $getfh->($fl) or return;
          my $buf;
          while(my $l = read($fh, $buf, 1024)) {
             !$UTF8 ? $md5->add($buf) : $md5->add(Encode::encode_utf8($buf));
          }
      }
      return 1;
  }
  
  sub Digest::MD5::addurl {
      my $md5     = shift;
      my $cn      = $getur->(shift()) or return;
      my $ut      = shift;
      local $UTF8 = $ut if defined $ut;
      !$UTF8 ? $md5->add($cn) : $md5->add(Encode::encode_utf8($cn));
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Digest::MD5::File - Perl extension for getting MD5 sums for files and urls. 
  
  =head1 SYNOPSIS
  
      use Digest::MD5::File qw(dir_md5_hex file_md5_hex url_md5_hex);
  
      my $md5 = Digest::MD5->new;
      $md5->addpath('/path/to/file');
      my $digest = $md5->hexdigest;
  
      my $digest = file_md5($file);
      my $digest = file_md5_hex($file);
      my $digest = file_md5_base64($file);
  
      my $md5 = Digest::MD5->new;
      $md5->addurl('http://www.tmbg.com/tour.html');
      my $digest = $md5->hexdigest;
  
      my $digest = url_md5($url);
      my $digest = url_md5_hex($url);
      my $digest = url_md5_base64($url);
    
      my $md5 = Digest::MD5->new;
      $md5->adddir('/directory');
      my $digest = $md5->hexdigest;
  
      my $dir_hashref = dir_md5($dir);    
      my $dir_hashref = dir_md5_hex($dir);    
      my $dir_hashref = dir_md5_base64($dir);
  
  =head1 DESCRIPTION
  
    Get MD5 sums for files of a given path or content of a given url.
  
  =head1 EXPORT
  
  None by default.
  You can export any file_* dir_*, or url_* function and anything L<Digest::MD5> can export.
  
     use Digest::MD5::File qw(md5 md5_hex md5_base64); # 3 Digest::MD5 functions
     print md5_hex('abc123'), "\n";
     print md5_base64('abc123'), "\n";
  
  =head1 OBJECT METHODS
  
  =head2 addpath()
  
      my $md5 = Digest::MD5->new;
      $md5->addpath('/path/to/file.txt') 
          or die "file.txt is not where you said: $!";
  
  or you can add multiple files by specifying an array ref of files:
  
      $md5->addpath(\@files);
  
  =head2 adddir()
   
  addpath()s each file in a directory recursively. Follows the same rules as the dir_* functions.
  
      my $md5 = Digest::MD5->new;
      $md5->adddir('/home/tmbg/') 
          or die "See warning above to see why I bailed: $!";
  
  =head2 addurl()
  
      my $md5 = Digest::MD5->new;
      $md5->addurl('http://www.tmbg.com/tour.html')
          or die "They Must Be not on tour";
  
  =head1 file_* functions
  
  Get the digest in variouse formats of $file.
  If file does not exist or is a directory it croaks (See NOFATALS for more info)
  
      my $digest = file_md5($file) or warn "$file failed: $!";
      my $digest = file_md5_hex($file) or warn "$file failed: $!";
      my $digest = file_md5_base64($file) or warn "$file failed: $!";
  
  =head1 dir_* functions
  
  Returns a hashref whose keys are files relative to the given path and the values are the MD5 sum of the file or and empty string if a directory.
  It recurses through the entire depth of the directory.
  Symlinks to files are just addpath()d and symlinks to directories are followed.
  
      my $dir_hashref = dir_md5($dir) or warn "$dir failed: $!";
      my $dir_hashref = dir_md5_hex($dir) or warn "$dir failed: $!";
      my $dir_hashref = dir_md5_base64($dir) or warn "$dir failed: $!";
  
  =head1 url_* functions
  
  Get the digest in various formats of the content at $url (Including, if $url points to directory, the directory listing content).
  Returns undef if url fails (IE if L<LWP::UserAgent>'s $res->is_success is false)
  
      my $digest = url_md5($url) or warn "$url failed"; 
      my $digest = url_md5_hex($url) or warn "$url failed";
      my $digest = url_md5_base64($url) or warn "$url failed";
  
  =head1 SPECIAL SETTINGS
  
  =head2 BINMODE
  
  By default files are opened in binmode. If you do not want to do this you can unset it a variety of ways:
  
      use Digest::MD5::File qw(-nobin);
  
  or
  
      $Digest::MD5::File::BINMODE = 0;
  
  or at the function/method level by specifying its value as the second argument:
  
      $md5->addpath($file,0);
  
      my $digest = file_md5_hex($file,0);
  
  =head2 UTF8
  
  In some cases you may want to have your data utf8 encoded, you can do this the following ways:
  
      use Digest::MD5::File qw(-utf8);
  
  or
  
      $Digest::MD5::File::UTF8 = 1;
  
  or at the function/method level by specifying its value as the third argument for files and second for urls:
  
      $md5->addpath($file,$binmode,1);
  
      my $digest = file_md5_hex($file,$binmode,1);
  
      $md5->addurl($url,1);
  
      url_md5_hex($url,1);
  
  It use's L<Encode>'s encode_utf8() function to do the encoding. So if you do not have Encode (pre 5.7.3) this won't work :)
  
  =head2 NOFATALS
  
  Instead of croaking it will return undef if you set NOFATALS to true.
  
  You can do this two ways:
  
      $Digest::MD5::File::NOFATALS = 1;
  
  or the -nofatals flag:
  
      use Digest::MD5::File qw(-nofatals);
  
      my $digest = file_md5_hex($file) or die "$file failed";
  
  $! is not set so its not really helpful if you die(). 
  
  =head1 SEE ALSO
  
  L<Digest::MD5>, L<Encode>, L<LWP::UserAgent>
  
  =head1 AUTHOR
  
  Daniel Muey, L<http://drmuey.com/cpan_contact.pl>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2005 by Daniel Muey
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
DIGEST_MD5_FILE

$fatpacked{"Encode/Locale.pm"} = <<'ENCODE_LOCALE';
  package Encode::Locale;
  
  use strict;
  our $VERSION = "1.03";
  
  use base 'Exporter';
  our @EXPORT_OK = qw(
      decode_argv env
      $ENCODING_LOCALE $ENCODING_LOCALE_FS
      $ENCODING_CONSOLE_IN $ENCODING_CONSOLE_OUT
  );
  
  use Encode ();
  use Encode::Alias ();
  
  our $ENCODING_LOCALE;
  our $ENCODING_LOCALE_FS;
  our $ENCODING_CONSOLE_IN;
  our $ENCODING_CONSOLE_OUT;
  
  sub DEBUG () { 0 }
  
  sub _init {
      if ($^O eq "MSWin32") {
  	unless ($ENCODING_LOCALE) {
  	    # Try to obtain what the Windows ANSI code page is
  	    eval {
  		unless (defined &GetACP) {
  		    require Win32::API;
  		    Win32::API->Import('kernel32', 'int GetACP()');
  		};
  		if (defined &GetACP) {
  		    my $cp = GetACP();
  		    $ENCODING_LOCALE = "cp$cp" if $cp;
  		}
  	    };
  	}
  
  	unless ($ENCODING_CONSOLE_IN) {
  	    # If we have the Win32::Console module installed we can ask
  	    # it for the code set to use
  	    eval {
  		require Win32::Console;
  		my $cp = Win32::Console::InputCP();
  		$ENCODING_CONSOLE_IN = "cp$cp" if $cp;
  		$cp = Win32::Console::OutputCP();
  		$ENCODING_CONSOLE_OUT = "cp$cp" if $cp;
  	    };
  	    # Invoking the 'chcp' program might also work
  	    if (!$ENCODING_CONSOLE_IN && (qx(chcp) || '') =~ /^Active code page: (\d+)/) {
  		$ENCODING_CONSOLE_IN = "cp$1";
  	    }
  	}
      }
  
      unless ($ENCODING_LOCALE) {
  	eval {
  	    require I18N::Langinfo;
  	    $ENCODING_LOCALE = I18N::Langinfo::langinfo(I18N::Langinfo::CODESET());
  
  	    # Workaround of Encode < v2.25.  The "646" encoding  alias was
  	    # introduced in Encode-2.25, but we don't want to require that version
  	    # quite yet.  Should avoid the CPAN testers failure reported from
  	    # openbsd-4.7/perl-5.10.0 combo.
  	    $ENCODING_LOCALE = "ascii" if $ENCODING_LOCALE eq "646";
  
  	    # https://rt.cpan.org/Ticket/Display.html?id=66373
  	    $ENCODING_LOCALE = "hp-roman8" if $^O eq "hpux" && $ENCODING_LOCALE eq "roman8";
  	};
  	$ENCODING_LOCALE ||= $ENCODING_CONSOLE_IN;
      }
  
      if ($^O eq "darwin") {
  	$ENCODING_LOCALE_FS ||= "UTF-8";
      }
  
      # final fallback
      $ENCODING_LOCALE ||= $^O eq "MSWin32" ? "cp1252" : "UTF-8";
      $ENCODING_LOCALE_FS ||= $ENCODING_LOCALE;
      $ENCODING_CONSOLE_IN ||= $ENCODING_LOCALE;
      $ENCODING_CONSOLE_OUT ||= $ENCODING_CONSOLE_IN;
  
      unless (Encode::find_encoding($ENCODING_LOCALE)) {
  	my $foundit;
  	if (lc($ENCODING_LOCALE) eq "gb18030") {
  	    eval {
  		require Encode::HanExtra;
  	    };
  	    if ($@) {
  		die "Need Encode::HanExtra to be installed to support locale codeset ($ENCODING_LOCALE), stopped";
  	    }
  	    $foundit++ if Encode::find_encoding($ENCODING_LOCALE);
  	}
  	die "The locale codeset ($ENCODING_LOCALE) isn't one that perl can decode, stopped"
  	    unless $foundit;
  
      }
  
      # use Data::Dump; ddx $ENCODING_LOCALE, $ENCODING_LOCALE_FS, $ENCODING_CONSOLE_IN, $ENCODING_CONSOLE_OUT;
  }
  
  _init();
  Encode::Alias::define_alias(sub {
      no strict 'refs';
      no warnings 'once';
      return ${"ENCODING_" . uc(shift)};
  }, "locale");
  
  sub _flush_aliases {
      no strict 'refs';
      for my $a (keys %Encode::Alias::Alias) {
  	if (defined ${"ENCODING_" . uc($a)}) {
  	    delete $Encode::Alias::Alias{$a};
  	    warn "Flushed alias cache for $a" if DEBUG;
  	}
      }
  }
  
  sub reinit {
      $ENCODING_LOCALE = shift;
      $ENCODING_LOCALE_FS = shift;
      $ENCODING_CONSOLE_IN = $ENCODING_LOCALE;
      $ENCODING_CONSOLE_OUT = $ENCODING_LOCALE;
      _init();
      _flush_aliases();
  }
  
  sub decode_argv {
      die if defined wantarray;
      for (@ARGV) {
  	$_ = Encode::decode(locale => $_, @_);
      }
  }
  
  sub env {
      my $k = Encode::encode(locale => shift);
      my $old = $ENV{$k};
      if (@_) {
  	my $v = shift;
  	if (defined $v) {
  	    $ENV{$k} = Encode::encode(locale => $v);
  	}
  	else {
  	    delete $ENV{$k};
  	}
      }
      return Encode::decode(locale => $old) if defined wantarray;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Encode::Locale - Determine the locale encoding
  
  =head1 SYNOPSIS
  
    use Encode::Locale;
    use Encode;
  
    $string = decode(locale => $bytes);
    $bytes = encode(locale => $string);
  
    if (-t) {
        binmode(STDIN, ":encoding(console_in)");
        binmode(STDOUT, ":encoding(console_out)");
        binmode(STDERR, ":encoding(console_out)");
    }
  
    # Processing file names passed in as arguments
    my $uni_filename = decode(locale => $ARGV[0]);
    open(my $fh, "<", encode(locale_fs => $uni_filename))
       || die "Can't open '$uni_filename': $!";
    binmode($fh, ":encoding(locale)");
    ...
  
  =head1 DESCRIPTION
  
  In many applications it's wise to let Perl use Unicode for the strings it
  processes.  Most of the interfaces Perl has to the outside world are still byte
  based.  Programs therefore need to decode byte strings that enter the program
  from the outside and encode them again on the way out.
  
  The POSIX locale system is used to specify both the language conventions
  requested by the user and the preferred character set to consume and
  output.  The C<Encode::Locale> module looks up the charset and encoding (called
  a CODESET in the locale jargon) and arranges for the L<Encode> module to know
  this encoding under the name "locale".  It means bytes obtained from the
  environment can be converted to Unicode strings by calling C<<
  Encode::encode(locale => $bytes) >> and converted back again with C<<
  Encode::decode(locale => $string) >>.
  
  Where file systems interfaces pass file names in and out of the program we also
  need care.  The trend is for operating systems to use a fixed file encoding
  that don't actually depend on the locale; and this module determines the most
  appropriate encoding for file names. The L<Encode> module will know this
  encoding under the name "locale_fs".  For traditional Unix systems this will
  be an alias to the same encoding as "locale".
  
  For programs running in a terminal window (called a "Console" on some systems)
  the "locale" encoding is usually a good choice for what to expect as input and
  output.  Some systems allows us to query the encoding set for the terminal and
  C<Encode::Locale> will do that if available and make these encodings known
  under the C<Encode> aliases "console_in" and "console_out".  For systems where
  we can't determine the terminal encoding these will be aliased as the same
  encoding as "locale".  The advice is to use "console_in" for input known to
  come from the terminal and "console_out" for output known to go from the
  terminal.
  
  In addition to arranging for various Encode aliases the following functions and
  variables are provided:
  
  =over
  
  =item decode_argv( )
  
  =item decode_argv( Encode::FB_CROAK )
  
  This will decode the command line arguments to perl (the C<@ARGV> array) in-place.
  
  The function will by default replace characters that can't be decoded by
  "\x{FFFD}", the Unicode replacement character.
  
  Any argument provided is passed as CHECK to underlying Encode::decode() call.
  Pass the value C<Encode::FB_CROAK> to have the decoding croak if not all the
  command line arguments can be decoded.  See L<Encode/"Handling Malformed Data">
  for details on other options for CHECK.
  
  =item env( $uni_key )
  
  =item env( $uni_key => $uni_value )
  
  Interface to get/set environment variables.  Returns the current value as a
  Unicode string. The $uni_key and $uni_value arguments are expected to be
  Unicode strings as well.  Passing C<undef> as $uni_value deletes the
  environment variable named $uni_key.
  
  The returned value will have the characters that can't be decoded replaced by
  "\x{FFFD}", the Unicode replacement character.
  
  There is no interface to request alternative CHECK behavior as for
  decode_argv().  If you need that you need to call encode/decode yourself.
  For example:
  
      my $key = Encode::encode(locale => $uni_key, Encode::FB_CROAK);
      my $uni_value = Encode::decode(locale => $ENV{$key}, Encode::FB_CROAK);
  
  =item reinit( )
  
  =item reinit( $encoding )
  
  Reinitialize the encodings from the locale.  You want to call this function if
  you changed anything in the environment that might influence the locale.
  
  This function will croak if the determined encoding isn't recognized by
  the Encode module.
  
  With argument force $ENCODING_... variables to set to the given value.
  
  =item $ENCODING_LOCALE
  
  The encoding name determined to be suitable for the current locale.
  L<Encode> know this encoding as "locale".
  
  =item $ENCODING_LOCALE_FS
  
  The encoding name determined to be suiteable for file system interfaces
  involving file names.
  L<Encode> know this encoding as "locale_fs".
  
  =item $ENCODING_CONSOLE_IN
  
  =item $ENCODING_CONSOLE_OUT
  
  The encodings to be used for reading and writing output to the a console.
  L<Encode> know these encodings as "console_in" and "console_out".
  
  =back
  
  =head1 NOTES
  
  This table summarizes the mapping of the encodings set up
  by the C<Encode::Locale> module:
  
    Encode      |         |              |
    Alias       | Windows | Mac OS X     | POSIX
    ------------+---------+--------------+------------
    locale      | ANSI    | nl_langinfo  | nl_langinfo
    locale_fs   | ANSI    | UTF-8        | nl_langinfo
    console_in  | OEM     | nl_langinfo  | nl_langinfo
    console_out | OEM     | nl_langinfo  | nl_langinfo
  
  =head2 Windows
  
  Windows has basically 2 sets of APIs.  A wide API (based on passing UTF-16
  strings) and a byte based API based a character set called ANSI.  The
  regular Perl interfaces to the OS currently only uses the ANSI APIs.
  Unfortunately ANSI is not a single character set.
  
  The encoding that corresponds to ANSI varies between different editions of
  Windows.  For many western editions of Windows ANSI corresponds to CP-1252
  which is a character set similar to ISO-8859-1.  Conceptually the ANSI
  character set is a similar concept to the POSIX locale CODESET so this module
  figures out what the ANSI code page is and make this available as
  $ENCODING_LOCALE and the "locale" Encoding alias.
  
  Windows systems also operate with another byte based character set.
  It's called the OEM code page.  This is the encoding that the Console
  takes as input and output.  It's common for the OEM code page to
  differ from the ANSI code page.
  
  =head2 Mac OS X
  
  On Mac OS X the file system encoding is always UTF-8 while the locale
  can otherwise be set up as normal for POSIX systems.
  
  File names on Mac OS X will at the OS-level be converted to
  NFD-form.  A file created by passing a NFC-filename will come
  in NFD-form from readdir().  See L<Unicode::Normalize> for details
  of NFD/NFC.
  
  Actually, Apple does not follow the Unicode NFD standard since not all
  character ranges are decomposed.  The claim is that this avoids problems with
  round trip conversions from old Mac text encodings.  See L<Encode::UTF8Mac> for
  details.
  
  =head2 POSIX (Linux and other Unixes)
  
  File systems might vary in what encoding is to be used for
  filenames.  Since this module has no way to actually figure out
  what the is correct it goes with the best guess which is to
  assume filenames are encoding according to the current locale.
  Users are advised to always specify UTF-8 as the locale charset.
  
  =head1 SEE ALSO
  
  L<I18N::Langinfo>, L<Encode>
  
  =head1 AUTHOR
  
  Copyright 2010 Gisle Aas <gisle@aas.no>.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
ENCODE_LOCALE

$fatpacked{"File/BaseDir.pm"} = <<'FILE_BASEDIR';
  package File::BaseDir;
  
  use strict;
  use Carp;
  require File::Spec;
  require Exporter;
  
  our $VERSION = 0.03;
  
  our @ISA = qw(Exporter);
  our %EXPORT_TAGS = (
  	vars => [ qw(
  		xdg_data_home xdg_data_dirs
  		xdg_config_home xdg_config_dirs
  		xdg_cache_home
  	) ],
  	lookup => [ qw(
  		data_home data_dirs data_files
  		config_home config_dirs config_files
  		cache_home
  	) ],
  );
  our @EXPORT_OK = (
  	qw(xdg_data_files xdg_config_files),
  	map @$_, values %EXPORT_TAGS
  );
  
  # Set root and home directories
  my $rootdir = File::Spec->rootdir();
  if ($^O eq 'MSWin32') {
  	$rootdir = 'C:\\'; # File::Spec default depends on CWD
  	$ENV{HOME} ||= $ENV{USERPROFILE} || $ENV{HOMEDRIVE}.$ENV{HOMEPATH};
  		# logic from File::HomeDir::Windows
  }
  my $home = $ENV{HOME};
  unless ($home) {
  	warn "WARNING: HOME is not set, using root: $rootdir\n";
  	$home = $rootdir;
  }
  
  # Set defaults
  our $xdg_data_home = File::Spec->catdir($home, qw/.local share/);
  our @xdg_data_dirs = (
  	File::Spec->catdir($rootdir, qw/usr local share/),
  	File::Spec->catdir($rootdir, qw/usr share/),
  );
  our $xdg_config_home = File::Spec->catdir($home, '.config');
  our @xdg_config_dirs = ( File::Spec->catdir($rootdir, qw/etc xdg/) );
  our $xdg_cache_home = File::Spec->catdir($home, '.cache');
  
  # OO method
  sub new { bless \$VERSION, shift } # what else is there to bless ?
  
  # Variable methods
  sub xdg_data_home { $ENV{XDG_DATA_HOME} || $xdg_data_home }
  
  sub xdg_data_dirs {
  	( $ENV{XDG_DATA_DIRS}
  		? _adapt($ENV{XDG_DATA_DIRS})
  		: @xdg_data_dirs
  	)
  }
  
  sub xdg_config_home {$ENV{XDG_CONFIG_HOME} || $xdg_config_home }
  
  sub xdg_config_dirs {
  	( $ENV{XDG_CONFIG_DIRS}
  		? _adapt($ENV{XDG_CONFIG_DIRS})
  		: @xdg_config_dirs
  	)
  }
  
  sub xdg_cache_home { $ENV{XDG_CACHE_HOME} || $xdg_cache_home }
  
  sub _adapt {
  	map { File::Spec->catdir( split('/', $_) ) } split /[:;]/, shift;
  		# ':' defined in the spec, but ';' is standard on win32
  }
  
  # Lookup methods
  sub data_home { _catfile(xdg_data_home, @_) }
  
  sub data_dirs { _find_files(\&_dir, \@_, xdg_data_home, xdg_data_dirs) }
  
  sub data_files { _find_files(\&_file, \@_, xdg_data_home, xdg_data_dirs) }
  
  sub xdg_data_files { my @dirs = data_files(@_); return @dirs }
  
  sub config_home { _catfile(xdg_config_home, @_) }
  
  sub config_dirs { _find_files(\&_dir, \@_, xdg_config_home, xdg_config_dirs) }
  
  sub config_files { _find_files(\&_file, \@_, xdg_config_home, xdg_config_dirs) }
  
  sub xdg_config_files { my @dirs = config_files(@_); return @dirs }
  
  sub cache_home { _catfile(xdg_cache_home, @_) }
  
  sub _catfile {
  	my $dir = shift;
  	shift if ref $_[0] or $_[0] =~ /::/; # OO call
  	return File::Spec->catfile($dir, @_);
  }
  
  sub _find_files {
  	my $type = shift;
  	my $file = shift;
  	shift @$file if ref $$file[0] or $$file[0] =~ /::/; # OO call
  	#warn "Looking for: @$file\n         in: @_\n";
  	if (wantarray) {
  		return grep { &$type( $_ ) && -r $_ }
  		       map  { File::Spec->catfile($_, @$file) } @_;
  	}
  	else { # prevent unnessecary stats by returning early
  		for (@_) {
  			my $path = File::Spec->catfile($_, @$file);
  			return $path if &$type($path) && -r $path;
  		}
  	}
  	return ();
  }
  
  sub _dir { -d $_[0] }
  
  sub _file { -f $_[0] }
  
  1;
  
  __END__
  
  =head1 NAME
  
  File::BaseDir - Use the Freedesktop.org base directory specification
  
  =head1 SYNOPSIS
  
  	use File::BaseDir qw/xdg_data_files/;
  	for ( xdg_data_files('mime/globs') ) {
  		# do something
  	}
  
  =head1 DESCRIPTION
  
  This module can be used to find directories and files as specified
  by the Freedesktop.org Base Directory Specification. This specifications
  gives a mechanism to locate directories for configuration, application data
  and cache data. It is suggested that desktop applications for e.g. the 
  Gnome, KDE or Xfce platforms follow this layout. However, the same layout can
  just as well be used for non-GUI applications.
  
  This module forked from L<File::MimeInfo>.
  
  This module follows version 0.6 of BaseDir specification.
  
  =head1 EXPORT
  
  None by default, but all methods can be exported on demand.
  Also the groups ":lookup" and ":vars" are defined. The ":vars" group
  contains all routines with a "xdg_" prefix; the ":lookup" group
  contains the routines to locate files and directories.
  
  =head1 METHODS
  
  =over 4
  
  =item C<new()>
  
  Simple constructor to allow Object Oriented use of this module.
  
  =back
  
  =head2 Lookup
  
  The following methods are used to lookup files and folders in one of the
  search paths.
  
  =over 4
  
  =item C<data_home(@PATH)>
  
  Takes a list of file path elements and returns a new path by appending
  them to the data home directory. The new path does not need to exist.
  Use this when writing user specific application data.
  
  Example:
  
    # data_home is: /home/USER/.local/share
    $path = $bd->data_home('Foo', 'Bar', 'Baz');
    # returns: /home/USER/.local/share/Foo/Bar/Baz
  
  =item C<data_dirs(@PATH)>
  
  Looks for directories specified by C<@PATH> in the data home and
  other data directories. Returns (possibly empty) list of readable
  directories. In scalar context only the first directory found is
  returned. Use this to lookup application data.
  
  =item C<data_files(@PATH)>
  
  Looks for files specified by C<@PATH> in the data home and other data
  directories. Only returns files that are readable. In scalar context only
  the first file found is returned. Use this to lookup application data.
  
  =item C<config_home(@PATH)>
  
  Takes a list of path elements and appends them to the config home
  directory returning a new path. The new path does not need to exist.
  Use this when writing user specific configuration.
  
  =item C<config_dirs(@PATH)>
  
  Looks for directories specified by C<@PATH> in the config home and
  other config directories. Returns (possibly empty) list of readable
  directories. In scalar context only the first directory found is
  returned. Use this to lookup configuration.
  
  =item C<config_files(@PATH)>
  
  Looks for files specified by C<@PATH> in the config home and other
  config directories. Returns a (possibly empty) list of files that
  are readable. In scalar context only the first file found is returned.
  Use this to lookup configuration.
  
  =item C<cache_home(@PATH)>
  
  Takes a list of path elements and appends them to the cache home
  directory returning a new path. The new path does not need to exist.
  
  =back
  
  =head2 Variables
  
  The following methods only returns the value of one of the XDG variables.
  
  =over 4
  
  =item C<xdg_data_home>
  
  Returns either C<$ENV{XDG_DATA_HOME}> or it's default value.
  Default is F<$HOME/.local/share>.
  
  =item C<xdg_data_dirs>
  
  Returns either C<$ENV{XDG_DATA_DIRS}> or it's default value as list.
  Default is F</usr/local/share>, F</usr/share>.
  
  =item C<xdg_config_home>
  
  Returns either C<$ENV{XDG_CONFIG_HOME}> or it's default value.
  Default is F<$HOME/.config>.
  
  =item C<xdg_config_dirs>
  
  Returns either C<$ENV{XDG_CONFIG_DIRS}> or it's default value as list.
  Default is F</etc/xdg>.
  
  =item C<xdg_cache_home>
  
  Returns either C<$ENV{XDG_CACHE_HOME}> or it's default value.
  Default is F<$HOME/.cache>.
  
  =back
  
  =head1 NON-UNIX PLATFORMS
  
  The use of L<File::Spec> ensures that all paths are returned in the apropriate
  form for the current platform. On Windows this module will try to set C<$HOME>
  to a sensible value if it is not defined yet. On other platforms one can use
  e.g. L<File::HomeDir> to set $HOME before loading File::BaseDir.
  
  Please note that the specification is targeting Unix platforms only and
  will only have limited relevance on other platforms. Any platform dependend
  behavior in this module should be considerd an extension of the spec.
  
  =head1 BACKWARDS COMPATIBILITY
  
  The methods C<xdg_data_files()> and C<xdg_config_files()> are exported for
  backwards compatibilty with version 0.02. They are identical to C<data_files()>
  and C<config_files()> respectively but without the C<wantarray> behavior.
  
  =head1 BUGS
  
  Please mail the author if you encounter any bugs.
  
  =head1 AUTHOR
  
  Jaap Karssenberg || Pardus [Larus] E<lt>pardus@cpan.orgE<gt>
  
  Copyright (c) 2003, 2007 Jaap G Karssenberg. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<http://www.freedesktop.org/wiki/Specifications/basedir-spec>
  
FILE_BASEDIR

$fatpacked{"File/MimeInfo.pm"} = <<'FILE_MIMEINFO';
  package File::MimeInfo;
  
  use strict;
  use Carp;
  use Fcntl 'SEEK_SET';
  use File::Spec;
  use File::BaseDir qw/data_files/;
  require Exporter;
  
  our @ISA = qw(Exporter);
  our @EXPORT = qw(mimetype);
  our @EXPORT_OK = qw(extensions describe globs inodetype mimetype_canon mimetype_isa);
  our $VERSION = '0.17';
  our $DEBUG;
  
  our ($_hashed, $_hashed_aliases, $_hashed_subclasses);
  our (@globs, %literal, %extension, %mime2ext, %aliases, %subclasses);
  our ($LANG, @DIRS);
  # @globs = [ [ 'glob', qr//, $mime_string ], ... ]
  # %literal contains literal matches
  # %extension contains extensions (globs matching /^\*(\.\w)+$/ )
  # %mime2ext is used for looking up extension by mime type
  # %aliases contains the aliases table
  # %subclasses contains the subclasses table
  # $LANG can be used to set a default language for the comments
  # @DIRS can be used to specify custom database directories
  
  sub new { bless \$VERSION, shift } # what else is there to bless ?
  
  sub mimetype {
  	my $file = pop;
  	croak 'subroutine "mimetype" needs a filename as argument' unless defined $file;
  	croak 'You should use File::MimeInfo::Magic to check open filehandles' if ref $file;
  	return
  		inodetype($file) ||
  		globs($file)	 ||
  		default($file);
  }
  
  sub inodetype {
  	my $file = pop;
  	print STDERR "> Checking inode type\n" if $DEBUG;
  	lstat $file or return undef;
  	return undef if -f _;
  	my $t =	(-l $file) ? 'inode/symlink' :  # Win32 does not like '_' here
  		(-d _) ? 'inode/directory'   :
  		(-p _) ? 'inode/fifo'        :
  		(-c _) ? 'inode/chardevice'  :
  		(-b _) ? 'inode/blockdevice' :
  		(-S _) ? 'inode/socket'      : '' ;
  	if ($t eq 'inode/directory') { # compare devices to detext mount-points
  		my $dev = (stat _)[0]; # device of the node under investigation
  		$file = File::Spec->rel2abs($file); # get full path
  		my @dirs = File::Spec->splitdir($file);
  		$file = File::Spec->catfile(@dirs); # removes trailing '/' or equivalent
  		return $t if -l $file; # parent can be on other dev for links
  		pop @dirs;
  		my $dir = File::Spec->catdir(@dirs); # parent dir
  		$t = 'inode/mount-point' unless (stat $dir)[0] == $dev; # compare devices
  		return $t;
  	}
  	else { return $t ? $t : undef }
  }
  
  sub globs {
  	my $file = pop;
  	croak 'subroutine "globs" needs a filename as argument' unless defined $file;
  	rehash() unless $_hashed;
  	(undef, undef, $file) = File::Spec->splitpath($file); # remove path
  	print STDERR "> Checking globs for basename '$file'\n" if $DEBUG;
  
  	return $literal{$file} if exists $literal{$file};
  
  	if ($file =~ /\.(\w+(\.\w+)*)$/) {
  		my @ext = split /\./, $1;
  		while (@ext) {
  			my $ext = join('.', @ext);
  			print STDERR "> Checking for extension '.$ext'\n" if $DEBUG;
  			warn "WARNING: wantarray behaviour of globs() will change in the future.\n" if wantarray;
  			return wantarray
  				? ($extension{$ext}, $ext)
  				: $extension{$ext}
  				if exists $extension{$ext};
  			shift @ext;
  		}
  	}
  
  	for (@globs) {
  		next unless $file =~ $_->[1];
  		print STDERR "> This file name matches \"$_->[0]\"\n" if $DEBUG;
  		return $_->[2];
  	}
  
  	return globs(lc $file) if $file =~ /[A-Z]/; # recurs
  	return undef;
  }
  
  sub default {
  	my $file = pop;
  	croak 'subroutine "default" needs a filename as argument' unless defined $file;
  
  	my $line;
  	unless (ref $file) {
  		return undef unless -f $file;
  		print STDERR "> File exists, trying default method\n" if $DEBUG;
  		return 'text/plain' if -z $file;
  
  		open FILE, '<', $file or return undef;
  		binmode FILE, ':utf8' unless $] < 5.008;
  		read FILE, $line, 32;
  		close FILE;
  	}
  	else {
  		print STDERR "> Trying default method on object\n" if $DEBUG;
  
  		$file->seek(0, SEEK_SET);
  		$file->read($line, 32);
  	}
  
  	{
  		no warnings; # warnings can be thrown when input not ascii
  		if ($] < 5.008 or ! utf8::valid($line)) {
  			use bytes; # avoid invalid utf8 chars
  			$line =~ s/\s//g; # \m, \n and \t are also control chars
  			return 'text/plain' unless $line =~ /[\x00-\x1F\x7F]/;
  		}
  		else {
  			# use perl to do something intelligent for ascii & utf8
  			return 'text/plain' unless $line =~ /[^[:print:]\s]/;
  		}
  	}
  	print STDERR "> First 10 bytes of the file contain control chars\n" if $DEBUG;
  	return 'application/octet-stream';
  }
  
  sub rehash {
  	(@globs, %literal, %extension, %mime2ext) = (); # clear all data
  	local $_; # limit scope of $_ ... :S
  	my @globfiles = @DIRS
  		? ( grep {-e $_ && -r $_} map "$_/globs", @DIRS )
  		: ( reverse data_files('mime/globs')        );
  	print STDERR << 'EOT' unless @globfiles;
  WARNING: You don't seem to have a mime-info database. The
  shared-mime-info package is available from http://freedesktop.org/ .
  EOT
  	my @done;
  	for my $file (@globfiles) {
  		next if grep {$file eq $_} @done;
  		_hash_globs($file);
  		push @done, $file;
  	}
  	$_hashed = 1;
  }
  
  sub _hash_globs {
  	my $file = shift;
  	open GLOB, '<', $file || croak "Could not open file '$file' for reading" ;
  	binmode GLOB, ':utf8' unless $] < 5.008;
  	my ($string, $glob);
  	while (<GLOB>) {
  		next if /^\s*#/ or ! /\S/; # skip comments and empty lines
  		chomp;
  		($string, $glob) = split /:/, $_, 2;
  		unless ($glob =~ /[\?\*\[]/) { $literal{$glob} = $string }
  		elsif ($glob =~ /^\*\.(\w+(\.\w+)*)$/) {
  		    $extension{$1} = $string;
  		    $mime2ext{$string} = [] if !defined($mime2ext{$string});
  		    push @{$mime2ext{$string}}, $1;
  		} else { unshift @globs, [$glob, _glob_to_regexp($glob), $string] }
  	}
  	close GLOB || croak "Could not open file '$file' for reading" ;
  }
  
  sub _glob_to_regexp {
  	my $glob = shift;
  	$glob =~ s/\./\\./g;
  	$glob =~ s/([?*])/.$1/g;
  	$glob =~ s/([^\w\/\\\.\?\*\[\]])/\\$1/g;
  	qr/^$glob$/;
  }
  
  sub extensions {
  	my $mimet = mimetype_canon(pop @_);
  	rehash() unless $_hashed;
          my $ref = $mime2ext{$mimet} if exists $mime2ext{$mimet};
  	return $ref ? @{$ref}    : undef if wantarray;
          return $ref ? @{$ref}[0] : '';
  }
  
  sub describe {
  	shift if ref $_[0];
  	my ($mt, $lang) = @_;
  	croak 'subroutine "describe" needs a mimetype as argument' unless $mt;
  	$mt = mimetype_canon($mt);
  	$lang = $LANG unless defined $lang;
  	my $att =  $lang ? qq{xml:lang="$lang"} : '';
  	my $desc;
  	my @descfiles = @DIRS
  		? ( grep {-e $_ && -r $_} map "$_/$mt.xml", @DIRS        )
  		: ( reverse data_files('mime', split '/', "$mt.xml") ) ;
  	for my $file (@descfiles) {
  		$desc = ''; # if a file was found, return at least empty string
  		open XML, '<', $file || croak "Could not open file '$file' for reading";
  		binmode XML, ':utf8' unless $] < 5.008;
  		while (<XML>) {
  			next unless m!<comment\s*$att>(.*?)</comment>!;
  			$desc = $1;
  			last;
  		}
  		close XML || croak "Could not open file '$file' for reading";
  		last if $desc;
  	}
  	return $desc;
  }
  
  sub mimetype_canon {
  	my $mimet = pop;
  	croak 'mimetype_canon needs argument' unless defined $mimet;
  	rehash_aliases() unless $_hashed_aliases;
  	return exists($aliases{$mimet}) ? $aliases{$mimet} : $mimet;
  }
  
  sub rehash_aliases {
  	%aliases = _read_map_files('aliases');
  	$_hashed_aliases++;
  }
  
  sub _read_map_files {
  	my ($name, $list) = @_;
  	my @files = @DIRS
  		? ( grep {-e $_ && -r $_} map "$_/$name", @DIRS )
  		: ( reverse data_files("mime/$name")        );
  	my (@done, %map);
  	for my $file (@files) {
  		next if grep {$_ eq $file} @done;
  		open MAP, '<', $file || croak "Could not open file '$file' for reading";
  		binmode MAP, ':utf8' unless $] < 5.008;
  		while (<MAP>) {
  			next if /^\s*#/ or ! /\S/; # skip comments and empty lines
  			chomp;
  			my ($k, $v) = split /\s+/, $_, 2;
  			if ($list) {
  				$map{$k} = [] unless $map{$k};
  				push @{$map{$k}}, $v;
  			}
  			else { $map{$k} = $v }
  		}
  		close MAP;
  		push @done, $file;
  	}
  	return %map;
  }
  
  sub mimetype_isa {
  	my $parent = pop || croak 'mimetype_isa needs argument';
  	my $mimet = pop;
  	if (ref $mimet or ! defined $mimet) {
  		$mimet = mimetype_canon($parent);
  		undef $parent;
  	}
  	else {
  		$mimet = mimetype_canon($mimet);
  		$parent = mimetype_canon($parent);
  	}
  	rehash_subclasses() unless $_hashed_subclasses;
  
  	my @subc;
  	push @subc, 'inode/directory' if $mimet eq 'inode/mount-point';
  	push @subc, @{$subclasses{$mimet}} if exists $subclasses{$mimet};
  	push @subc, 'text/plain' if $mimet =~ m#^text/#;
  	push @subc, 'application/octet-stream' unless $mimet =~ m#^inode/#;
  
  	return $parent ? scalar(grep {$_ eq $parent} @subc) : @subc;
  }
  
  sub rehash_subclasses {
  	%subclasses = _read_map_files('subclasses', 'LIST');
  	$_hashed_subclasses++;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  File::MimeInfo - Determine file type
  
  =head1 SYNOPSIS
  
    use File::MimeInfo;
    my $mime_type = mimetype($file);
  
  =head1 DESCRIPTION
  
  This module can be used to determine the mime type of a file. It
  tries to implement the freedesktop specification for a shared
  MIME database.
  
  For this module shared-mime-info-spec 0.13 was used.
  
  This package only uses the globs file. No real magic checking is
  used. The L<File::MimeInfo::Magic> package is provided for magic typing.
  
  If you want to detemine the mimetype of data in a memory buffer you should
  use L<File::MimeInfo::Magic> in combination with L<IO::Scalar>.
  
  This module loads the various data files when needed. If you want to
  hash data ealier see the C<rehash> methods below.
  
  =head1 EXPORT
  
  The method C<mimetype> is exported by default.
  The methods C<inodetype>, C<globs>, C<extensions>, C<describe>,
  C<mimetype_canon> and C<mimetype_isa> can be exported on demand.
  
  =head1 METHODS
  
  =over 4
  
  =item C<new()>
  
  Simple constructor to allow Object Oriented use of this module.
  If you want to use this, include the package as C<use File::MimeInfo ();>
  to avoid importing sub C<mimetype()>.
  
  =item C<mimetype($file)>
  
  Returns a mimetype string for C<$file>, returns undef on failure.
  
  This method bundles C<inodetype> and C<globs>.
  
  If these methods are unsuccessful the file is read and the mimetype defaults
  to 'text/plain' or to 'application/octet-stream' when the first ten chars
  of the file match ascii control chars (white spaces excluded).
  If the file doesn't exist or isn't readable C<undef> is returned.
  
  =item C<inodetype($file)>
  
  Returns a mimetype in the 'inode' namespace or undef when the file is
  actually a normal file.
  
  =item C<globs($file)>
  
  Returns a mimetype string for C<$file> based on the filename and filename extensions.
  Returns undef on failure. The file doesn't need to exist.
  
  Behaviour in list context (wantarray) is unspecified and will change in future
  releases.
  
  =item C<default($file)>
  
  This method decides whether a file is binary or plain text by looking at
  the first few bytes in the file. Used to decide between "text/plain" and
  "application/octet-stream" if all other methods have failed.
  
  The spec states that we should check for the ascii control chars and let
  higher bit chars pass to allow utf8. We try to be more intelligent using
  perl utf8 support.
  
  =item C<extensions($mimetype)>
  
  In list context, returns the list of filename extensions that map to the given mimetype.
  In scalar context, returns the first extension that is found in the database
  for this mimetype.
  
  =item C<describe($mimetype, $lang)>
  
  Returns a description of this mimetype as supplied by the mime info database.
  You can specify a language with the optional parameter C<$lang>, this should be
  the two letter language code used in the xml files. Also you can set the global
  variable C<$File::MimeInfo::LANG> to specify a language.
  
  This method returns undef when no xml file was found (i.e. the mimetype
  doesn't exist in the database). It returns an empty string when the xml file doesn't
  contain a description in the language you specified.
  
  I<Currently no real xml parsing is done, it trusts the xml files are nicely formatted.>
  
  =item C<mimetype_canon($mimetype)>
  
  Returns the canonical mimetype for a given mimetype.
  Deprecated mimetypes are typically aliased to their canonical variants.
  This method only checks aliases, doesn't check whether the mimetype
  exists.
  
  Use this method as a filter when you take a mimetype as input.
  
  =item C<mimetype_isa($mimetype)>
  
  =item C<mimetype_isa($mimetype, $mimetype)>
  
  When give only one argument this method returns a list with mimetypes that are parent
  classes for this mimetype.
  
  When given two arguments returns true if the second mimetype is a parent class of
  the first one.
  
  This method checks the subclasses table and applies a few rules for implicite
  subclasses.
  
  =item C<rehash()>
  
  Rehash the data files. Glob information is preparsed when this method is called.
  
  If you want to by-pass the XDG basedir system you can specify your database
  directories by setting C<@File::MimeInfo::DIRS>. But normally it is better to
  change the XDG basedir environment variables.
  
  =item C<rehash_aliases()>
  
  Rehashes the F<mime/aliases> files.
  
  =item C<rehash_subclasses()>
  
  Rehashes the F<mime/subclasses> files.
  
  =back
  
  =head1 DIAGNOSTICS
  
  This module throws an exception when it can't find any data files, when it can't
  open a data file it found for reading or when a subroutine doesn't get enough arguments.
  In the first case you either don't have the freedesktop mime info database installed,
  or your environment variables point to the wrong places,
  in the second case you have the database installed, but it is broken
  (the mime info database should logically be world readable).
  
  =head1 TODO
  
  Make an option for using some caching mechanism to reduce init time.
  
  Make C<describe()> use real xml parsing ?
  
  =head1 LIMITATIONS
  
  Perl versions prior to 5.8.0 do not have the ':utf8' IO Layer, thus
  for the default method and for reading the xml files
  utf8 is not supported for these versions.
  
  Since it is not possible to distinguish between encoding types (utf8, latin1, latin2 etc.)
  in a straightforward manner only utf8 is supported (because the spec recommends this).
  
  This module does not yet check extended attributes for a mimetype.
  Patches for this are very welcome.
  
  =head1 BUGS
  
  Please mail the author when you encounter any bugs.
  
  =head1 AUTHOR
  
  Jaap Karssenberg E<lt>pardus@cpan.orgE<gt>
  
  Copyright (c) 2003, 2012 Jaap G Karssenberg. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<File::BaseDir>,
  L<File::MimeInfo::Magic>,
  L<File::MimeInfo::Applications>,
  L<File::MimeInfo::Rox>
  
  =over 4
  
  =item related CPAN modules
  
  L<File::MMagic>
  
  =item freedesktop specifications used
  
  L<http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec>,
  L<http://www.freedesktop.org/wiki/Specifications/basedir-spec>,
  L<http://www.freedesktop.org/wiki/Specifications/desktop-entry-spec>
  
  =item freedesktop mime database
  
  L<http://www.freedesktop.org/wiki/Software/shared-mime-info>
  
  =back
  
  =cut
FILE_MIMEINFO

$fatpacked{"File/MimeInfo/Applications.pm"} = <<'FILE_MIMEINFO_APPLICATIONS';
  package File::MimeInfo::Applications;
  
  use strict;
  use Carp;
  use File::Spec;
  use File::BaseDir qw/data_home data_dirs data_files/;
  use File::MimeInfo qw/mimetype_canon mimetype_isa/;
  use File::DesktopEntry;
  require Exporter;
  
  our $VERSION = '0.17';
  
  our @ISA = qw(Exporter);
  our @EXPORT = qw(
  	mime_applications mime_applications_all
  	mime_applications_set_default mime_applications_set_custom
  );
  
  print STDERR << 'EOT' unless data_files(qw/applications mimeinfo.cache/);
  WARNING: You don't seem to have any mimeinfo.cache files.
  Try running the update-desktop-database command. If you
  don't have this command you should install the
  desktop-file-utils package. This package is available from
  http://freedesktop.org/wiki/Software_2fdesktop_2dfile_2dutils
  EOT
  
  sub mime_applications {
  	croak "usage: mime_applications(MIMETYPE)" unless @_ == 1;
  	my $mime = mimetype_canon(shift @_);
  	local $Carp::CarpLevel = $Carp::CarpLevel + 1;
  	return wantarray ? (_default($mime), _others($mime)) : _default($mime);
  }
  
  sub mime_applications_all {
  	croak "usage: mime_applications(MIMETYPE)" unless @_ == 1;
  	my $mime = shift;
  	return mime_applications($mime),
  		grep defined($_), map mime_applications($_), mimetype_isa($mime);
  }
  
  sub mime_applications_set_default {
  	croak "usage: mime_applications_set_default(MIMETYPE, APPLICATION)"
  		unless @_ == 2;
  	my ($mimetype, $desktop_file) = @_;
  	(undef, undef, $desktop_file) =
  		File::Spec->splitpath($desktop_file->{file})
  		if ref $desktop_file;
  	croak "missing desktop entry filename for application"
  		unless length $desktop_file;
  	$desktop_file .= '.desktop' unless $desktop_file =~ /\.desktop$/;
  	_write_list($mimetype, $desktop_file);
  }
  
  sub mime_applications_set_custom {
  	croak "usage: mime_applications_set_custom(MIMETYPE, COMMAND)"
  		unless @_ == 2;
  	my ($mimetype, $command) = @_;
  	$command =~ /(\w+)/;
  	my $word = $1 or croak "COMMAND does not contain a word !?";
  
  	# Algorithm to generate name copied from other implementations
  	my $i = 1;
  	my $desktop_file =
  		data_home('applications', $word.'-usercreated-'.$i.'.desktop');
  	while (-e $desktop_file) {
  		$i++;
  		$desktop_file =
  		data_home('applications', $word.'-usercreated-'.$i.'.desktop');
  	}
  
  	my $object = File::DesktopEntry->new();
  	$object->set(
  		Type      => 'Application',
  		Name      => $word,
  		NoDsiplay => 'true',
  		Exec      => $command,
  	);
  	my (undef, undef, $df) = File::Spec->splitpath($desktop_file);
  	_write_list($mimetype, $df); # creates dir if needed
  	$object->write($desktop_file);
  	return $object;
  }
  
  sub _default {
  	my $mimetype = shift;
  	my $file = data_home(qw/applications defaults.list/);
  	return undef unless -f $file && -r _;
  
  	$Carp::CarpLevel++;
  	my @list = _read_list($mimetype, $file);
  	my $desktop_file = _find_file(reverse @list);
  	$Carp::CarpLevel--;
  
  	return $desktop_file;
  }
  
  sub _others {
  	my $mimetype = shift;
  
  	$Carp::CarpLevel++;
  	my (@list, @done);
  	for my $dir (data_dirs('applications')) {
  		my $cache = File::Spec->catfile($dir, 'mimeinfo.cache');
  		next if grep {$_ eq $cache} @done;
  		push @done, $cache;
  		next unless -f $cache and -r _;
  		for (_read_list($mimetype, $cache)) {
  			my $file = File::Spec->catfile($dir, $_);
  			next unless -f $file and -r _;
  			push @list, File::DesktopEntry->new($file);
  		}
  	}
  	$Carp::CarpLevel--;
  
  	return @list;
  }
  
  sub _read_list { # read list with "mime/type=foo.desktop;bar.desktop" format
  	my ($mimetype, $file) = @_;
  	my @list;
  	open LIST, '<', $file or croak "Could not read file: $file";
  	while (<LIST>) {
  		/^$mimetype=(.*)$/ or next;
  		push @list, grep defined($_), split ';', $1;
  	}
  	close LIST;
  
  	return @list;
  }
  
  sub _write_list {
  	my ($mimetype, $desktop_file) = @_;
  	my $file = data_home(qw/applications defaults.list/);
  	my $text;
  	if (-f $file) {
  		open LIST, '<', $file or croak "Could not read file: $file";
  		while (<LIST>) {
  			$text .= $_ unless /^$mimetype=/;
  		}
  		close LIST;
  		$text =~ s/[\n\r]?$/\n/; # just to be sure
  	}
  	else {
  		_mkdir($file);
  		$text = "[Default Applications]\n";
  	}
  
  	open LIST, '>', $file or croak "Could not write file: $file";
  	print LIST $text;
  	print LIST "$mimetype=$desktop_file;\n";
  	close LIST or croak "Could not write file: $file";
  }
  
  sub _find_file {
  	my @list = shift;
  	for (@list) {
  		my $file = data_files('applications', $_);
  		return File::DesktopEntry->new($file) if $file;
  	}
  	return undef;
  }
  
  sub _mkdir {
  	my $dir = shift;
  	return if -d $dir;
  
  	my ($vol, $dirs, undef) = File::Spec->splitpath($dir);
  	my @dirs = File::Spec->splitdir($dirs);
  	my $path = File::Spec->catpath($vol, shift @dirs);
  	while (@dirs) {
  		mkdir $path; # fails silently
  		$path = File::Spec->catdir($path, shift @dirs);
  	}
  
  	die "Could not create dir: $path\n" unless -d $path;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  File::MimeInfo::Applications - Find programs to open a file by mimetype
  
  =head1 SYNOPSIS
  
    use File::MimeInfo::Magic;
    use File::MimeInfo::Applications;
  
    my $file = '/foo/bar';
    my $mimetype = mimetype($file)
        || die "Could not find mimetype for $file\n";
  
    my ($default, @other) = mime_applications($mimetype);
  
    if (defined $default) {
        $default->system($file)
    }
    else {
  	  # prompt user with choice from @others
  	  # ...
    }
  
  =head1 DESCRIPTION
  
  This module tries to find applications that can open files
  with a certain mimetype. This is done in the way suggested by
  the freedesktop Desktop Entry specification. This module is
  intended to be compatible with file managers and other applications that
  implement this specification.
  
  This module depends on L<File::DesktopEntry> being installed.
  
  To use this module effectively you need to have the desktop-file-utils
  package from freedesktop and run update-desktop-database after installing
  new .desktop files.
  See L<http://www.freedesktop.org/wiki/Software/desktop-file-utils>.
  
  At the moment of writing this module is compatible with the way Nautilus (Gnome)
  and with Thunar (XFCE) handle applications for mimetypes. I understand KDE
  is still working on implementing the freedesktop mime specifications but will
  follow. At the very least all perl applications using this module are using
  the same defaults.
  
  =head1 EXPORT
  
  All methods are exported by default.
  
  =head1 METHODS
  
  =over 4
  
  =item C<mime_applications(MIMETYPE)>
  
  Returns an array of L<File::DesktopEntry> objects. The first
  is the default application for this mimetype, the rest are
  applications that say they can handle this mimetype.
  
  If the first result is undefined there is no default application
  and it is good practice to ask the user which application he wants
  to use.
  
  =item C<mime_applications_all(MIMETYPE)>
  
  Like C<mime_applications()> but also takes into account applications that
  can open mimetypes from which MIMETYPE inherits. Parent mimetypes tell
  something about the data format, all code inherits from text/plain for example.
  
  =item C<mime_applications_set_default(MIMETYPE, APPLICATION)>
  
  Save a default application for this mimetype. This action will
  affect other applications using the same mechanism to find a default
  application.
  
  APPLICATION can either be a File::DesktopEntry object or
  the basename of a .desktop file.
  
  =item C<mime_applications_set_custom(MIMETYPE, COMMAND)>
  
  Save a custom shell command as default application.
  Generates a DesktopEntry file on the fly and calls
  C<mime_applications_set_custom>.
  Returns the DesktopEntry object.
  
  No checks are done at all on COMMAND.
  It should however contain at least one word.
  
  =back
  
  =head1 NOTES
  
  At present the file with defaults is
  F<$XDG_DATA_HOME/applications/defaults.list>.
  This file is not specified in any freedesktop spec and if it gets standardized
  it should probably be located in C<$XDG_CONFIG_HOME>. For this module I tried
  to implement the status quo.
  
  =head1 BUGS
  
  Please mail the author when you encounter any bugs.
  
  =head1 AUTHOR
  
  Jaap Karssenberg E<lt>pardus@cpan.orgE<gt>
  
  Copyright (c) 2005, 2012 Jaap G Karssenberg. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<File::DesktopEntry>,
  L<File::MimeInfo>,
  L<File::MimeInfo::Magic>,
  L<File::BaseDir>
  
  L<http://freedesktop.org/wiki/Software_2fdesktop_2dfile_2dutils>
  
  =cut
FILE_MIMEINFO_APPLICATIONS

$fatpacked{"File/MimeInfo/Magic.pm"} = <<'FILE_MIMEINFO_MAGIC';
  
  package File::MimeInfo::Magic;
  
  use strict;
  use Carp;
  use Fcntl 'SEEK_SET';
  use File::BaseDir qw/data_files/;
  require File::MimeInfo;
  require Exporter;
  
  BEGIN {
  	no strict "refs";
  	for (qw/extensions describe globs inodetype default/) {
  		*{$_} = \&{"File::MimeInfo::$_"};
  	}
  }
  
  our @ISA = qw(Exporter File::MimeInfo);
  our @EXPORT = qw(mimetype);
  our @EXPORT_OK = qw(extensions describe globs inodetype magic);
  our $VERSION = '0.17';
  our $DEBUG;
  
  our $_hashed = 0;
  our (@magic_80, @magic, $max_buffer);
  # @magic_80 and @magic are used to store the parse tree of magic data
  # @magic_80 contains magic rules with priority 80 and higher, @magic the rest
  # $max_buffer contains the maximum number of chars to be buffered from a non-seekable
  # filehandle in order to do magic mimetyping
  
  sub mimetype {
  	my $file = pop;
  	croak 'subroutine "mimetype" needs a filename as argument' unless defined $file;
  
  	return magic($file) || default($file) if ref $file;
  	return &File::MimeInfo::mimetype($file) unless -s $file and -r _;
  
  	my ($mimet, $fh);
  	return $mimet if $mimet = inodetype($file);
  
  	($mimet, $fh) = _magic($file, \@magic_80); # high priority rules
  	return $mimet if $mimet;
  
  	return $mimet if $mimet = globs($file);
  
  	($mimet, $fh) = _magic($fh, \@magic); # lower priority rules
  	close $fh unless ref $file;
  
  	return $mimet if $mimet;
  	return default($file);
  }
  
  sub magic {
  	my $file = pop;
  	croak 'subroutine "magic" needs a filename as argument' unless defined $file;
  	return undef unless ref($file) || -s $file;
  	print STDERR "> Checking all magic rules\n" if $DEBUG;
  
  	my ($mimet, $fh) = _magic($file, \@magic_80, \@magic);
  	close $fh unless ref $file;
  
  	return $mimet;
  }
  
  sub _magic {
  	my ($file, @rules) = @_;
  	_rehash() unless $_hashed;
  
  	my $fh;
  	unless (ref $file) {
  		open $fh, '<', $file or return undef;
  		binmode $fh;
  	}
  	else { $fh = $file }
  
  	for my $type (map @$_, @rules) {
  		for (2..$#$type) {
  			next unless _check_rule($$type[$_], $fh, 0);
  			close $fh unless ref $file;
  			return ($$type[1], $fh);
  		}
  	}
  	return (undef, $fh);
  }
  
  sub _check_rule {
  	my ($ref, $fh, $lev) = @_;
  	my $line;
  
  	# Read
  	if (ref $fh eq 'GLOB') {
  		seek($fh, $$ref[0], SEEK_SET);	# seek offset
  		read($fh, $line, $$ref[1]);	# read max length
  	}
  	else { # allowing for IO::Something
  		$fh->seek($$ref[0], SEEK_SET);	# seek offset
  		$fh->read($line, $$ref[1]);	# read max length
  	}
  
  	# Match regex
  	$line = unpack 'b*', $line if $$ref[2];	# unpack to bits if using mask
  	return undef unless $line =~ $$ref[3];	# match regex
  	print STDERR	'>', '>'x$lev, ' Value "', _escape_bytes($2),
  			'" at offset ', $$ref[1]+length($1),
  			" matches at $$ref[4]\n"
  		if $DEBUG;
  	return 1 unless $#$ref > 4;
  
  	# Check nested rules and recurs
  	for (5..$#$ref) {
  		return 1 if _check_rule($$ref[$_], $fh, $lev+1);
  	}
  	print STDERR "> Failed nested rules\n" if $DEBUG && ! $lev;
  	return 0;
  }
  
  sub rehash {
  	&File::MimeInfo::rehash();
  	&_rehash();
  	#use Data::Dumper;
  	#print Dumper \@magic_80, \@magic;
  }
  
  sub _rehash {
  	local $_; # limit scope of $_ ... :S
  	($max_buffer, @magic_80, @magic) = (32); # clear data
  	my @magicfiles = @File::MimeInfo::DIRS
  		? ( grep {-e $_ && -r $_}
  			map "$_/magic", @File::MimeInfo::DIRS )
  		: ( reverse data_files('mime/magic') ) ;
  	my @done;
  	for my $file (@magicfiles) {
  		next if grep {$file eq $_} @done;
  		_hash_magic($file);
  		push @done, $file;
  	}
  	@magic = sort {$$b[0] <=> $$a[0]} @magic;
  	while ($magic[0][0] >= 80) {
  		push @magic_80, shift @magic;
  	}
  	$_hashed = 1;
  }
  
  sub _hash_magic {
  	my $file = shift;
  
  	open MAGIC, '<', $file
  		|| croak "Could not open file '$file' for reading";
  	binmode MAGIC;
  	<MAGIC> eq "MIME-Magic\x00\n"
  		or carp "Magic file '$file' doesn't seem to be a magic file";
  	my $line = 1;
  	while (<MAGIC>) {
  		$line++;
  
  		if (/^\[(\d+):(.*?)\]\n$/) {
  			push @magic, [$1,$2];
  			next;
  		}
  
  		s/^(\d*)>(\d+)=(.{2})//s
  			|| warn "$file line $line skipped\n" && next;
  		my ($i, $o, $l) = ($1, $2, unpack 'n', $3);
  		                  # indent, offset, value length
  		while (length($_) <= $l) {
  			$_ .= <MAGIC>;
  			$line++;
  		}
  
  		my $v = substr $_, 0, $l, ''; # value
  
  		/^(?:&(.{$l}))?(?:~(\d+))?(?:\+(\d+))?\n$/s
  			|| warn "$file line $line skipped\n" && next;
  		my ($m, $w, $r) = ($1, $2 || 1, $3 || 1);
  		                  # mask, word size, range
  		my $mdef = defined $m;
  
  		# possible big endian to little endian conversion
  		# as a bonus perl also takes care of weird endian cases
  		if ( $w != 1 ) {
  			my ( $utpl, $ptpl );
  			if ( 2 == $w ) {
  				$v = pack 'S', unpack 'n', $v;
  				$m = pack 'S', unpack 'n', $m if $mdef;
  			}
  			elsif ( 4 == $w ) {
  				$v = pack 'L', unpack 'N', $v;
  				$m = pack 'L', unpack 'N', $m if $mdef;
  			}
  			else {
  				warn "Unsupported word size: $w octets ".
  				     " at $file line $line\n"
  			}
  		}
  
  		my $end = $o + $l + $r - 1;
  		$max_buffer = $end if $max_buffer < $end;
  		my $ref = $i ? _find_branch($i) : $magic[-1];
  		$r--;             # 1-based => 0-based range for regex
  		$r *= 8 if $mdef; # bytes => bits for matching a mask
  		my $reg = '^'
  			. ( $r    ? "(.{0,$r}?)" : '()'           )
  			. ( $mdef ? '('. _mask_regex($v, $m) .')'
  			          : '('. quotemeta($v)       .')' ) ;
  		push @$ref, [
  			$o, $end,    # offset, offset+length+range
  			$mdef,       # boolean for mask
  			qr/$reg/sm,  # the regex to match
  			undef	     # debug data
  		];
  		$$ref[-1][-1] = "$file line $line" if $DEBUG;
  	}
  	close MAGIC;
  }
  
  sub _find_branch { # finds last branch of tree of rules
  	my $i = shift;
  	my $ref = $magic[-1];
  	for (1..$i) { $ref = $$ref[-1] }
  	return $ref;
  }
  
  sub _mask_regex { # build regex based on mask
  	my ($v, $m) = @_;
  	my @v = split '', unpack "b*", $v;
  	my @m = split '', unpack "b*", $m;
  	my $re = '';
  	for (0 .. $#m) {
  		$re .= $m[$_] ? $v[$_] : '.' ;
  		# If $mask = 1 than ($input && $mask) will be same as $input
  		# If $mask = 0 than ($input && $mask) is always 0
  		# But $mask = 0 only makes sense if $value = 0
  		# So if $mask = 0 we ignore that bit of $input
  	}
  	return $re;
  }
  
  sub _escape_bytes { # used for debug output
  	my $string = shift;
  	if ($string =~ /[\x00-\x1F\x7F]/) {
  		$string = join '', map {
  			my $o = ord($_);
  			($o < 32)   ? '^' . chr($o + 64) :
  			($o == 127) ? '^?'               : $_ ;
  		} split '', $string;
  	}
  	return $string;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  File::MimeInfo::Magic - Determine file type with magic
  
  =head1 SYNOPSIS
  
  	use File::MimeInfo::Magic;
  	my $mime_type = mimetype($file);
  
  =head1 DESCRIPTION
  
  This module inherits from L<File::MimeInfo>, it is transparent
  to its functions but adds support for the freedesktop magic file.
  
  Magic data is hashed when you need it for the first time.
  If you want to force hashing earlier use the C<rehash()> function.
  
  =head1 EXPORT
  
  The method C<mimetype> is exported by default. The methods C<magic>,
  C<inodetype>, C<globs> and C<describe> can be exported on demand.
  
  =head1 METHODS
  
  See also L<File::MimeInfo> for methods that are inherited.
  
  =over 4
  
  =item C<mimetype($file)>
  
  Returns a mime-type string for C<$file>, returns undef on failure.
  
  This method bundles C<inodetype()>, C<globs()> and C<magic()>.
  
  Magic rules with an priority of 80 and higher are checked before
  C<globs()> is called, all other magic rules afterwards.
  
  If this doesn't work the file is read and the mime-type defaults
  to 'text/plain' or to 'application/octet-stream' when the first ten chars
  of the file match ascii control chars (white spaces excluded).
  If the file doesn't exist or isn't readable C<undef> is returned.
  
  If C<$file> is an object reference only C<magic> and the default method
  are used. See below for details.
  
  =item C<magic($file)>
  
  Returns a mime-type string for C<$file> based on the magic rules,
  returns undef on failure.
  
  C<$file> can be an object reference, in that case it is supposed to have a
  C<seek()> and a C<read()> method. This allows you for example to determine
  the mimetype of data in memory by using L<IO::Scalar>.
  
  Be aware that when using a filehandle or an C<IO::> object you need to set
  the C<:utf8> binmode yourself if apropriate.
  
  =item C<rehash()>
  
  Rehash the data files. Glob and magic
  information is preparsed when this method is called.
  
  If you want to by-pass the XDG basedir system you can specify your database
  directories by setting C<@File::MimeInfo::DIRS>. But normally it is better to
  change the XDG basedir environment variables.
  
  =item C<default>
  
  =item C<describe>
  
  =item C<extensions>
  
  =item C<globs>
  
  =item C<inodetype>
  
  These routines are imported from L<File::MimeInfo>.
  
  =back
  
  =head1 SEE ALSO
  
  L<File::MimeInfo>
  
  =head1 LIMITATIONS
  
  Only word sizes of 1, 2 or 4 are supported. Any other word size is ignored
  and will cause a warning.
  
  =head1 BUGS
  
  Please mail the author when you encounter any bugs.
  
  =head1 AUTHOR
  
  Jaap Karssenberg E<lt>pardus@cpan.orgE<gt>
  
  Copyright (c) 2003, 2012 Jaap G Karssenberg. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
FILE_MIMEINFO_MAGIC

$fatpacked{"File/MimeInfo/Rox.pm"} = <<'FILE_MIMEINFO_ROX';
  package File::MimeInfo::Rox;
  
  use strict;
  use Carp;
  use File::BaseDir qw/config_home data_dirs/;
  use File::Spec;
  require Exporter;
  
  our @ISA = qw(Exporter);
  our @EXPORT = qw(mime_exec mime_system);
  our @EXPORT_OK = qw(suggest_script_name);
  our %EXPORT_TAGS = (magic => \@EXPORT);
  our $VERSION = '0.17';
  our @choicespath = (
  	config_home('rox.sourceforge.net'),
  	File::Spec->catdir($ENV{HOME}, 'Choices'),
  	data_dirs('Choices'),
  );
  our ($DEBUG);
  
  sub import {
  	my $parent = (grep {$_ eq q/:magic/} @_)
  		? q/File::MimeInfo::Magic/
  		: q/File::MimeInfo/;
  	eval "use $parent";
  	die $@ if $@;
  	goto \&Exporter::import;
  }
  
  sub mime_system { _do_mime('system', @_) }
  sub mime_exec   { _do_mime('exec',   @_) }
  
  sub _do_mime {
  	my ($act, $file, $mimet) = (shift, shift, shift);
  
  	$mimet ||= mimetype($file);
  	return undef unless $mimet;
  	print "Using mimetype: $mimet\n" if $DEBUG;
  
  	my $script = _locate_script($mimet);
  	return undef unless $script;
  
  	print "Going to $act: $script $file\n" if $DEBUG;
  	($act eq 'exec')
  		? exec($script, $file, @_)
  		: (system($script, $file, @_) == 0)
  			or croak "couldn't $act: $script $file";
  	42;
  }
  
  sub _locate_script {
  	my $mime = shift;
  	$mime =~ /^(\w+)/;
  	my $media = $1;
  	$mime =~ s#/#_#;
  	my @p = $ENV{CHOICESPATH}
  		? split(/:/, $ENV{CHOICESPATH})
  		: (@choicespath);
  	my $script;
  	for (
  		map("$_/MIME-types/$mime", @p),
  		map("$_/MIME-types/$media", @p)
  	) {
  		print "looking for: $_\n" if $DEBUG;
  		next unless -e $_;
  		$script = $_;
  		last;
  	}
  	return undef unless $script;
  	$script = "$script/AppRun" if -d $script;
  	return -f $script ? $script : undef;
  }
  
  sub suggest_script_name {
  	my $m = pop;
  	$m =~ s#/#_#;
  	my @p = $ENV{CHOICESPATH}
  		? split(/:/, $ENV{CHOICESPATH})
  		: (@choicespath);
  	return "$p[0]/MIME-types", $m;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  File::MimeInfo::Rox - Open files by mimetype "Rox style"
  
  =head1 SYNOPSIS
  
    use File::MimeInfo::Magic;
    use File::MimeInfo::Rox qw/:magic/;
  
    # open some file with the apropriate program
    mime_system($somefile);
  
    # more verbose version
    my $mt = mimetype($somefile)
        || die "Could not find mimetype for $somefile\n";
    mime_system($somefile, $mt)
        || die "No program to open $somefile available\n";
  
  
  =head1 DESCRIPTION
  
  This module tries to mimic the behaviour of the rox file
  browser L<http://rox.sf.net> when "opening" data files.
  It determines the mime type and searches in rox's C<Choices>
  directories for a program to handle that mimetype.
  
  See the rox documentation for an extensive discussion of this
  mechanism.
  
  =head1 EXPORT
  
  The methods C<mime_exec> and C<mime_system> are exported,
  if you use the export tag C<:magic> you get the same methods
  but L<File::MimeInfo::Magic> will be used for mimetype lookup.
  
  =head1 ENVIRONMENT
  
  The environment variable C<CHOICESPATH> is used when searching
  for rox's config dirs. It defaults to
  C<$ENV{HOME}/Choices:/usr/local/share/Choices:/usr/share/Choices>
  
  =head1 METHODS
  
  =over 4
  
  =item C<mime_system($file)>
  
  =item C<mime_system($file, $mimetype, @_)>
  
  Try to open C<$file> with the appropriate program for files of
  it's mimetype. You can use C<$mimetype> to force the mimetype.
  Also if you allready know the mimetype it saves a lot of time
  to just tell it.
  
  If either the mimetype couldn't be determinated or
  no appropriate program could be found C<undef> is returned.
  If the actual L<system> failes an exception is raised.
  
  All remaining arguments are passed on to the handler.
  
  =item C<mime_exec($file)>
  
  =item C<mime_exec($file, $mimetype, @_)>
  
  Like C<mime_system()> but uses L<exec> instead of L<system>,
  so it B<never returns> if successful.
  
  =item C<suggest_script_name($mimetype)>
  
  Returns the list C<($dir, $file)> for the suggested place
  to write new script files (or symlinks) for mimetype C<$mimetype>.
  The suggested dir doesn't need to exist.
  
  =back
  
  =head1 BUGS
  
  Please mail the author when you encounter any bugs.
  
  =head1 AUTHOR
  
  Jaap Karssenberg E<lt>pardus@cpan.orgE<gt>
  
  Copyright (c) 2003, 2012 Jaap G Karssenberg. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<File::MimeInfo>,
  L<File::MimeInfo::Magic>,
  L<http://rox.sourceforce.net>
  
  =cut
FILE_MIMEINFO_ROX

$fatpacked{"File/Next.pm"} = <<'FILE_NEXT';
  package File::Next;
  
  use strict;
  use warnings;
  
  =head1 NAME
  
  File::Next - File-finding iterator
  
  =head1 VERSION
  
  Version 1.12
  
  =cut
  
  our $VERSION = '1.12';
  
  =head1 SYNOPSIS
  
  File::Next is a lightweight, taint-safe file-finding module.
  It's lightweight and has no non-core prerequisites.
  
      use File::Next;
  
      my $files = File::Next::files( '/tmp' );
  
      while ( defined ( my $file = $files->() ) ) {
          # do something...
      }
  
  =head1 OPERATIONAL THEORY
  
  The two major functions, I<files()> and I<dirs()>, return an iterator
  that will walk through a directory tree.  The simplest use case is:
  
      use File::Next;
  
      my $iter = File::Next::files( '/tmp' );
  
      while ( defined ( my $file = $iter->() ) ) {
          print $file, "\n";
      }
  
      # Prints...
      /tmp/foo.txt
      /tmp/bar.pl
      /tmp/baz/1
      /tmp/baz/2.txt
      /tmp/baz/wango/tango/purple.txt
  
  Note that only files are returned by C<files()>'s iterator.
  Directories are ignored.
  
  In list context, the iterator returns a list containing I<$dir>,
  I<$file> and I<$fullpath>, where I<$fullpath> is what would get
  returned in scalar context.
  
  The first parameter to any of the iterator factory functions may
  be a hashref of options.
  
  =head1 ITERATORS
  
  For the three iterators, the \%options are optional.
  
  =head2 files( [ \%options, ] @starting_points )
  
  Returns an iterator that walks directories starting with the items
  in I<@starting_points>.  Each call to the iterator returns another
  regular file.
  
  =head2 dirs( [ \%options, ] @starting_points )
  
  Returns an iterator that walks directories starting with the items
  in I<@starting_points>.  Each call to the iterator returns another
  directory.
  
  =head2 everything( [ \%options, ] @starting_points )
  
  Returns an iterator that walks directories starting with the items
  in I<@starting_points>.  Each call to the iterator returns another
  file, whether it's a regular file, directory, symlink, socket, or
  whatever.
  
  =head2 from_file( [ \%options, ] $filename )
  
  Returns an iterator that iterates over each of the files specified
  in I<$filename>.  If I<$filename> is C<->, then the files are read
  from STDIN.
  
  The files are assumed to be in the file one filename per line.  If
  I<$nul_separated> is passed, then the files are assumed to be
  NUL-separated, as by C<find -print0>.
  
  If there are blank lines or empty filenames in the input stream,
  they are ignored.
  
  Each filename is checked to see that it is a regular file or a named
  pipe.  If the file does not exists or is a directory, then a warning
  is thrown to I<warning_handler>, and the file is skipped.
  
  The following options have no effect in C<from_files>: I<descend_filter>,
  I<sort_files>, I<follow_symlinks>.
  
  =head1 SUPPORT FUNCTIONS
  
  =head2 sort_standard( $a, $b )
  
  A sort function for passing as a C<sort_files> option:
  
      my $iter = File::Next::files( {
          sort_files => \&File::Next::sort_standard,
      }, 't/swamp' );
  
  This function is the default, so the code above is identical to:
  
      my $iter = File::Next::files( {
          sort_files => 1,
      }, 't/swamp' );
  
  =head2 sort_reverse( $a, $b )
  
  Same as C<sort_standard>, but in reverse.
  
  =head2 reslash( $path )
  
  Takes a path with all forward slashes and rebuilds it with whatever
  is appropriate for the platform.  For example 'foo/bar/bat' will
  become 'foo\bar\bat' on Windows.
  
  This is really just a convenience function.  I'd make it private,
  but F<ack> wants it, too.
  
  =cut
  
  =head1 CONSTRUCTOR PARAMETERS
  
  =head2 file_filter -> \&file_filter
  
  The file_filter lets you check to see if it's really a file you
  want to get back.  If the file_filter returns a true value, the
  file will be returned; if false, it will be skipped.
  
  The file_filter function takes no arguments but rather does its work through
  a collection of variables.
  
  =over 4
  
  =item * C<$_> is the current filename within that directory
  
  =item * C<$File::Next::dir> is the current directory name
  
  =item * C<$File::Next::name> is the complete pathname to the file
  
  =back
  
  These are analogous to the same variables in L<File::Find>.
  
      my $iter = File::Next::files( { file_filter => sub { /\.txt$/ } }, '/tmp' );
  
  By default, the I<file_filter> is C<sub {1}>, or "all files".
  
  This filter has no effect if your iterator is only returning directories.
  
  =head2 descend_filter => \&descend_filter
  
  The descend_filter lets you check to see if the iterator should
  descend into a given directory.  Maybe you want to skip F<CVS> and
  F<.svn> directories.
  
      my $descend_filter = sub { $_ ne "CVS" && $_ ne ".svn" }
  
  The descend_filter function takes no arguments but rather does its work through
  a collection of variables.
  
  =over 4
  
  =item * C<$_> is the current filename of the directory
  
  =item * C<$File::Next::dir> is the complete directory name
  
  =back
  
  The descend filter is NOT applied to any directory names specified
  in as I<@starting_points> in the constructor.  For example,
  
      my $iter = File::Next::files( { descend_filter => sub{0} }, '/tmp' );
  
  always descends into I</tmp>, as you would expect.
  
  By default, the I<descend_filter> is C<sub {1}>, or "always descend".
  
  =head2 error_handler => \&error_handler
  
  If I<error_handler> is set, then any errors will be sent through
  it.  By default, this value is C<CORE::die>.  This function must
  NOT return.
  
  =head2 warning_handler => \&warning_handler
  
  If I<warning_handler> is set, then any errors will be sent through
  it.  By default, this value is C<CORE::warn>.  Unlike the
  I<error_handler>, this function must return.
  
  =head2 sort_files => [ 0 | 1 | \&sort_sub]
  
  If you want files sorted, pass in some true value, as in
  C<< sort_files => 1 >>.
  
  If you want a special sort order, pass in a sort function like
  C<< sort_files => sub { $a->[1] cmp $b->[1] } >>.
  Note that the parms passed in to the sub are arrayrefs, where $a->[0]
  is the directory name, $a->[1] is the file name and $a->[2] is the
  full path.  Typically you're going to be sorting on $a->[2].
  
  =head2 follow_symlinks => [ 0 | 1 ]
  
  If set to false, the iterator will ignore any files and directories
  that are actually symlinks.  This has no effect on non-Unixy systems
  such as Windows.  By default, this is true.
  
  Note that this filter does not apply to any of the I<@starting_points>
  passed in to the constructor.
  
  You should not set C<< follow_symlinks => 0 >> unless you specifically
  need that behavior.  Setting C<< follow_symlinks => 0 >> can be a
  speed hit, because File::Next must check to see if the file or
  directory you're about to follow is actually a symlink.
  
  =head2 nul_separated => [ 0 | 1 ]
  
  Used on by the C<from_file> iterator.  Specifies that the files
  listed in the input file are separated by NUL characters, as from
  the C<find> command with the C<-print0> argument.
  
  =cut
  
  use File::Spec ();
  
  our $name; # name of the current file
  our $dir;  # dir of the current file
  
  our %files_defaults;
  our %skip_dirs;
  
  BEGIN {
      %files_defaults = (
          file_filter     => undef,
          descend_filter  => undef,
          error_handler   => sub { CORE::die @_ },
          warning_handler => sub { CORE::warn @_ },
          sort_files      => undef,
          follow_symlinks => 1,
          nul_separated   => 0,
      );
      %skip_dirs = map {($_,1)} (File::Spec->curdir, File::Spec->updir);
  }
  
  
  sub files {
      die _bad_invocation() if @_ && defined($_[0]) && ($_[0] eq __PACKAGE__);
  
      my ($parms,@queue) = _setup( \%files_defaults, @_ );
      my $filter = $parms->{file_filter};
  
      return sub {
          while (@queue) {
              my ($dirname,$file,$fullpath) = splice( @queue, 0, 3 ); ## no critic (ProhibitMagicNumbers)
              if ( -f $fullpath || -p $fullpath || $fullpath =~ m{^/dev/fd} ) {
                  if ( $filter ) {
                      local $_ = $file;
                      local $File::Next::dir = $dirname;
                      local $File::Next::name = $fullpath;
                      next if not $filter->();
                  }
                  return wantarray ? ($dirname,$file,$fullpath) : $fullpath;
              }
              elsif ( -d _ ) {
                  unshift( @queue, _candidate_files( $parms, $fullpath ) );
              }
          } # while
  
          return;
      }; # iterator
  }
  
  
  sub dirs {
      die _bad_invocation() if @_ && defined($_[0]) && ($_[0] eq __PACKAGE__);
  
      my ($parms,@queue) = _setup( \%files_defaults, @_ );
  
      return sub {
          while (@queue) {
              my (undef,undef,$fullpath) = splice( @queue, 0, 3 ); ## no critic (ProhibitMagicNumbers)
              if ( -d $fullpath ) {
                  unshift( @queue, _candidate_files( $parms, $fullpath ) );
                  return $fullpath;
              }
          } # while
  
          return;
      }; # iterator
  }
  
  sub everything {
      die _bad_invocation() if @_ && defined($_[0]) && ($_[0] eq __PACKAGE__);
  
      my ($parms,@queue) = _setup( \%files_defaults, @_ );
      my $filter = $parms->{file_filter};
  
      return sub {
          while (@queue) {
              my ($dirname,$file,$fullpath) = splice( @queue, 0, 3 ); ## no critic (ProhibitMagicNumbers)
              if ( -d $fullpath ) {
                  unshift( @queue, _candidate_files( $parms, $fullpath ) );
              }
              if ( $filter ) {
                  local $_ = $file;
                  local $File::Next::dir  = $dirname;
                  local $File::Next::name = $fullpath;
                  next if not $filter->();
              }
              return wantarray ? ($dirname,$file,$fullpath) : $fullpath;
          } # while
  
          return;
      }; # iterator
  }
  
  sub from_file {
      die _bad_invocation() if @_ && defined($_[0]) && ($_[0] eq __PACKAGE__);
  
      my ($parms,@queue) = _setup( \%files_defaults, @_ );
      my $err  = $parms->{error_handler};
      my $warn = $parms->{error_handler};
  
      my $filename = $queue[1];
  
      if ( !defined($filename) ) {
          $err->( 'Must pass a filename to from_file()' );
          return undef;
      }
  
      my $fh;
      if ( $filename eq '-' ) {
          $fh = \*STDIN;
      }
      else {
          if ( !open( $fh, '<', $filename ) ) {
              $err->( "Unable to open $filename: $!" );
              return undef;
          }
      }
      my $filter = $parms->{file_filter};
  
      return sub {
          local $/ = $parms->{nul_separated} ? "\x00" : $/;
          while ( my $fullpath = <$fh> ) {
              chomp $fullpath;
              next unless $fullpath =~ /./;
              if ( not ( -f $fullpath || -p _ ) ) {
                  $warn->( "$fullpath: No such file" );
                  next;
              }
  
              my ($volume,$dirname,$file) = File::Spec->splitpath( $fullpath );
              if ( $filter ) {
                  local $_ = $file;
                  local $File::Next::dir  = $dirname;
                  local $File::Next::name = $fullpath;
                  next if not $filter->();
              }
              return wantarray ? ($dirname,$file,$fullpath) : $fullpath;
          } # while
          close $fh;
  
          return;
      }; # iterator
  }
  
  sub _bad_invocation {
      my $good = (caller(1))[3];
      my $bad  = $good;
      $bad =~ s/(.+)::/$1->/;
      return "$good must not be invoked as $bad";
  }
  
  sub sort_standard($$)   { return $_[0]->[1] cmp $_[1]->[1] } ## no critic (ProhibitSubroutinePrototypes)
  sub sort_reverse($$)    { return $_[1]->[1] cmp $_[0]->[1] } ## no critic (ProhibitSubroutinePrototypes)
  
  sub reslash {
      my $path = shift;
  
      my @parts = split( /\//, $path );
  
      return $path if @parts < 2;
  
      return File::Spec->catfile( @parts );
  }
  
  
  =head1 PRIVATE FUNCTIONS
  
  =head2 _setup( $default_parms, @whatever_was_passed_to_files() )
  
  Handles all the scut-work for setting up the parms passed in.
  
  Returns a hashref of operational options, combined between
  I<$passed_parms> and I<$defaults>, plus the queue.
  
  The queue prep stuff takes the strings in I<@starting_points> and
  puts them in the format that queue needs.
  
  The C<@queue> that gets passed around is an array that has three
  elements for each of the entries in the queue: $dir, $file and
  $fullpath.  Items must be pushed and popped off the queue three at
  a time (spliced, really).
  
  =cut
  
  sub _setup {
      my $defaults = shift;
      my $passed_parms = ref $_[0] eq 'HASH' ? {%{+shift}} : {}; # copy parm hash
  
      my %passed_parms = %{$passed_parms};
  
      my $parms = {};
      for my $key ( keys %{$defaults} ) {
          $parms->{$key} =
              exists $passed_parms{$key}
                  ? delete $passed_parms{$key}
                  : $defaults->{$key};
      }
  
      # Any leftover keys are bogus
      for my $badkey ( keys %passed_parms ) {
          my $sub = (caller(1))[3]; ## no critic (ProhibitMagicNumbers)
          $parms->{error_handler}->( "Invalid option passed to $sub(): $badkey" );
      }
  
      # If it's not a code ref, assume standard sort
      if ( $parms->{sort_files} && ( ref($parms->{sort_files}) ne 'CODE' ) ) {
          $parms->{sort_files} = \&sort_standard;
      }
      my @queue;
  
      for ( @_ ) {
          my $start = reslash( $_ );
          if (-d $start) {
              push @queue, ($start,undef,$start);
          }
          else {
              push @queue, (undef,$start,$start);
          }
      }
  
      return ($parms,@queue);
  }
  
  =head2 _candidate_files( $parms, $dir )
  
  Pulls out the files/dirs that might be worth looking into in I<$dir>.
  If I<$dir> is the empty string, then search the current directory.
  
  I<$parms> is the hashref of parms passed into File::Next constructor.
  
  =cut
  
  sub _candidate_files {
      my $parms   = shift;
      my $dirname = shift;
  
      my $dh;
      if ( !opendir $dh, $dirname ) {
          $parms->{error_handler}->( "$dirname: $!" );
          return;
      }
  
      my @newfiles;
      my $descend_filter = $parms->{descend_filter};
      my $follow_symlinks = $parms->{follow_symlinks};
      my $sort_sub = $parms->{sort_files};
  
      for my $file ( grep { !exists $skip_dirs{$_} } readdir $dh ) {
          my $has_stat;
  
          # Only do directory checking if we have a descend_filter
          my $fullpath = File::Spec->catdir( $dirname, $file );
          if ( !$follow_symlinks ) {
              next if -l $fullpath;
              $has_stat = 1;
          }
  
          if ( $descend_filter ) {
              if ( $has_stat ? (-d _) : (-d $fullpath) ) {
                  local $File::Next::dir = $fullpath;
                  local $_ = $file;
                  next if not $descend_filter->();
              }
          }
          if ( $sort_sub ) {
              push( @newfiles, [ $dirname, $file, $fullpath ] );
          }
          else {
              push( @newfiles, $dirname, $file, $fullpath );
          }
      }
      closedir $dh;
  
      if ( $sort_sub ) {
          return map { @{$_} } sort $sort_sub @newfiles;
      }
  
      return @newfiles;
  }
  
  =head1 DIAGNOSTICS
  
  =over
  
  =item C<< File::Next::files must not be invoked as File::Next->files >>
  
  =item C<< File::Next::dirs must not be invoked as File::Next->dirs >>
  
  =item C<< File::Next::everything must not be invoked as File::Next->everything >>
  
  =back
  
  The interface functions do not allow for the method invocation syntax and
  throw errors with the messages above. You can work around this limitation
  with L<UNIVERSAL/can>.
  
      for my $file_system_feature (qw(dirs files)) {
          my $iterator = File::Next->can($file_system_feature)->($options, $target_directory);
          while (defined(my $name = $iterator->())) {
              # ...
          }
      }
  
  =head1 SPEED TWEAKS
  
  =over 4
  
  =item * Don't set C<< follow_symlinks => 0 >> unless you need it.
  
  =back
  
  =head1 AUTHOR
  
  Andy Lester, C<< <andy at petdance.com> >>
  
  =head1 BUGS
  
  Please report any bugs or feature requests to
  L<http://github.com/petdance/file-next/issues>.
  
  Note that File::Next does NOT use L<http://rt.cpan.org> for bug tracking.
  
  =head1 SUPPORT
  
  You can find documentation for this module with the perldoc command.
  
      perldoc File::Next
  
  You can also look for information at:
  
  =over 4
  
  =item * File::Next's bug queue
  
  L<http://github.com/petdance/file-next/issues>
  
  =item * AnnoCPAN: Annotated CPAN documentation
  
  L<http://annocpan.org/dist/File-Next>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/File-Next>
  
  =item * Search CPAN
  
  L<http://search.cpan.org/dist/File-Next>
  
  =item * Source code repository
  
  L<http://github.com/petdance/file-next/tree/master>
  
  =back
  
  =head1 ACKNOWLEDGEMENTS
  
  All file-finding in this module is adapted from Mark Jason Dominus'
  marvelous I<Higher Order Perl>, page 126.
  
  Thanks also for bug fixes and typo finding to
  Bruce Woodward,
  Christopher J. Madsen,
  Bernhard Fisseni
  and Rob Hoelz.
  
  =head1 COPYRIGHT & LICENSE
  
  Copyright 2005-2012 Andy Lester.
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the Artistic License version 2.0.
  
  =cut
  
  1; # End of File::Next
FILE_NEXT

$fatpacked{"File/Slurp.pm"} = <<'FILE_SLURP';
  package File::Slurp;
  
  use 5.6.2 ;
  
  use strict;
  use warnings ;
  
  use Carp ;
  use Exporter ;
  use Fcntl qw( :DEFAULT ) ;
  use POSIX qw( :fcntl_h ) ;
  use Errno ;
  #use Symbol ;
  
  use vars qw( @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION ) ;
  @ISA = qw( Exporter ) ;
  
  $VERSION = '9999.19';
  
  my @std_export = qw(
  	read_file
  	write_file
  	overwrite_file
  	append_file
  	read_dir
  ) ;
  
  my @edit_export = qw( 
  	edit_file
  	edit_file_lines
  ) ;
  
  my @ok_export = qw( 
  ) ;
  
  @EXPORT_OK = (
  	@edit_export,
  	qw(
  		slurp
  		prepend_file
  	),
  ) ;
  
  %EXPORT_TAGS = (
  	'all'	=> [ @std_export, @edit_export, @EXPORT_OK ],
  	'edit'	=> [ @edit_export ],
  	'std'	=> [ @std_export ],
  ) ;
  
  @EXPORT = @std_export ;
  
  my $max_fast_slurp_size = 1024 * 100 ;
  
  my $is_win32 = $^O =~ /win32/i ;
  
  # Install subs for various constants that aren't set in older perls
  # (< 5.005).  Fcntl on old perls uses Exporter to define subs without a
  # () prototype These can't be overridden with the constant pragma or
  # we get a prototype mismatch.  Hence this less than aesthetically
  # appealing BEGIN block:
  
  BEGIN {
  	unless( defined &SEEK_SET ) {
  		*SEEK_SET = sub { 0 };
  		*SEEK_CUR = sub { 1 };
  		*SEEK_END = sub { 2 };
  	}
  
  	unless( defined &O_BINARY ) {
  		*O_BINARY = sub { 0 };
  		*O_RDONLY = sub { 0 };
  		*O_WRONLY = sub { 1 };
  	}
  
  	unless ( defined &O_APPEND ) {
  
  		if ( $^O =~ /olaris/ ) {
  			*O_APPEND = sub { 8 };
  			*O_CREAT = sub { 256 };
  			*O_EXCL = sub { 1024 };
  		}
  		elsif ( $^O =~ /inux/ ) {
  			*O_APPEND = sub { 1024 };
  			*O_CREAT = sub { 64 };
  			*O_EXCL = sub { 128 };
  		}
  		elsif ( $^O =~ /BSD/i ) {
  			*O_APPEND = sub { 8 };
  			*O_CREAT = sub { 512 };
  			*O_EXCL = sub { 2048 };
  		}
  	}
  }
  
  # print "OS [$^O]\n" ;
  
  # print "O_BINARY = ", O_BINARY(), "\n" ;
  # print "O_RDONLY = ", O_RDONLY(), "\n" ;
  # print "O_WRONLY = ", O_WRONLY(), "\n" ;
  # print "O_APPEND = ", O_APPEND(), "\n" ;
  # print "O_CREAT   ", O_CREAT(), "\n" ;
  # print "O_EXCL   ", O_EXCL(), "\n" ;
  
  
  *slurp = \&read_file ;
  
  sub read_file {
  
  	my $file_name = shift ;
  	my $opts = ( ref $_[0] eq 'HASH' ) ? shift : { @_ } ;
  
  # this is the optimized read_file for shorter files.
  # the test for -s > 0 is to allow pseudo files to be read with the
  # regular loop since they return a size of 0.
  
  	if ( !ref $file_name && -e $file_name && -s _ > 0 &&
  	     -s _ < $max_fast_slurp_size && !%{$opts} && !wantarray ) {
  
  
  		my $fh ;
  		unless( sysopen( $fh, $file_name, O_RDONLY ) ) {
  
  			@_ = ( $opts, "read_file '$file_name' - sysopen: $!");
  			goto &_error ;
  		}
  
  		my $read_cnt = sysread( $fh, my $buf, -s _ ) ;
  
  		unless ( defined $read_cnt ) {
  
  			@_ = ( $opts,
  				"read_file '$file_name' - small sysread: $!");
  			goto &_error ;
  		}
  
  		$buf =~ s/\015\012/\n/g if $is_win32 ;
  		return $buf ;
  	}
  
  # set the buffer to either the passed in one or ours and init it to the null
  # string
  
  	my $buf ;
  	my $buf_ref = $opts->{'buf_ref'} || \$buf ;
  	${$buf_ref} = '' ;
  
  	my( $read_fh, $size_left, $blk_size ) ;
  
  # deal with ref for a file name
  # it could be an open handle or an overloaded object
  
  	if ( ref $file_name ) {
  
  		my $ref_result = _check_ref( $file_name ) ;
  
  		if ( ref $ref_result ) {
  
  # we got an error, deal with it
  
  			@_ = ( $opts, $ref_result ) ;
  			goto &_error ;
  		}
  
  		if ( $ref_result ) {
  
  # we got an overloaded object and the result is the stringified value
  # use it as the file name
  
  			$file_name = $ref_result ;
  		}
  		else {
  
  # here we have just an open handle. set $read_fh so we don't do a sysopen
  
  			$read_fh = $file_name ;
  			$blk_size = $opts->{'blk_size'} || 1024 * 1024 ;
  			$size_left = $blk_size ;
  		}
  	}
  
  # see if we have a path we need to open
  
  	unless ( $read_fh ) {
  
  # a regular file. set the sysopen mode
  
  		my $mode = O_RDONLY ;
  
  #printf "RD: BINARY %x MODE %x\n", O_BINARY, $mode ;
  
  		$read_fh = local( *FH ) ;
  #		$read_fh = gensym ;
  		unless ( sysopen( $read_fh, $file_name, $mode ) ) {
  			@_ = ( $opts, "read_file '$file_name' - sysopen: $!");
  			goto &_error ;
  		}
  
  		if ( my $binmode = $opts->{'binmode'} ) {
  			binmode( $read_fh, $binmode ) ;
  		}
  
  # get the size of the file for use in the read loop
  
  		$size_left = -s $read_fh ;
  
  #print "SIZE $size_left\n" ;
  
  # we need a blk_size if the size is 0 so we can handle pseudofiles like in
  # /proc. these show as 0 size but have data to be slurped.
  
  		unless( $size_left ) {
  
  			$blk_size = $opts->{'blk_size'} || 1024 * 1024 ;
  			$size_left = $blk_size ;
  		}
  	}
  
  # infinite read loop. we exit when we are done slurping
  
  	while( 1 ) {
  
  # do the read and see how much we got
  
  		my $read_cnt = sysread( $read_fh, ${$buf_ref},
  				$size_left, length ${$buf_ref} ) ;
  
  # since we're using sysread Perl won't automatically restart the call
  # when interrupted by a signal.
  
  		next if $!{EINTR};
  
  		unless ( defined $read_cnt ) {
  
  			@_ = ( $opts, "read_file '$file_name' - loop sysread: $!");
  			goto &_error ;
  		}
  
  # good read. see if we hit EOF (nothing left to read)
  
  		last if $read_cnt == 0 ;
  
  # loop if we are slurping a handle. we don't track $size_left then.
  
  		next if $blk_size ;
  
  # count down how much we read and loop if we have more to read.
  
  		$size_left -= $read_cnt ;
  		last if $size_left <= 0 ;
  	}
  
  # fix up cr/lf to be a newline if this is a windows text file
  
  	${$buf_ref} =~ s/\015\012/\n/g if $is_win32 && !$opts->{'binmode'} ;
  
  	my $sep = $/ ;
  	$sep = '\n\n+' if defined $sep && $sep eq '' ;
  
  # see if caller wants lines
  
  	if( wantarray || $opts->{'array_ref'} ) {
  
  		use re 'taint' ;
  
  		my @lines = length(${$buf_ref}) ?
  			${$buf_ref} =~ /(.*?$sep|.+)/sg : () ;
  
  		chomp @lines if $opts->{'chomp'} ;
  
  # caller wants an array ref
  
  		return \@lines if $opts->{'array_ref'} ;
  
  # caller wants list of lines
  
  		return @lines ;
  	}
  
  # caller wants a scalar ref to the slurped text
  
  	return $buf_ref if $opts->{'scalar_ref'} ;
  
  # caller wants a scalar with the slurped text (normal scalar context)
  
  	return ${$buf_ref} if defined wantarray ;
  
  # caller passed in an i/o buffer by reference (normal void context)
  
  	return ;
  }
  
  # errors in this sub are returned as scalar refs
  # a normal IO/GLOB handle is an empty return
  # an overloaded object returns its stringified as a scalarfilename
  
  sub _check_ref {
  
  	my( $handle ) = @_ ;
  
  # check if we are reading from a handle (GLOB or IO object)
  
  	if ( eval { $handle->isa( 'GLOB' ) || $handle->isa( 'IO' ) } ) {
  
  # we have a handle. deal with seeking to it if it is DATA
  
  		my $err = _seek_data_handle( $handle ) ;
  
  # return the error string if any
  
  		return \$err if $err ;
  
  # we have good handle
  		return ;
  	}
  
  	eval { require overload } ;
  
  # return an error if we can't load the overload pragma
  # or if the object isn't overloaded
  
  	return \"Bad handle '$handle' is not a GLOB or IO object or overloaded"
  		 if $@ || !overload::Overloaded( $handle ) ;
  
  # must be overloaded so return its stringified value
  
  	return "$handle" ;
  }
  
  sub _seek_data_handle {
  
  	my( $handle ) = @_ ;
  
  # DEEP DARK MAGIC. this checks the UNTAINT IO flag of a
  # glob/handle. only the DATA handle is untainted (since it is from
  # trusted data in the source file). this allows us to test if this is
  # the DATA handle and then to do a sysseek to make sure it gets
  # slurped correctly. on some systems, the buffered i/o pointer is not
  # left at the same place as the fd pointer. this sysseek makes them
  # the same so slurping with sysread will work.
  
  	eval{ require B } ;
  
  	if ( $@ ) {
  
  		return <<ERR ;
  Can't find B.pm with this Perl: $!.
  That module is needed to properly slurp the DATA handle.
  ERR
  	}
  
  	if ( B::svref_2object( $handle )->IO->IoFLAGS & 16 ) {
  
  # set the seek position to the current tell.
  
  		unless( sysseek( $handle, tell( $handle ), SEEK_SET ) ) {
  			return "read_file '$handle' - sysseek: $!" ;
  		}
  	}
  
  # seek was successful, return no error string
  
  	return ;
  }
  
  
  sub write_file {
  
  	my $file_name = shift ;
  
  # get the optional argument hash ref from @_ or an empty hash ref.
  
  	my $opts = ( ref $_[0] eq 'HASH' ) ? shift : {} ;
  
  	my( $buf_ref, $write_fh, $no_truncate, $orig_file_name, $data_is_ref ) ;
  
  # get the buffer ref - it depends on how the data is passed into write_file
  # after this if/else $buf_ref will have a scalar ref to the data.
  
  	if ( ref $opts->{'buf_ref'} eq 'SCALAR' ) {
  
  # a scalar ref passed in %opts has the data
  # note that the data was passed by ref
  
  		$buf_ref = $opts->{'buf_ref'} ;
  		$data_is_ref = 1 ;
  	}
  	elsif ( ref $_[0] eq 'SCALAR' ) {
  
  # the first value in @_ is the scalar ref to the data
  # note that the data was passed by ref
  
  		$buf_ref = shift ;
  		$data_is_ref = 1 ;
  	}
  	elsif ( ref $_[0] eq 'ARRAY' ) {
  
  # the first value in @_ is the array ref to the data so join it.
  
  		${$buf_ref} = join '', @{$_[0]} ;
  	}
  	else {
  
  # good old @_ has all the data so join it.
  
  		${$buf_ref} = join '', @_ ;
  	}
  
  # deal with ref for a file name
  
  	if ( ref $file_name ) {
  
  		my $ref_result = _check_ref( $file_name ) ;
  
  		if ( ref $ref_result ) {
  
  # we got an error, deal with it
  
  			@_ = ( $opts, $ref_result ) ;
  			goto &_error ;
  		}
  
  		if ( $ref_result ) {
  
  # we got an overloaded object and the result is the stringified value
  # use it as the file name
  
  			$file_name = $ref_result ;
  		}
  		else {
  
  # we now have a proper handle ref.
  # make sure we don't call truncate on it.
  
  			$write_fh = $file_name ;
  			$no_truncate = 1 ;
  		}
  	}
  
  # see if we have a path we need to open
  
  	unless( $write_fh ) {
  
  # spew to regular file.
  
  		if ( $opts->{'atomic'} ) {
  
  # in atomic mode, we spew to a temp file so make one and save the original
  # file name.
  			$orig_file_name = $file_name ;
  			$file_name .= ".$$" ;
  		}
  
  # set the mode for the sysopen
  
  		my $mode = O_WRONLY | O_CREAT ;
  		$mode |= O_APPEND if $opts->{'append'} ;
  		$mode |= O_EXCL if $opts->{'no_clobber'} ;
  
  		my $perms = $opts->{perms} ;
  		$perms = 0666 unless defined $perms ;
  
  #printf "WR: BINARY %x MODE %x\n", O_BINARY, $mode ;
  
  # open the file and handle any error.
  
  		$write_fh = local( *FH ) ;
  #		$write_fh = gensym ;
  		unless ( sysopen( $write_fh, $file_name, $mode, $perms ) ) {
  
  			@_ = ( $opts, "write_file '$file_name' - sysopen: $!");
  			goto &_error ;
  		}
  	}
  
  	if ( my $binmode = $opts->{'binmode'} ) {
  		binmode( $write_fh, $binmode ) ;
  	}
  
  	sysseek( $write_fh, 0, SEEK_END ) if $opts->{'append'} ;
  
  #print 'WR before data ', unpack( 'H*', ${$buf_ref}), "\n" ;
  
  # fix up newline to write cr/lf if this is a windows text file
  
  	if ( $is_win32 && !$opts->{'binmode'} ) {
  
  # copy the write data if it was passed by ref so we don't clobber the
  # caller's data
  		$buf_ref = \do{ my $copy = ${$buf_ref}; } if $data_is_ref ;
  		${$buf_ref} =~ s/\n/\015\012/g ;
  	}
  
  #print 'after data ', unpack( 'H*', ${$buf_ref}), "\n" ;
  
  # get the size of how much we are writing and init the offset into that buffer
  
  	my $size_left = length( ${$buf_ref} ) ;
  	my $offset = 0 ;
  
  # loop until we have no more data left to write
  
  	do {
  
  # do the write and track how much we just wrote
  
  		my $write_cnt = syswrite( $write_fh, ${$buf_ref},
  				$size_left, $offset ) ;
  
  # since we're using syswrite Perl won't automatically restart the call
  # when interrupted by a signal.
  
  		next if $!{EINTR};
  
  		unless ( defined $write_cnt ) {
  
  			@_ = ( $opts, "write_file '$file_name' - syswrite: $!");
  			goto &_error ;
  		}
  
  # track how much left to write and where to write from in the buffer
  
  		$size_left -= $write_cnt ;
  		$offset += $write_cnt ;
  
  	} while( $size_left > 0 ) ;
  
  # we truncate regular files in case we overwrite a long file with a shorter file
  # so seek to the current position to get it (same as tell()).
  
  	truncate( $write_fh,
  		  sysseek( $write_fh, 0, SEEK_CUR ) ) unless $no_truncate ;
  
  	close( $write_fh ) ;
  
  # handle the atomic mode - move the temp file to the original filename.
  
  	if ( $opts->{'atomic'} && !rename( $file_name, $orig_file_name ) ) {
  
  		@_ = ( $opts, "write_file '$file_name' - rename: $!" ) ;
  		goto &_error ;
  	}
  
  	return 1 ;
  }
  
  # this is for backwards compatibility with the previous File::Slurp module. 
  # write_file always overwrites an existing file
  
  *overwrite_file = \&write_file ;
  
  # the current write_file has an append mode so we use that. this
  # supports the same API with an optional second argument which is a
  # hash ref of options.
  
  sub append_file {
  
  # get the optional opts hash ref
  	my $opts = $_[1] ;
  	if ( ref $opts eq 'HASH' ) {
  
  # we were passed an opts ref so just mark the append mode
  
  		$opts->{append} = 1 ;
  	}
  	else {
  
  # no opts hash so insert one with the append mode
  
  		splice( @_, 1, 0, { append => 1 } ) ;
  	}
  
  # magic goto the main write_file sub. this overlays the sub without touching
  # the stack or @_
  
  	goto &write_file
  }
  
  # prepend data to the beginning of a file
  
  sub prepend_file {
  
  	my $file_name = shift ;
  
  #print "FILE $file_name\n" ;
  
  	my $opts = ( ref $_[0] eq 'HASH' ) ? shift : {} ;
  
  # delete unsupported options
  
  	my @bad_opts =
  		grep $_ ne 'err_mode' && $_ ne 'binmode', keys %{$opts} ;
  
  	delete @{$opts}{@bad_opts} ;
  
  	my $prepend_data = shift ;
  	$prepend_data = '' unless defined $prepend_data ;
  	$prepend_data = ${$prepend_data} if ref $prepend_data eq 'SCALAR' ;
  
  #print "PRE [$prepend_data]\n" ;
  
  	my $err_mode = delete $opts->{err_mode} ;
  	$opts->{ err_mode } = 'croak' ;
  	$opts->{ scalar_ref } = 1 ;
  
  	my $existing_data = eval { read_file( $file_name, $opts ) } ;
  
  	if ( $@ ) {
  
  		@_ = ( { err_mode => $err_mode },
  			"prepend_file '$file_name' - read_file: $!" ) ;
  		goto &_error ;
  	}
  
  #print "EXIST [$$existing_data]\n" ;
  
  	$opts->{atomic} = 1 ;
  	my $write_result =
  		eval { write_file( $file_name, $opts,
  		       $prepend_data, $$existing_data ) ;
  	} ;
  
  	if ( $@ ) {
  
  		@_ = ( { err_mode => $err_mode },
  			"prepend_file '$file_name' - write_file: $!" ) ;
  		goto &_error ;
  	}
  
  	return $write_result ;
  }
  
  # edit a file as a scalar in $_
  
  sub edit_file(&$;$) {
  
  	my( $edit_code, $file_name, $opts ) = @_ ;
  	$opts = {} unless ref $opts eq 'HASH' ;
  
  # 	my $edit_code = shift ;
  # 	my $file_name = shift ;
  # 	my $opts = ( ref $_[0] eq 'HASH' ) ? shift : {} ;
  
  #print "FILE $file_name\n" ;
  
  # delete unsupported options
  
  	my @bad_opts =
  		grep $_ ne 'err_mode' && $_ ne 'binmode', keys %{$opts} ;
  
  	delete @{$opts}{@bad_opts} ;
  
  # keep the user err_mode and force croaking on internal errors
  
  	my $err_mode = delete $opts->{err_mode} ;
  	$opts->{ err_mode } = 'croak' ;
  
  # get a scalar ref for speed and slurp the file into a scalar
  
  	$opts->{ scalar_ref } = 1 ;
  	my $existing_data = eval { read_file( $file_name, $opts ) } ;
  
  	if ( $@ ) {
  
  		@_ = ( { err_mode => $err_mode },
  			"edit_file '$file_name' - read_file: $!" ) ;
  		goto &_error ;
  	}
  
  #print "EXIST [$$existing_data]\n" ;
  
  	my( $edited_data ) = map { $edit_code->(); $_ } $$existing_data ;
  
  	$opts->{atomic} = 1 ;
  	my $write_result =
  		eval { write_file( $file_name, $opts, $edited_data ) } ;
  
  	if ( $@ ) {
  
  		@_ = ( { err_mode => $err_mode },
  			"edit_file '$file_name' - write_file: $!" ) ;
  		goto &_error ;
  	}
  
  	return $write_result ;
  }
  
  sub edit_file_lines(&$;$) {
  
  	my( $edit_code, $file_name, $opts ) = @_ ;
  	$opts = {} unless ref $opts eq 'HASH' ;
  
  # 	my $edit_code = shift ;
  # 	my $file_name = shift ;
  # 	my $opts = ( ref $_[0] eq 'HASH' ) ? shift : {} ;
  
  #print "FILE $file_name\n" ;
  
  # delete unsupported options
  
  	my @bad_opts =
  		grep $_ ne 'err_mode' && $_ ne 'binmode', keys %{$opts} ;
  
  	delete @{$opts}{@bad_opts} ;
  
  # keep the user err_mode and force croaking on internal errors
  
  	my $err_mode = delete $opts->{err_mode} ;
  	$opts->{ err_mode } = 'croak' ;
  
  # get an array ref for speed and slurp the file into lines
  
  	$opts->{ array_ref } = 1 ;
  	my $existing_data = eval { read_file( $file_name, $opts ) } ;
  
  	if ( $@ ) {
  
  		@_ = ( { err_mode => $err_mode },
  			"edit_file_lines '$file_name' - read_file: $!" ) ;
  		goto &_error ;
  	}
  
  #print "EXIST [$$existing_data]\n" ;
  
  	my @edited_data = map { $edit_code->(); $_ } @$existing_data ;
  
  	$opts->{atomic} = 1 ;
  	my $write_result =
  		eval { write_file( $file_name, $opts, @edited_data ) } ;
  
  	if ( $@ ) {
  
  		@_ = ( { err_mode => $err_mode },
  			"edit_file_lines '$file_name' - write_file: $!" ) ;
  		goto &_error ;
  	}
  
  	return $write_result ;
  }
  
  # basic wrapper around opendir/readdir
  
  sub read_dir {
  
  	my $dir = shift ;
  	my $opts = ( ref $_[0] eq 'HASH' ) ? shift : { @_ } ;
  
  # this handle will be destroyed upon return
  
  	local(*DIRH);
  
  # open the dir and handle any errors
  
  	unless ( opendir( DIRH, $dir ) ) {
  
  		@_ = ( $opts, "read_dir '$dir' - opendir: $!" ) ;
  		goto &_error ;
  	}
  
  	my @dir_entries = readdir(DIRH) ;
  
  	@dir_entries = grep( $_ ne "." && $_ ne "..", @dir_entries )
  		unless $opts->{'keep_dot_dot'} ;
  
  	if ( $opts->{'prefix'} ) {
  
  		substr( $_, 0, 0, "$dir/" ) for @dir_entries ;
  	}
  
  	return @dir_entries if wantarray ;
  	return \@dir_entries ;
  }
  
  # error handling section
  #
  # all the error handling uses magic goto so the caller will get the
  # error message as if from their code and not this module. if we just
  # did a call on the error code, the carp/croak would report it from
  # this module since the error sub is one level down on the call stack
  # from read_file/write_file/read_dir.
  
  
  my %err_func = (
  	'carp'	=> \&carp,
  	'croak'	=> \&croak,
  ) ;
  
  sub _error {
  
  	my( $opts, $err_msg ) = @_ ;
  
  # get the error function to use
  
   	my $func = $err_func{ $opts->{'err_mode'} || 'croak' } ;
  
  # if we didn't find it in our error function hash, they must have set
  # it to quiet and we don't do anything.
  
  	return unless $func ;
  
  # call the carp/croak function
  
  	$func->($err_msg) if $func ;
  
  # return a hard undef (in list context this will be a single value of
  # undef which is not a legal in-band value)
  
  	return undef ;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  File::Slurp - Simple and Efficient Reading/Writing/Modifying of Complete Files
  
  =head1 SYNOPSIS
  
    use File::Slurp;
  
  # read in a whole file into a scalar
    my $text = read_file( 'filename' ) ;
  
  # read in a whole file into an array of lines
    my @lines = read_file( 'filename' ) ;
  
  # write out a whole file from a scalar
    write_file( 'filename', $text ) ;
  
  # write out a whole file from an array of lines
    write_file( 'filename', @lines ) ;
  
  # Here is a simple and fast way to load and save a simple config file
  # made of key=value lines.
    my %conf = read_file( $file_name ) =~ /^(\w+)=(.*)$/mg ;
    write_file( $file_name, {atomic => 1}, map "$_=$conf{$_}\n", keys %conf ) ;
  
  # insert text at the beginning of a file
    prepend_file( 'filename', $text ) ;
  
  # in-place edit to replace all 'foo' with 'bar' in file 
    edit_file { s/foo/bar/g } 'filename' ;
  
  # in-place edit to delete all lines with 'foo' from file
    edit_file_lines sub { $_ = '' if /foo/ }, 'filename' ;
  
  # read in a whole directory of file names (skipping . and ..)
    my @files = read_dir( '/path/to/dir' ) ;
  
  =head1 DESCRIPTION
  
  This module provides subs that allow you to read or write entire files
  with one simple call. They are designed to be simple to use, have
  flexible ways to pass in or get the file contents and to be very
  efficient.  There is also a sub to read in all the files in a
  directory other than C<.> and C<..>
  
  These slurp/spew subs work for files, pipes and sockets, stdio,
  pseudo-files, and the DATA handle. Read more about why slurping files is
  a good thing in the file 'slurp_article.pod' in the extras/ directory.
  
  If you are interested in how fast these calls work, check out the
  slurp_bench.pl program in the extras/ directory. It compares many
  different forms of slurping. You can select the I/O direction, context
  and file sizes. Use the --help option to see how to run it.
  
  =head2 B<read_file>
  
  This sub reads in an entire file and returns its contents to the
  caller.  In scalar context it returns the entire file as a single
  scalar. In list context it will return a list of lines (using the
  current value of $/ as the separator including support for paragraph
  mode when it is set to '').
  
    my $text = read_file( 'filename' ) ;
    my $bin = read_file( 'filename' { binmode => ':raw' } ) ;
    my @lines = read_file( 'filename' ) ;
    my $lines = read_file( 'filename', array_ref => 1 ) ;
  
  The first argument is the file to slurp in. If the next argument is a
  hash reference, then it is used as the options. Otherwise the rest of
  the argument list are is used as key/value options.
  
  If the file argument is a handle (if it is a ref and is an IO or GLOB
  object), then that handle is slurped in. This mode is supported so you
  slurp handles such as C<DATA> and C<STDIN>. See the test handle.t for
  an example that does C<open( '-|' )> and the child process spews data
  to the parant which slurps it in.  All of the options that control how
  the data is returned to the caller still work in this case.
  
  If the first argument is an overloaded object then its stringified value
  is used for the filename and that file is opened.  This is a new feature
  in 9999.14. See the stringify.t test for an example.
  
  By default C<read_file> returns an undef in scalar contex or a single
  undef in list context if it encounters an error. Those are both
  impossible to get with a clean read_file call which means you can check
  the return value and always know if you had an error. You can change how
  errors are handled with the C<err_mode> option.
  
  Speed Note: If you call read_file and just get a scalar return value
  it is now optimized to handle shorter files. This is only used if no
  options are used, the file is shorter then 100k bytes, the filename is
  a plain scalar and a scalar file is returned. If you want the fastest
  slurping, use the C<buf_ref> or C<scalar_ref> options (see below)
  
  NOTE: as of version 9999.06, read_file works correctly on the C<DATA>
  handle. It used to need a sysseek workaround but that is now handled
  when needed by the module itself.
  
  You can optionally request that C<slurp()> is exported to your code. This
  is an alias for read_file and is meant to be forward compatible with
  Perl 6 (which will have slurp() built-in).
  
  The options for C<read_file> are:
  
  =head3 binmode
  
  If you set the binmode option, then its value is passed to a call to
  binmode on the opened handle. You can use this to set the file to be
  read in binary mode, utf8, etc. See perldoc -f binmode for more.
  
  	my $bin_data = read_file( $bin_file, binmode => ':raw' ) ;
  	my $utf_text = read_file( $bin_file, binmode => ':utf8' ) ;
  
  =head3 array_ref
  
  If this boolean option is set, the return value (only in scalar
  context) will be an array reference which contains the lines of the
  slurped file. The following two calls are equivalent:
  
  	my $lines_ref = read_file( $bin_file, array_ref => 1 ) ;
  	my $lines_ref = [ read_file( $bin_file ) ] ;
  
  =head3 chomp
  
  If this boolean option is set, the lines are chomped. This only
  happens if you are slurping in a list context or using the
  C<array_ref> option.
  
  =head3 scalar_ref
  
  If this boolean option is set, the return value (only in scalar
  context) will be an scalar reference to a string which is the contents
  of the slurped file. This will usually be faster than returning the
  plain scalar. It will also save memory as it will not make a copy of
  the file to return. Run the extras/slurp_bench.pl script to see speed
  comparisons.
  
  	my $text_ref = read_file( $bin_file, scalar_ref => 1 ) ;
  
  =head3 buf_ref
  
  You can use this option to pass in a scalar reference and the slurped
  file contents will be stored in the scalar. This can be used in
  conjunction with any of the other options. This saves an extra copy of
  the slurped file and can lower ram usage vs returning the file. It is
  usually the fastest way to read a file into a scalar. Run the
  extras/slurp_bench.pl script to see speed comparisons.
  
  
  	read_file( $bin_file, buf_ref => \$buffer ) ;
  
  =head3 blk_size
  
  You can use this option to set the block size used when slurping from
  an already open handle (like \*STDIN). It defaults to 1MB.
  
  	my $text_ref = read_file( $bin_file, blk_size => 10_000_000,
  					     array_ref => 1 ) ;
  
  =head3 err_mode
  
  You can use this option to control how read_file behaves when an error
  occurs. This option defaults to 'croak'. You can set it to 'carp' or to
  'quiet to have no special error handling. This code wants to carp and
  then read another file if it fails.
  
  	my $text_ref = read_file( $file, err_mode => 'carp' ) ;
  	unless ( $text_ref ) {
  
  		# read a different file but croak if not found
  		$text_ref = read_file( $another_file ) ;
  	}
  	
  	# process ${$text_ref}
  
  =head2 B<write_file>
  
  This sub writes out an entire file in one call.
  
    write_file( 'filename', @data ) ;
  
  The first argument to C<write_file> is the filename. The next argument
  is an optional hash reference and it contains key/values that can
  modify the behavior of C<write_file>. The rest of the argument list is
  the data to be written to the file.
  
    write_file( 'filename', {append => 1 }, @data ) ;
    write_file( 'filename', {binmode => ':raw'}, $buffer ) ;
  
  As a shortcut if the first data argument is a scalar or array reference,
  it is used as the only data to be written to the file. Any following
  arguments in @_ are ignored. This is a faster way to pass in the output
  to be written to the file and is equivalent to the C<buf_ref> option of
  C<read_file>. These following pairs are equivalent but the pass by
  reference call will be faster in most cases (especially with larger
  files).
  
    write_file( 'filename', \$buffer ) ;
    write_file( 'filename', $buffer ) ;
  
    write_file( 'filename', \@lines ) ;
    write_file( 'filename', @lines ) ;
  
  If the first argument is a handle (if it is a ref and is an IO or GLOB
  object), then that handle is written to. This mode is supported so you
  spew to handles such as \*STDOUT. See the test handle.t for an example
  that does C<open( '-|' )> and child process spews data to the parent
  which slurps it in.  All of the options that control how the data are
  passed into C<write_file> still work in this case.
  
  If the first argument is an overloaded object then its stringified value
  is used for the filename and that file is opened.  This is new feature
  in 9999.14. See the stringify.t test for an example.
  
  By default C<write_file> returns 1 upon successfully writing the file or
  undef if it encountered an error. You can change how errors are handled
  with the C<err_mode> option.
  
  The options are:
  
  =head3 binmode
  
  If you set the binmode option, then its value is passed to a call to
  binmode on the opened handle. You can use this to set the file to be
  read in binary mode, utf8, etc. See perldoc -f binmode for more.
  
  	write_file( $bin_file, {binmode => ':raw'}, @data ) ;
  	write_file( $bin_file, {binmode => ':utf8'}, $utf_text ) ;
  
  =head3 perms
  
  The perms option sets the permissions of newly-created files. This value
  is modified by your process's umask and defaults to 0666 (same as
  sysopen).
  
  NOTE: this option is new as of File::Slurp version 9999.14;
  
  =head3 buf_ref
  
  You can use this option to pass in a scalar reference which has the
  data to be written. If this is set then any data arguments (including
  the scalar reference shortcut) in @_ will be ignored. These are
  equivalent:
  
  	write_file( $bin_file, { buf_ref => \$buffer } ) ;
  	write_file( $bin_file, \$buffer ) ;
  	write_file( $bin_file, $buffer ) ;
  
  =head3 atomic
  
  If you set this boolean option, the file will be written to in an
  atomic fashion. A temporary file name is created by appending the pid
  ($$) to the file name argument and that file is spewed to. After the
  file is closed it is renamed to the original file name (and rename is
  an atomic operation on most OS's). If the program using this were to
  crash in the middle of this, then the file with the pid suffix could
  be left behind.
  
  =head3 append
  
  If you set this boolean option, the data will be written at the end of
  the current file. Internally this sets the sysopen mode flag O_APPEND.
  
  	write_file( $file, {append => 1}, @data ) ;
  
   You
  can import append_file and it does the same thing.
  
  =head3 no_clobber
  
  If you set this boolean option, an existing file will not be overwritten.
  
  	write_file( $file, {no_clobber => 1}, @data ) ;
  
  =head3 err_mode
  
  You can use this option to control how C<write_file> behaves when an
  error occurs. This option defaults to 'croak'. You can set it to
  'carp' or to 'quiet' to have no error handling other than the return
  value. If the first call to C<write_file> fails it will carp and then
  write to another file. If the second call to C<write_file> fails, it
  will croak.
  
  	unless ( write_file( $file, { err_mode => 'carp', \$data ) ;
  
  		# write a different file but croak if not found
  		write_file( $other_file, \$data ) ;
  	}
  
  =head2 overwrite_file
  
  This sub is just a typeglob alias to write_file since write_file
  always overwrites an existing file. This sub is supported for
  backwards compatibility with the original version of this module. See
  write_file for its API and behavior.
  
  =head2 append_file
  
  This sub will write its data to the end of the file. It is a wrapper
  around write_file and it has the same API so see that for the full
  documentation. These calls are equivalent:
  
  	append_file( $file, @data ) ;
  	write_file( $file, {append => 1}, @data ) ;
  
  
  =head2 prepend_file
  
  This sub writes data to the beginning of a file. The previously existing
  data is written after that so the effect is prepending data in front of
  a file. It is a counterpart to the append_file sub in this module. It
  works by first using C<read_file> to slurp in the file and then calling
  C<write_file> with the new data and the existing file data.
  
  The first argument to C<prepend_file> is the filename. The next argument
  is an optional hash reference and it contains key/values that can modify
  the behavior of C<prepend_file>. The rest of the argument list is the
  data to be written to the file and that is passed to C<write_file> as is
  (see that for allowed data).
  
  Only the C<binmode> and C<err_mode> options are supported. The
  C<write_file> call has the C<atomic> option set so you will always have
  a consistant file. See above for more about those options.
  
  C<prepend_file> is not exported by default, you need to import it
  explicitly.
  
  	use File::Slurp qw( prepend_file ) ;
  	prepend_file( $file, $header ) ;
  	prepend_file( $file, \@lines ) ;
  	prepend_file( $file, { binmode => 'raw:'}, $bin_data ) ;
  
  
  =head2 edit_file, edit_file_lines
  
  These subs read in a file into $_, execute a code block which should
  modify $_ and then write $_ back to the file. The difference between
  them is that C<edit_file> reads the whole file into $_ and calls the
  code block one time. With C<edit_file_lines> each line is read into $_
  and the code is called for each line. In both cases the code should
  modify $_ if desired and it will be written back out. These subs are
  the equivalent of the -pi command line options of Perl but you can
  call them from inside your program and not fork out a process. They
  are in @EXPORT_OK so you need to request them to be imported on the
  use line or you can import both of them with:
  
  	use File::Slurp qw( :edit ) ;
  
  The first argument to C<edit_file> and C<edit_file_lines> is a code
  block or a code reference. The code block is not followed by a comma
  (as with grep and map) but a code reference is followed by a
  comma. See the examples below for both styles. The next argument is
  the filename. The last argument is an optional hash reference and it
  contains key/values that can modify the behavior of
  C<prepend_file>. 
  
  Only the C<binmode> and C<err_mode> options are supported. The
  C<write_file> call has the C<atomic> option set so you will always
  have a consistant file. See above for more about those options.
  
  Each group of calls below show a Perl command line instance and the
  equivalent calls to C<edit_file> and C<edit_file_lines>.
  
  	perl -0777 -pi -e 's/foo/bar/g' filename
  	use File::Slurp qw( edit_file ) ;
  	edit_file { s/foo/bar/g } 'filename' ;
  	edit_file sub { s/foo/bar/g }, 'filename' ;
  	edit_file \&replace_foo, 'filename' ;
  	sub replace_foo { s/foo/bar/g }
  
  	perl -pi -e '$_ = "" if /foo/' filename
  	use File::Slurp qw( edit_file_lines ) ;
  	use File::Slurp ;
  	edit_file_lines { $_ = '' if /foo/ } 'filename' ;
  	edit_file_lines sub { $_ = '' if /foo/ }, 'filename' ;
  	edit_file \&delete_foo, 'filename' ;
  	sub delete_foo { $_ = '' if /foo/ }
  
  =head2 read_dir
  
  This sub reads all the file names from directory and returns them to
  the caller but C<.> and C<..> are removed by default.
  
  	my @files = read_dir( '/path/to/dir' ) ;
  
  The first argument is the path to the directory to read.  If the next
  argument is a hash reference, then it is used as the options.
  Otherwise the rest of the argument list are is used as key/value
  options.
  
  In list context C<read_dir> returns a list of the entries in the
  directory. In a scalar context it returns an array reference which has
  the entries.
  
  =head3 err_mode
  
  If the C<err_mode> option is set, it selects how errors are handled (see
  C<err_mode> in C<read_file> or C<write_file>).
  
  =head3 keep_dot_dot
  
  If this boolean option is set, C<.> and C<..> are not removed from the
  list of files.
  
  	my @all_files = read_dir( '/path/to/dir', keep_dot_dot => 1 ) ;
  
  =head3 prefix
  
  If this boolean option is set, the string "$dir/" is prefixed to each
  dir entry. This means you can directly use the results to open
  files. A common newbie mistake is not putting the directory in front
  of entries when opening themn.
  
  	my @paths = read_dir( '/path/to/dir', prefix => 1 ) ;
  
  =head2 EXPORT
  
    These are exported by default or with
  	use File::Slurp qw( :std ) ;
  
    read_file write_file overwrite_file append_file read_dir
  
    These are exported with
  	use File::Slurp qw( :edit ) ;
  
    edit_file edit_file_lines
  
    You can get all subs in the module exported with 
  	use File::Slurp qw( :all ) ;
  
  =head2 LICENSE
  
    Same as Perl.
  
  =head2 SEE ALSO
  
  An article on file slurping in extras/slurp_article.pod. There is
  also a benchmarking script in extras/slurp_bench.pl.
  
  =head2 BUGS
  
  If run under Perl 5.004, slurping from the DATA handle will fail as
  that requires B.pm which didn't get into core until 5.005.
  
  =head1 AUTHOR
  
  Uri Guttman, E<lt>uri AT stemsystems DOT comE<gt>
  
  =cut
FILE_SLURP

$fatpacked{"HTTP/Config.pm"} = <<'HTTP_CONFIG';
  package HTTP::Config;
  
  use strict;
  use URI;
  use vars qw($VERSION);
  
  $VERSION = "6.00";
  
  sub new {
      my $class = shift;
      return bless [], $class;
  }
  
  sub entries {
      my $self = shift;
      @$self;
  }
  
  sub empty {
      my $self = shift;
      not @$self;
  }
  
  sub add {
      if (@_ == 2) {
          my $self = shift;
          push(@$self, shift);
          return;
      }
      my($self, %spec) = @_;
      push(@$self, \%spec);
      return;
  }
  
  sub find2 {
      my($self, %spec) = @_;
      my @found;
      my @rest;
   ITEM:
      for my $item (@$self) {
          for my $k (keys %spec) {
              if (!exists $item->{$k} || $spec{$k} ne $item->{$k}) {
                  push(@rest, $item);
                  next ITEM;
              }
          }
          push(@found, $item);
      }
      return \@found unless wantarray;
      return \@found, \@rest;
  }
  
  sub find {
      my $self = shift;
      my $f = $self->find2(@_);
      return @$f if wantarray;
      return $f->[0];
  }
  
  sub remove {
      my($self, %spec) = @_;
      my($removed, $rest) = $self->find2(%spec);
      @$self = @$rest if @$removed;
      return @$removed;
  }
  
  my %MATCH = (
      m_scheme => sub {
          my($v, $uri) = @_;
          return $uri->_scheme eq $v;  # URI known to be canonical
      },
      m_secure => sub {
          my($v, $uri) = @_;
          my $secure = $uri->can("secure") ? $uri->secure : $uri->_scheme eq "https";
          return $secure == !!$v;
      },
      m_host_port => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host_port");
          return $uri->host_port eq $v, 7;
      },
      m_host => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host");
          return $uri->host eq $v, 6;
      },
      m_port => sub {
          my($v, $uri) = @_;
          return unless $uri->can("port");
          return $uri->port eq $v;
      },
      m_domain => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host");
          my $h = $uri->host;
          $h = "$h.local" unless $h =~ /\./;
          $v = ".$v" unless $v =~ /^\./;
          return length($v), 5 if substr($h, -length($v)) eq $v;
          return 0;
      },
      m_path => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          return $uri->path eq $v, 4;
      },
      m_path_prefix => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          my $path = $uri->path;
          my $len = length($v);
          return $len, 3 if $path eq $v;
          return 0 if length($path) <= $len;
          $v .= "/" unless $v =~ m,/\z,,;
          return $len, 3 if substr($path, 0, length($v)) eq $v;
          return 0;
      },
      m_path_match => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          return $uri->path =~ $v;
      },
      m_uri__ => sub {
          my($v, $k, $uri) = @_;
          return unless $uri->can($k);
          return 1 unless defined $v;
          return $uri->$k eq $v;
      },
      m_method => sub {
          my($v, $uri, $request) = @_;
          return $request && $request->method eq $v;
      },
      m_proxy => sub {
          my($v, $uri, $request) = @_;
          return $request && ($request->{proxy} || "") eq $v;
      },
      m_code => sub {
          my($v, $uri, $request, $response) = @_;
          $v =~ s/xx\z//;
          return unless $response;
          return length($v), 2 if substr($response->code, 0, length($v)) eq $v;
      },
      m_media_type => sub {  # for request too??
          my($v, $uri, $request, $response) = @_;
          return unless $response;
          return 1, 1 if $v eq "*/*";
          my $ct = $response->content_type;
          return 2, 1 if $v =~ s,/\*\z,, && $ct =~ m,^\Q$v\E/,;
          return 3, 1 if $v eq "html" && $response->content_is_html;
          return 4, 1 if $v eq "xhtml" && $response->content_is_xhtml;
          return 10, 1 if $v eq $ct;
          return 0;
      },
      m_header__ => sub {
          my($v, $k, $uri, $request, $response) = @_;
          return unless $request;
          return 1 if $request->header($k) eq $v;
          return 1 if $response && $response->header($k) eq $v;
          return 0;
      },
      m_response_attr__ => sub {
          my($v, $k, $uri, $request, $response) = @_;
          return unless $response;
          return 1 if !defined($v) && exists $response->{$k};
          return 0 unless exists $response->{$k};
          return 1 if $response->{$k} eq $v;
          return 0;
      },
  );
  
  sub matching {
      my $self = shift;
      if (@_ == 1) {
          if ($_[0]->can("request")) {
              unshift(@_, $_[0]->request);
              unshift(@_, undef) unless defined $_[0];
          }
          unshift(@_, $_[0]->uri_canonical) if $_[0] && $_[0]->can("uri_canonical");
      }
      my($uri, $request, $response) = @_;
      $uri = URI->new($uri) unless ref($uri);
  
      my @m;
   ITEM:
      for my $item (@$self) {
          my $order;
          for my $ikey (keys %$item) {
              my $mkey = $ikey;
              my $k;
              $k = $1 if $mkey =~ s/__(.*)/__/;
              if (my $m = $MATCH{$mkey}) {
                  #print "$ikey $mkey\n";
                  my($c, $o);
                  my @arg = (
                      defined($k) ? $k : (),
                      $uri, $request, $response
                  );
                  my $v = $item->{$ikey};
                  $v = [$v] unless ref($v) eq "ARRAY";
                  for (@$v) {
                      ($c, $o) = $m->($_, @arg);
                      #print "  - $_ ==> $c $o\n";
                      last if $c;
                  }
                  next ITEM unless $c;
                  $order->[$o || 0] += $c;
              }
          }
          $order->[7] ||= 0;
          $item->{_order} = join(".", reverse map sprintf("%03d", $_ || 0), @$order);
          push(@m, $item);
      }
      @m = sort { $b->{_order} cmp $a->{_order} } @m;
      delete $_->{_order} for @m;
      return @m if wantarray;
      return $m[0];
  }
  
  sub add_item {
      my $self = shift;
      my $item = shift;
      return $self->add(item => $item, @_);
  }
  
  sub remove_items {
      my $self = shift;
      return map $_->{item}, $self->remove(@_);
  }
  
  sub matching_items {
      my $self = shift;
      return map $_->{item}, $self->matching(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Config - Configuration for request and response objects
  
  =head1 SYNOPSIS
  
   use HTTP::Config;
   my $c = HTTP::Config->new;
   $c->add(m_domain => ".example.com", m_scheme => "http", verbose => 1);
   
   use HTTP::Request;
   my $request = HTTP::Request->new(GET => "http://www.example.com");
   
   if (my @m = $c->matching($request)) {
      print "Yadayada\n" if $m[0]->{verbose};
   }
  
  =head1 DESCRIPTION
  
  An C<HTTP::Config> object is a list of entries that
  can be matched against request or request/response pairs.  Its
  purpose is to hold configuration data that can be looked up given a
  request or response object.
  
  Each configuration entry is a hash.  Some keys specify matching to
  occur against attributes of request/response objects.  Other keys can
  be used to hold user data.
  
  The following methods are provided:
  
  =over 4
  
  =item $conf = HTTP::Config->new
  
  Constructs a new empty C<HTTP::Config> object and returns it.
  
  =item $conf->entries
  
  Returns the list of entries in the configuration object.
  In scalar context returns the number of entries.
  
  =item $conf->empty
  
  Return true if there are no entries in the configuration object.
  This is just a shorthand for C<< not $conf->entries >>.
  
  =item $conf->add( %matchspec, %other )
  
  =item $conf->add( \%entry )
  
  Adds a new entry to the configuration.
  You can either pass separate key/value pairs or a hash reference.
  
  =item $conf->remove( %spec )
  
  Removes (and returns) the entries that have matches for all the key/value pairs in %spec.
  If %spec is empty this will match all entries; so it will empty the configuation object.
  
  =item $conf->matching( $uri, $request, $response )
  
  =item $conf->matching( $uri )
  
  =item $conf->matching( $request )
  
  =item $conf->matching( $response )
  
  Returns the entries that match the given $uri, $request and $response triplet.
  
  If called with a single $request object then the $uri is obtained by calling its 'uri_canonical' method.
  If called with a single $response object, then the request object is obtained by calling its 'request' method;
  and then the $uri is obtained as if a single $request was provided.
  
  The entries are returned with the most specific matches first.
  In scalar context returns the most specific match or C<undef> in none match.
  
  =item $conf->add_item( $item, %matchspec )
  
  =item $conf->remove_items( %spec )
  
  =item $conf->matching_items( $uri, $request, $response )
  
  Wrappers that hides the entries themselves.
  
  =back
  
  =head2 Matching
  
  The following keys on a configuration entry specify matching.  For all
  of these you can provide an array of values instead of a single value.
  The entry matches if at least one of the values in the array matches.
  
  Entries that require match against a response object attribute will never match
  unless a response object was provided.
  
  =over
  
  =item m_scheme => $scheme
  
  Matches if the URI uses the specified scheme; e.g. "http".
  
  =item m_secure => $bool
  
  If $bool is TRUE; matches if the URI uses a secure scheme.  If $bool
  is FALSE; matches if the URI does not use a secure scheme.  An example
  of a secure scheme is "https".
  
  =item m_host_port => "$hostname:$port"
  
  Matches if the URI's host_port method return the specified value.
  
  =item m_host => $hostname
  
  Matches if the URI's host method returns the specified value.
  
  =item m_port => $port
  
  Matches if the URI's port method returns the specified value.
  
  =item m_domain => ".$domain"
  
  Matches if the URI's host method return a value that within the given
  domain.  The hostname "www.example.com" will for instance match the
  domain ".com".
  
  =item m_path => $path
  
  Matches if the URI's path method returns the specified value.
  
  =item m_path_prefix => $path
  
  Matches if the URI's path is the specified path or has the specified
  path as prefix.
  
  =item m_path_match => $Regexp
  
  Matches if the regular expression matches the URI's path.  Eg. qr/\.html$/.
  
  =item m_method => $method
  
  Matches if the request method matches the specified value. Eg. "GET" or "POST".
  
  =item m_code => $digit
  
  =item m_code => $status_code
  
  Matches if the response status code matches.  If a single digit is
  specified; matches for all response status codes beginning with that digit.
  
  =item m_proxy => $url
  
  Matches if the request is to be sent to the given Proxy server.
  
  =item m_media_type => "*/*"
  
  =item m_media_type => "text/*"
  
  =item m_media_type => "html"
  
  =item m_media_type => "xhtml"
  
  =item m_media_type => "text/html"
  
  Matches if the response media type matches.
  
  With a value of "html" matches if $response->content_is_html returns TRUE.
  With a value of "xhtml" matches if $response->content_is_xhtml returns TRUE.
  
  =item m_uri__I<$method> => undef
  
  Matches if the URI object provides the method.
  
  =item m_uri__I<$method> => $string
  
  Matches if the URI's $method method returns the given value.
  
  =item m_header__I<$field> => $string
  
  Matches if either the request or the response have a header $field with the given value.
  
  =item m_response_attr__I<$key> => undef
  
  =item m_response_attr__I<$key> => $string
  
  Matches if the response object has that key, or the entry has the given value.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<HTTP::Request>, L<HTTP::Response>
  
  =head1 COPYRIGHT
  
  Copyright 2008, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
HTTP_CONFIG

$fatpacked{"HTTP/Date.pm"} = <<'HTTP_DATE';
  package HTTP::Date;
  
  $VERSION = "6.02";
  
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(time2str str2time);
  @EXPORT_OK = qw(parse_date time2iso time2isoz);
  
  use strict;
  require Time::Local;
  
  use vars qw(@DoW @MoY %MoY);
  @DoW = qw(Sun Mon Tue Wed Thu Fri Sat);
  @MoY = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
  @MoY{@MoY} = (1..12);
  
  my %GMT_ZONE = (GMT => 1, UTC => 1, UT => 1, Z => 1);
  
  
  sub time2str (;$)
  {
      my $time = shift;
      $time = time unless defined $time;
      my ($sec, $min, $hour, $mday, $mon, $year, $wday) = gmtime($time);
      sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",
  	    $DoW[$wday],
  	    $mday, $MoY[$mon], $year+1900,
  	    $hour, $min, $sec);
  }
  
  
  sub str2time ($;$)
  {
      my $str = shift;
      return undef unless defined $str;
  
      # fast exit for strictly conforming string
      if ($str =~ /^[SMTWF][a-z][a-z], (\d\d) ([JFMAJSOND][a-z][a-z]) (\d\d\d\d) (\d\d):(\d\d):(\d\d) GMT$/) {
  	return eval {
  	    my $t = Time::Local::timegm($6, $5, $4, $1, $MoY{$2}-1, $3);
  	    $t < 0 ? undef : $t;
  	};
      }
  
      my @d = parse_date($str);
      return undef unless @d;
      $d[1]--;        # month
  
      my $tz = pop(@d);
      unless (defined $tz) {
  	unless (defined($tz = shift)) {
  	    return eval { my $frac = $d[-1]; $frac -= ($d[-1] = int($frac));
  			  my $t = Time::Local::timelocal(reverse @d) + $frac;
  			  $t < 0 ? undef : $t;
  		        };
  	}
      }
  
      my $offset = 0;
      if ($GMT_ZONE{uc $tz}) {
  	# offset already zero
      }
      elsif ($tz =~ /^([-+])?(\d\d?):?(\d\d)?$/) {
  	$offset = 3600 * $2;
  	$offset += 60 * $3 if $3;
  	$offset *= -1 if $1 && $1 eq '-';
      }
      else {
  	eval { require Time::Zone } || return undef;
  	$offset = Time::Zone::tz_offset($tz);
  	return undef unless defined $offset;
      }
  
      return eval { my $frac = $d[-1]; $frac -= ($d[-1] = int($frac));
  		  my $t = Time::Local::timegm(reverse @d) + $frac;
  		  $t < 0 ? undef : $t - $offset;
  		};
  }
  
  
  sub parse_date ($)
  {
      local($_) = shift;
      return unless defined;
  
      # More lax parsing below
      s/^\s+//;  # kill leading space
      s/^(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)[a-z]*,?\s*//i; # Useless weekday
  
      my($day, $mon, $yr, $hr, $min, $sec, $tz, $ampm);
  
      # Then we are able to check for most of the formats with this regexp
      (($day,$mon,$yr,$hr,$min,$sec,$tz) =
          /^
  	 (\d\d?)               # day
  	    (?:\s+|[-\/])
  	 (\w+)                 # month
  	    (?:\s+|[-\/])
  	 (\d+)                 # year
  	 (?:
  	       (?:\s+|:)       # separator before clock
  	    (\d\d?):(\d\d)     # hour:min
  	    (?::(\d\d))?       # optional seconds
  	 )?                    # optional clock
  	    \s*
  	 ([-+]?\d{2,4}|(?![APap][Mm]\b)[A-Za-z]+)? # timezone
  	    \s*
  	 (?:\(\w+\)|\w{3,})?   # ASCII representation of timezone.
  	    \s*$
  	/x)
  
      ||
  
      # Try the ctime and asctime format
      (($mon, $day, $hr, $min, $sec, $tz, $yr) =
  	/^
  	 (\w{1,3})             # month
  	    \s+
  	 (\d\d?)               # day
  	    \s+
  	 (\d\d?):(\d\d)        # hour:min
  	 (?::(\d\d))?          # optional seconds
  	    \s+
  	 (?:([A-Za-z]+)\s+)?   # optional timezone
  	 (\d+)                 # year
  	    \s*$               # allow trailing whitespace
  	/x)
  
      ||
  
      # Then the Unix 'ls -l' date format
      (($mon, $day, $yr, $hr, $min, $sec) =
  	/^
  	 (\w{3})               # month
  	    \s+
  	 (\d\d?)               # day
  	    \s+
  	 (?:
  	    (\d\d\d\d) |       # year
  	    (\d{1,2}):(\d{2})  # hour:min
              (?::(\d\d))?       # optional seconds
  	 )
  	 \s*$
         /x)
  
      ||
  
      # ISO 8601 format '1996-02-29 12:00:00 -0100' and variants
      (($yr, $mon, $day, $hr, $min, $sec, $tz) =
  	/^
  	  (\d{4})              # year
  	     [-\/]?
  	  (\d\d?)              # numerical month
  	     [-\/]?
  	  (\d\d?)              # day
  	 (?:
  	       (?:\s+|[-:Tt])  # separator before clock
  	    (\d\d?):?(\d\d)    # hour:min
  	    (?::?(\d\d(?:\.\d*)?))?  # optional seconds (and fractional)
  	 )?                    # optional clock
  	    \s*
  	 ([-+]?\d\d?:?(:?\d\d)?
  	  |Z|z)?               # timezone  (Z is "zero meridian", i.e. GMT)
  	    \s*$
  	/x)
  
      ||
  
      # Windows 'dir' 11-12-96  03:52PM
      (($mon, $day, $yr, $hr, $min, $ampm) =
          /^
            (\d{2})                # numerical month
               -
            (\d{2})                # day
               -
            (\d{2})                # year
               \s+
            (\d\d?):(\d\d)([APap][Mm])  # hour:min AM or PM
               \s*$
          /x)
  
      ||
      return;  # unrecognized format
  
      # Translate month name to number
      $mon = $MoY{$mon} ||
             $MoY{"\u\L$mon"} ||
  	   ($mon =~ /^\d\d?$/ && $mon >= 1 && $mon <= 12 && int($mon)) ||
             return;
  
      # If the year is missing, we assume first date before the current,
      # because of the formats we support such dates are mostly present
      # on "ls -l" listings.
      unless (defined $yr) {
  	my $cur_mon;
  	($cur_mon, $yr) = (localtime)[4, 5];
  	$yr += 1900;
  	$cur_mon++;
  	$yr-- if $mon > $cur_mon;
      }
      elsif (length($yr) < 3) {
  	# Find "obvious" year
  	my $cur_yr = (localtime)[5] + 1900;
  	my $m = $cur_yr % 100;
  	my $tmp = $yr;
  	$yr += $cur_yr - $m;
  	$m -= $tmp;
  	$yr += ($m > 0) ? 100 : -100
  	    if abs($m) > 50;
      }
  
      # Make sure clock elements are defined
      $hr  = 0 unless defined($hr);
      $min = 0 unless defined($min);
      $sec = 0 unless defined($sec);
  
      # Compensate for AM/PM
      if ($ampm) {
  	$ampm = uc $ampm;
  	$hr = 0 if $hr == 12 && $ampm eq 'AM';
  	$hr += 12 if $ampm eq 'PM' && $hr != 12;
      }
  
      return($yr, $mon, $day, $hr, $min, $sec, $tz)
  	if wantarray;
  
      if (defined $tz) {
  	$tz = "Z" if $tz =~ /^(GMT|UTC?|[-+]?0+)$/;
      }
      else {
  	$tz = "";
      }
      return sprintf("%04d-%02d-%02d %02d:%02d:%02d%s",
  		   $yr, $mon, $day, $hr, $min, $sec, $tz);
  }
  
  
  sub time2iso (;$)
  {
      my $time = shift;
      $time = time unless defined $time;
      my($sec,$min,$hour,$mday,$mon,$year) = localtime($time);
      sprintf("%04d-%02d-%02d %02d:%02d:%02d",
  	    $year+1900, $mon+1, $mday, $hour, $min, $sec);
  }
  
  
  sub time2isoz (;$)
  {
      my $time = shift;
      $time = time unless defined $time;
      my($sec,$min,$hour,$mday,$mon,$year) = gmtime($time);
      sprintf("%04d-%02d-%02d %02d:%02d:%02dZ",
              $year+1900, $mon+1, $mday, $hour, $min, $sec);
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Date - date conversion routines
  
  =head1 SYNOPSIS
  
   use HTTP::Date;
  
   $string = time2str($time);    # Format as GMT ASCII time
   $time = str2time($string);    # convert ASCII date to machine time
  
  =head1 DESCRIPTION
  
  This module provides functions that deal the date formats used by the
  HTTP protocol (and then some more).  Only the first two functions,
  time2str() and str2time(), are exported by default.
  
  =over 4
  
  =item time2str( [$time] )
  
  The time2str() function converts a machine time (seconds since epoch)
  to a string.  If the function is called without an argument or with an
  undefined argument, it will use the current time.
  
  The string returned is in the format preferred for the HTTP protocol.
  This is a fixed length subset of the format defined by RFC 1123,
  represented in Universal Time (GMT).  An example of a time stamp
  in this format is:
  
     Sun, 06 Nov 1994 08:49:37 GMT
  
  =item str2time( $str [, $zone] )
  
  The str2time() function converts a string to machine time.  It returns
  C<undef> if the format of $str is unrecognized, otherwise whatever the
  C<Time::Local> functions can make out of the parsed time.  Dates
  before the system's epoch may not work on all operating systems.  The
  time formats recognized are the same as for parse_date().
  
  The function also takes an optional second argument that specifies the
  default time zone to use when converting the date.  This parameter is
  ignored if the zone is found in the date string itself.  If this
  parameter is missing, and the date string format does not contain any
  zone specification, then the local time zone is assumed.
  
  If the zone is not "C<GMT>" or numerical (like "C<-0800>" or
  "C<+0100>"), then the C<Time::Zone> module must be installed in order
  to get the date recognized.
  
  =item parse_date( $str )
  
  This function will try to parse a date string, and then return it as a
  list of numerical values followed by a (possible undefined) time zone
  specifier; ($year, $month, $day, $hour, $min, $sec, $tz).  The $year
  will be the full 4-digit year, and $month numbers start with 1 (for January).
  
  In scalar context the numbers are interpolated in a string of the
  "YYYY-MM-DD hh:mm:ss TZ"-format and returned.
  
  If the date is unrecognized, then the empty list is returned (C<undef> in
  scalar context).
  
  The function is able to parse the following formats:
  
   "Wed, 09 Feb 1994 22:23:32 GMT"       -- HTTP format
   "Thu Feb  3 17:03:55 GMT 1994"        -- ctime(3) format
   "Thu Feb  3 00:00:00 1994",           -- ANSI C asctime() format
   "Tuesday, 08-Feb-94 14:15:29 GMT"     -- old rfc850 HTTP format
   "Tuesday, 08-Feb-1994 14:15:29 GMT"   -- broken rfc850 HTTP format
  
   "03/Feb/1994:17:03:55 -0700"   -- common logfile format
   "09 Feb 1994 22:23:32 GMT"     -- HTTP format (no weekday)
   "08-Feb-94 14:15:29 GMT"       -- rfc850 format (no weekday)
   "08-Feb-1994 14:15:29 GMT"     -- broken rfc850 format (no weekday)
  
   "1994-02-03 14:15:29 -0100"    -- ISO 8601 format
   "1994-02-03 14:15:29"          -- zone is optional
   "1994-02-03"                   -- only date
   "1994-02-03T14:15:29"          -- Use T as separator
   "19940203T141529Z"             -- ISO 8601 compact format
   "19940203"                     -- only date
  
   "08-Feb-94"         -- old rfc850 HTTP format    (no weekday, no time)
   "08-Feb-1994"       -- broken rfc850 HTTP format (no weekday, no time)
   "09 Feb 1994"       -- proposed new HTTP format  (no weekday, no time)
   "03/Feb/1994"       -- common logfile format     (no time, no offset)
  
   "Feb  3  1994"      -- Unix 'ls -l' format
   "Feb  3 17:03"      -- Unix 'ls -l' format
  
   "11-15-96  03:52PM" -- Windows 'dir' format
  
  The parser ignores leading and trailing whitespace.  It also allow the
  seconds to be missing and the month to be numerical in most formats.
  
  If the year is missing, then we assume that the date is the first
  matching date I<before> current month.  If the year is given with only
  2 digits, then parse_date() will select the century that makes the
  year closest to the current date.
  
  =item time2iso( [$time] )
  
  Same as time2str(), but returns a "YYYY-MM-DD hh:mm:ss"-formatted
  string representing time in the local time zone.
  
  =item time2isoz( [$time] )
  
  Same as time2str(), but returns a "YYYY-MM-DD hh:mm:ssZ"-formatted
  string representing Universal Time.
  
  
  =back
  
  =head1 SEE ALSO
  
  L<perlfunc/time>, L<Time::Zone>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1999, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
HTTP_DATE

$fatpacked{"HTTP/Headers.pm"} = <<'HTTP_HEADERS';
  package HTTP::Headers;
  
  use strict;
  use Carp ();
  
  use vars qw($VERSION $TRANSLATE_UNDERSCORE);
  $VERSION = "6.05";
  
  # The $TRANSLATE_UNDERSCORE variable controls whether '_' can be used
  # as a replacement for '-' in header field names.
  $TRANSLATE_UNDERSCORE = 1 unless defined $TRANSLATE_UNDERSCORE;
  
  # "Good Practice" order of HTTP message headers:
  #    - General-Headers
  #    - Request-Headers
  #    - Response-Headers
  #    - Entity-Headers
  
  my @general_headers = qw(
      Cache-Control Connection Date Pragma Trailer Transfer-Encoding Upgrade
      Via Warning
  );
  
  my @request_headers = qw(
      Accept Accept-Charset Accept-Encoding Accept-Language
      Authorization Expect From Host
      If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since
      Max-Forwards Proxy-Authorization Range Referer TE User-Agent
  );
  
  my @response_headers = qw(
      Accept-Ranges Age ETag Location Proxy-Authenticate Retry-After Server
      Vary WWW-Authenticate
  );
  
  my @entity_headers = qw(
      Allow Content-Encoding Content-Language Content-Length Content-Location
      Content-MD5 Content-Range Content-Type Expires Last-Modified
  );
  
  my %entity_header = map { lc($_) => 1 } @entity_headers;
  
  my @header_order = (
      @general_headers,
      @request_headers,
      @response_headers,
      @entity_headers,
  );
  
  # Make alternative representations of @header_order.  This is used
  # for sorting and case matching.
  my %header_order;
  my %standard_case;
  
  {
      my $i = 0;
      for (@header_order) {
  	my $lc = lc $_;
  	$header_order{$lc} = ++$i;
  	$standard_case{$lc} = $_;
      }
  }
  
  
  
  sub new
  {
      my($class) = shift;
      my $self = bless {}, $class;
      $self->header(@_) if @_; # set up initial headers
      $self;
  }
  
  
  sub header
  {
      my $self = shift;
      Carp::croak('Usage: $h->header($field, ...)') unless @_;
      my(@old);
      my %seen;
      while (@_) {
  	my $field = shift;
          my $op = @_ ? ($seen{lc($field)}++ ? 'PUSH' : 'SET') : 'GET';
  	@old = $self->_header($field, shift, $op);
      }
      return @old if wantarray;
      return $old[0] if @old <= 1;
      join(", ", @old);
  }
  
  sub clear
  {
      my $self = shift;
      %$self = ();
  }
  
  
  sub push_header
  {
      my $self = shift;
      return $self->_header(@_, 'PUSH_H') if @_ == 2;
      while (@_) {
  	$self->_header(splice(@_, 0, 2), 'PUSH_H');
      }
  }
  
  
  sub init_header
  {
      Carp::croak('Usage: $h->init_header($field, $val)') if @_ != 3;
      shift->_header(@_, 'INIT');
  }
  
  
  sub remove_header
  {
      my($self, @fields) = @_;
      my $field;
      my @values;
      foreach $field (@fields) {
  	$field =~ tr/_/-/ if $field !~ /^:/ && $TRANSLATE_UNDERSCORE;
  	my $v = delete $self->{lc $field};
  	push(@values, ref($v) eq 'ARRAY' ? @$v : $v) if defined $v;
      }
      return @values;
  }
  
  sub remove_content_headers
  {
      my $self = shift;
      unless (defined(wantarray)) {
  	# fast branch that does not create return object
  	delete @$self{grep $entity_header{$_} || /^content-/, keys %$self};
  	return;
      }
  
      my $c = ref($self)->new;
      for my $f (grep $entity_header{$_} || /^content-/, keys %$self) {
  	$c->{$f} = delete $self->{$f};
      }
      if (exists $self->{'::std_case'}) {
  	$c->{'::std_case'} = $self->{'::std_case'};
      }
      $c;
  }
  
  
  sub _header
  {
      my($self, $field, $val, $op) = @_;
  
      Carp::croak("Illegal field name '$field'")
          if rindex($field, ':') > 1 || !length($field);
  
      unless ($field =~ /^:/) {
  	$field =~ tr/_/-/ if $TRANSLATE_UNDERSCORE;
  	my $old = $field;
  	$field = lc $field;
  	unless($standard_case{$field} || $self->{'::std_case'}{$field}) {
  	    # generate a %std_case entry for this field
  	    $old =~ s/\b(\w)/\u$1/g;
  	    $self->{'::std_case'}{$field} = $old;
  	}
      }
  
      $op ||= defined($val) ? 'SET' : 'GET';
      if ($op eq 'PUSH_H') {
  	# Like PUSH but where we don't care about the return value
  	if (exists $self->{$field}) {
  	    my $h = $self->{$field};
  	    if (ref($h) eq 'ARRAY') {
  		push(@$h, ref($val) eq "ARRAY" ? @$val : $val);
  	    }
  	    else {
  		$self->{$field} = [$h, ref($val) eq "ARRAY" ? @$val : $val]
  	    }
  	    return;
  	}
  	$self->{$field} = $val;
  	return;
      }
  
      my $h = $self->{$field};
      my @old = ref($h) eq 'ARRAY' ? @$h : (defined($h) ? ($h) : ());
  
      unless ($op eq 'GET' || ($op eq 'INIT' && @old)) {
  	if (defined($val)) {
  	    my @new = ($op eq 'PUSH') ? @old : ();
  	    if (ref($val) ne 'ARRAY') {
  		push(@new, $val);
  	    }
  	    else {
  		push(@new, @$val);
  	    }
  	    $self->{$field} = @new > 1 ? \@new : $new[0];
  	}
  	elsif ($op ne 'PUSH') {
  	    delete $self->{$field};
  	}
      }
      @old;
  }
  
  
  sub _sorted_field_names
  {
      my $self = shift;
      return [ sort {
          ($header_order{$a} || 999) <=> ($header_order{$b} || 999) ||
           $a cmp $b
      } grep !/^::/, keys %$self ];
  }
  
  
  sub header_field_names {
      my $self = shift;
      return map $standard_case{$_} || $self->{'::std_case'}{$_} || $_, @{ $self->_sorted_field_names },
  	if wantarray;
      return grep !/^::/, keys %$self;
  }
  
  
  sub scan
  {
      my($self, $sub) = @_;
      my $key;
      for $key (@{ $self->_sorted_field_names }) {
  	my $vals = $self->{$key};
  	if (ref($vals) eq 'ARRAY') {
  	    my $val;
  	    for $val (@$vals) {
  		$sub->($standard_case{$key} || $self->{'::std_case'}{$key} || $key, $val);
  	    }
  	}
  	else {
  	    $sub->($standard_case{$key} || $self->{'::std_case'}{$key} || $key, $vals);
  	}
      }
  }
  
  
  sub as_string
  {
      my($self, $endl) = @_;
      $endl = "\n" unless defined $endl;
  
      my @result = ();
      for my $key (@{ $self->_sorted_field_names }) {
  	next if index($key, '_') == 0;
  	my $vals = $self->{$key};
  	if ( ref($vals) eq 'ARRAY' ) {
  	    for my $val (@$vals) {
  		my $field = $standard_case{$key} || $self->{'::std_case'}{$key} || $key;
  		$field =~ s/^://;
  		if ( index($val, "\n") >= 0 ) {
  		    $val = _process_newline($val, $endl);
  		}
  		push @result, $field . ': ' . $val;
  	    }
  	}
  	else {
  	    my $field = $standard_case{$key} || $self->{'::std_case'}{$key} || $key;
  	    $field =~ s/^://;
  	    if ( index($vals, "\n") >= 0 ) {
  		$vals = _process_newline($vals, $endl);
  	    }
  	    push @result, $field . ': ' . $vals;
  	}
      }
  
      join($endl, @result, '');
  }
  
  sub _process_newline {
      local $_ = shift;
      my $endl = shift;
      # must handle header values with embedded newlines with care
      s/\s+$//;        # trailing newlines and space must go
      s/\n(\x0d?\n)+/\n/g;     # no empty lines
      s/\n([^\040\t])/\n $1/g; # initial space for continuation
      s/\n/$endl/g;    # substitute with requested line ending
      $_;
  }
  
  
  
  if (eval { require Storable; 1 }) {
      *clone = \&Storable::dclone;
  } else {
      *clone = sub {
  	my $self = shift;
  	my $clone = HTTP::Headers->new;
  	$self->scan(sub { $clone->push_header(@_);} );
  	$clone;
      };
  }
  
  
  sub _date_header
  {
      require HTTP::Date;
      my($self, $header, $time) = @_;
      my($old) = $self->_header($header);
      if (defined $time) {
  	$self->_header($header, HTTP::Date::time2str($time));
      }
      $old =~ s/;.*// if defined($old);
      HTTP::Date::str2time($old);
  }
  
  
  sub date                { shift->_date_header('Date',                @_); }
  sub expires             { shift->_date_header('Expires',             @_); }
  sub if_modified_since   { shift->_date_header('If-Modified-Since',   @_); }
  sub if_unmodified_since { shift->_date_header('If-Unmodified-Since', @_); }
  sub last_modified       { shift->_date_header('Last-Modified',       @_); }
  
  # This is used as a private LWP extension.  The Client-Date header is
  # added as a timestamp to a response when it has been received.
  sub client_date         { shift->_date_header('Client-Date',         @_); }
  
  # The retry_after field is dual format (can also be a expressed as
  # number of seconds from now), so we don't provide an easy way to
  # access it until we have know how both these interfaces can be
  # addressed.  One possibility is to return a negative value for
  # relative seconds and a positive value for epoch based time values.
  #sub retry_after       { shift->_date_header('Retry-After',       @_); }
  
  sub content_type      {
      my $self = shift;
      my $ct = $self->{'content-type'};
      $self->{'content-type'} = shift if @_;
      $ct = $ct->[0] if ref($ct) eq 'ARRAY';
      return '' unless defined($ct) && length($ct);
      my @ct = split(/;\s*/, $ct, 2);
      for ($ct[0]) {
  	s/\s+//g;
  	$_ = lc($_);
      }
      wantarray ? @ct : $ct[0];
  }
  
  sub content_type_charset {
      my $self = shift;
      require HTTP::Headers::Util;
      my $h = $self->{'content-type'};
      $h = $h->[0] if ref($h);
      $h = "" unless defined $h;
      my @v = HTTP::Headers::Util::split_header_words($h);
      if (@v) {
  	my($ct, undef, %ct_param) = @{$v[0]};
  	my $charset = $ct_param{charset};
  	if ($ct) {
  	    $ct = lc($ct);
  	    $ct =~ s/\s+//;
  	}
  	if ($charset) {
  	    $charset = uc($charset);
  	    $charset =~ s/^\s+//;  $charset =~ s/\s+\z//;
  	    undef($charset) if $charset eq "";
  	}
  	return $ct, $charset if wantarray;
  	return $charset;
      }
      return undef, undef if wantarray;
      return undef;
  }
  
  sub content_is_text {
      my $self = shift;
      return $self->content_type =~ m,^text/,;
  }
  
  sub content_is_html {
      my $self = shift;
      return $self->content_type eq 'text/html' || $self->content_is_xhtml;
  }
  
  sub content_is_xhtml {
      my $ct = shift->content_type;
      return $ct eq "application/xhtml+xml" ||
             $ct eq "application/vnd.wap.xhtml+xml";
  }
  
  sub content_is_xml {
      my $ct = shift->content_type;
      return 1 if $ct eq "text/xml";
      return 1 if $ct eq "application/xml";
      return 1 if $ct =~ /\+xml$/;
      return 0;
  }
  
  sub referer           {
      my $self = shift;
      if (@_ && $_[0] =~ /#/) {
  	# Strip fragment per RFC 2616, section 14.36.
  	my $uri = shift;
  	if (ref($uri)) {
  	    $uri = $uri->clone;
  	    $uri->fragment(undef);
  	}
  	else {
  	    $uri =~ s/\#.*//;
  	}
  	unshift @_, $uri;
      }
      ($self->_header('Referer', @_))[0];
  }
  *referrer = \&referer;  # on tchrist's request
  
  sub title             { (shift->_header('Title',            @_))[0] }
  sub content_encoding  { (shift->_header('Content-Encoding', @_))[0] }
  sub content_language  { (shift->_header('Content-Language', @_))[0] }
  sub content_length    { (shift->_header('Content-Length',   @_))[0] }
  
  sub user_agent        { (shift->_header('User-Agent',       @_))[0] }
  sub server            { (shift->_header('Server',           @_))[0] }
  
  sub from              { (shift->_header('From',             @_))[0] }
  sub warning           { (shift->_header('Warning',          @_))[0] }
  
  sub www_authenticate  { (shift->_header('WWW-Authenticate', @_))[0] }
  sub authorization     { (shift->_header('Authorization',    @_))[0] }
  
  sub proxy_authenticate  { (shift->_header('Proxy-Authenticate',  @_))[0] }
  sub proxy_authorization { (shift->_header('Proxy-Authorization', @_))[0] }
  
  sub authorization_basic       { shift->_basic_auth("Authorization",       @_) }
  sub proxy_authorization_basic { shift->_basic_auth("Proxy-Authorization", @_) }
  
  sub _basic_auth {
      require MIME::Base64;
      my($self, $h, $user, $passwd) = @_;
      my($old) = $self->_header($h);
      if (defined $user) {
  	Carp::croak("Basic authorization user name can't contain ':'")
  	  if $user =~ /:/;
  	$passwd = '' unless defined $passwd;
  	$self->_header($h => 'Basic ' .
                               MIME::Base64::encode("$user:$passwd", ''));
      }
      if (defined $old && $old =~ s/^\s*Basic\s+//) {
  	my $val = MIME::Base64::decode($old);
  	return $val unless wantarray;
  	return split(/:/, $val, 2);
      }
      return;
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Headers - Class encapsulating HTTP Message headers
  
  =head1 SYNOPSIS
  
   require HTTP::Headers;
   $h = HTTP::Headers->new;
  
   $h->header('Content-Type' => 'text/plain');  # set
   $ct = $h->header('Content-Type');            # get
   $h->remove_header('Content-Type');           # delete
  
  =head1 DESCRIPTION
  
  The C<HTTP::Headers> class encapsulates HTTP-style message headers.
  The headers consist of attribute-value pairs also called fields, which
  may be repeated, and which are printed in a particular order.  The
  field names are cases insensitive.
  
  Instances of this class are usually created as member variables of the
  C<HTTP::Request> and C<HTTP::Response> classes, internal to the
  library.
  
  The following methods are available:
  
  =over 4
  
  =item $h = HTTP::Headers->new
  
  Constructs a new C<HTTP::Headers> object.  You might pass some initial
  attribute-value pairs as parameters to the constructor.  I<E.g.>:
  
   $h = HTTP::Headers->new(
         Date         => 'Thu, 03 Feb 1994 00:00:00 GMT',
         Content_Type => 'text/html; version=3.2',
         Content_Base => 'http://www.perl.org/');
  
  The constructor arguments are passed to the C<header> method which is
  described below.
  
  =item $h->clone
  
  Returns a copy of this C<HTTP::Headers> object.
  
  =item $h->header( $field )
  
  =item $h->header( $field => $value )
  
  =item $h->header( $f1 => $v1, $f2 => $v2, ... )
  
  Get or set the value of one or more header fields.  The header field
  name ($field) is not case sensitive.  To make the life easier for perl
  users who wants to avoid quoting before the => operator, you can use
  '_' as a replacement for '-' in header names.
  
  The header() method accepts multiple ($field => $value) pairs, which
  means that you can update several fields with a single invocation.
  
  The $value argument may be a plain string or a reference to an array
  of strings for a multi-valued field. If the $value is provided as
  C<undef> then the field is removed.  If the $value is not given, then
  that header field will remain unchanged.
  
  The old value (or values) of the last of the header fields is returned.
  If no such field exists C<undef> will be returned.
  
  A multi-valued field will be returned as separate values in list
  context and will be concatenated with ", " as separator in scalar
  context.  The HTTP spec (RFC 2616) promise that joining multiple
  values in this way will not change the semantic of a header field, but
  in practice there are cases like old-style Netscape cookies (see
  L<HTTP::Cookies>) where "," is used as part of the syntax of a single
  field value.
  
  Examples:
  
   $header->header(MIME_Version => '1.0',
  		 User_Agent   => 'My-Web-Client/0.01');
   $header->header(Accept => "text/html, text/plain, image/*");
   $header->header(Accept => [qw(text/html text/plain image/*)]);
   @accepts = $header->header('Accept');  # get multiple values
   $accepts = $header->header('Accept');  # get values as a single string
  
  =item $h->push_header( $field => $value )
  
  =item $h->push_header( $f1 => $v1, $f2 => $v2, ... )
  
  Add a new field value for the specified header field.  Previous values
  for the same field are retained.
  
  As for the header() method, the field name ($field) is not case
  sensitive and '_' can be used as a replacement for '-'.
  
  The $value argument may be a scalar or a reference to a list of
  scalars.
  
   $header->push_header(Accept => 'image/jpeg');
   $header->push_header(Accept => [map "image/$_", qw(gif png tiff)]);
  
  =item $h->init_header( $field => $value )
  
  Set the specified header to the given value, but only if no previous
  value for that field is set.
  
  The header field name ($field) is not case sensitive and '_'
  can be used as a replacement for '-'.
  
  The $value argument may be a scalar or a reference to a list of
  scalars.
  
  =item $h->remove_header( $field, ... )
  
  This function removes the header fields with the specified names.
  
  The header field names ($field) are not case sensitive and '_'
  can be used as a replacement for '-'.
  
  The return value is the values of the fields removed.  In scalar
  context the number of fields removed is returned.
  
  Note that if you pass in multiple field names then it is generally not
  possible to tell which of the returned values belonged to which field.
  
  =item $h->remove_content_headers
  
  This will remove all the header fields used to describe the content of
  a message.  All header field names prefixed with C<Content-> fall
  into this category, as well as C<Allow>, C<Expires> and
  C<Last-Modified>.  RFC 2616 denotes these fields as I<Entity Header
  Fields>.
  
  The return value is a new C<HTTP::Headers> object that contains the
  removed headers only.
  
  =item $h->clear
  
  This will remove all header fields.
  
  =item $h->header_field_names
  
  Returns the list of distinct names for the fields present in the
  header.  The field names have case as suggested by HTTP spec, and the
  names are returned in the recommended "Good Practice" order.
  
  In scalar context return the number of distinct field names.
  
  =item $h->scan( \&process_header_field )
  
  Apply a subroutine to each header field in turn.  The callback routine
  is called with two parameters; the name of the field and a single
  value (a string).  If a header field is multi-valued, then the
  routine is called once for each value.  The field name passed to the
  callback routine has case as suggested by HTTP spec, and the headers
  will be visited in the recommended "Good Practice" order.
  
  Any return values of the callback routine are ignored.  The loop can
  be broken by raising an exception (C<die>), but the caller of scan()
  would have to trap the exception itself.
  
  =item $h->as_string
  
  =item $h->as_string( $eol )
  
  Return the header fields as a formatted MIME header.  Since it
  internally uses the C<scan> method to build the string, the result
  will use case as suggested by HTTP spec, and it will follow
  recommended "Good Practice" of ordering the header fields.  Long header
  values are not folded.
  
  The optional $eol parameter specifies the line ending sequence to
  use.  The default is "\n".  Embedded "\n" characters in header field
  values will be substituted with this line ending sequence.
  
  =back
  
  =head1 CONVENIENCE METHODS
  
  The most frequently used headers can also be accessed through the
  following convenience methods.  Most of these methods can both be used to read
  and to set the value of a header.  The header value is set if you pass
  an argument to the method.  The old header value is always returned.
  If the given header did not exist then C<undef> is returned.
  
  Methods that deal with dates/times always convert their value to system
  time (seconds since Jan 1, 1970) and they also expect this kind of
  value when the header value is set.
  
  =over 4
  
  =item $h->date
  
  This header represents the date and time at which the message was
  originated. I<E.g.>:
  
    $h->date(time);  # set current date
  
  =item $h->expires
  
  This header gives the date and time after which the entity should be
  considered stale.
  
  =item $h->if_modified_since
  
  =item $h->if_unmodified_since
  
  These header fields are used to make a request conditional.  If the requested
  resource has (or has not) been modified since the time specified in this field,
  then the server will return a C<304 Not Modified> response instead of
  the document itself.
  
  =item $h->last_modified
  
  This header indicates the date and time at which the resource was last
  modified. I<E.g.>:
  
    # check if document is more than 1 hour old
    if (my $last_mod = $h->last_modified) {
        if ($last_mod < time - 60*60) {
  	  ...
        }
    }
  
  =item $h->content_type
  
  The Content-Type header field indicates the media type of the message
  content. I<E.g.>:
  
    $h->content_type('text/html');
  
  The value returned will be converted to lower case, and potential
  parameters will be chopped off and returned as a separate value if in
  an array context.  If there is no such header field, then the empty
  string is returned.  This makes it safe to do the following:
  
    if ($h->content_type eq 'text/html') {
       # we enter this place even if the real header value happens to
       # be 'TEXT/HTML; version=3.0'
       ...
    }
  
  =item $h->content_type_charset
  
  Returns the upper-cased charset specified in the Content-Type header.  In list
  context return the lower-cased bare content type followed by the upper-cased
  charset.  Both values will be C<undef> if not specified in the header.
  
  =item $h->content_is_text
  
  Returns TRUE if the Content-Type header field indicate that the
  content is textual.
  
  =item $h->content_is_html
  
  Returns TRUE if the Content-Type header field indicate that the
  content is some kind of HTML (including XHTML).  This method can't be
  used to set Content-Type.
  
  =item $h->content_is_xhtml
  
  Returns TRUE if the Content-Type header field indicate that the
  content is XHTML.  This method can't be used to set Content-Type.
  
  =item $h->content_is_xml
  
  Returns TRUE if the Content-Type header field indicate that the
  content is XML.  This method can't be used to set Content-Type.
  
  =item $h->content_encoding
  
  The Content-Encoding header field is used as a modifier to the
  media type.  When present, its value indicates what additional
  encoding mechanism has been applied to the resource.
  
  =item $h->content_length
  
  A decimal number indicating the size in bytes of the message content.
  
  =item $h->content_language
  
  The natural language(s) of the intended audience for the message
  content.  The value is one or more language tags as defined by RFC
  1766.  Eg. "no" for some kind of Norwegian and "en-US" for English the
  way it is written in the US.
  
  =item $h->title
  
  The title of the document.  In libwww-perl this header will be
  initialized automatically from the E<lt>TITLE>...E<lt>/TITLE> element
  of HTML documents.  I<This header is no longer part of the HTTP
  standard.>
  
  =item $h->user_agent
  
  This header field is used in request messages and contains information
  about the user agent originating the request.  I<E.g.>:
  
    $h->user_agent('Mozilla/5.0 (compatible; MSIE 7.0; Windows NT 6.0)');
  
  =item $h->server
  
  The server header field contains information about the software being
  used by the originating server program handling the request.
  
  =item $h->from
  
  This header should contain an Internet e-mail address for the human
  user who controls the requesting user agent.  The address should be
  machine-usable, as defined by RFC822.  E.g.:
  
    $h->from('King Kong <king@kong.com>');
  
  I<This header is no longer part of the HTTP standard.>
  
  =item $h->referer
  
  Used to specify the address (URI) of the document from which the
  requested resource address was obtained.
  
  The "Free On-line Dictionary of Computing" as this to say about the
  word I<referer>:
  
       <World-Wide Web> A misspelling of "referrer" which
       somehow made it into the {HTTP} standard.  A given {web
       page}'s referer (sic) is the {URL} of whatever web page
       contains the link that the user followed to the current
       page.  Most browsers pass this information as part of a
       request.
  
       (1998-10-19)
  
  By popular demand C<referrer> exists as an alias for this method so you
  can avoid this misspelling in your programs and still send the right
  thing on the wire.
  
  When setting the referrer, this method removes the fragment from the
  given URI if it is present, as mandated by RFC2616.  Note that
  the removal does I<not> happen automatically if using the header(),
  push_header() or init_header() methods to set the referrer.
  
  =item $h->www_authenticate
  
  This header must be included as part of a C<401 Unauthorized> response.
  The field value consist of a challenge that indicates the
  authentication scheme and parameters applicable to the requested URI.
  
  =item $h->proxy_authenticate
  
  This header must be included in a C<407 Proxy Authentication Required>
  response.
  
  =item $h->authorization
  
  =item $h->proxy_authorization
  
  A user agent that wishes to authenticate itself with a server or a
  proxy, may do so by including these headers.
  
  =item $h->authorization_basic
  
  This method is used to get or set an authorization header that use the
  "Basic Authentication Scheme".  In array context it will return two
  values; the user name and the password.  In scalar context it will
  return I<"uname:password"> as a single string value.
  
  When used to set the header value, it expects two arguments.  I<E.g.>:
  
    $h->authorization_basic($uname, $password);
  
  The method will croak if the $uname contains a colon ':'.
  
  =item $h->proxy_authorization_basic
  
  Same as authorization_basic() but will set the "Proxy-Authorization"
  header instead.
  
  =back
  
  =head1 NON-CANONICALIZED FIELD NAMES
  
  The header field name spelling is normally canonicalized including the
  '_' to '-' translation.  There are some application where this is not
  appropriate.  Prefixing field names with ':' allow you to force a
  specific spelling.  For example if you really want a header field name
  to show up as C<foo_bar> instead of "Foo-Bar", you might set it like
  this:
  
    $h->header(":foo_bar" => 1);
  
  These field names are returned with the ':' intact for
  $h->header_field_names and the $h->scan callback, but the colons do
  not show in $h->as_string.
  
  =head1 COPYRIGHT
  
  Copyright 1995-2005 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_HEADERS

$fatpacked{"HTTP/Headers/Auth.pm"} = <<'HTTP_HEADERS_AUTH';
  package HTTP::Headers::Auth;
  
  use strict;
  use vars qw($VERSION);
  $VERSION = "6.00";
  
  use HTTP::Headers;
  
  package HTTP::Headers;
  
  BEGIN {
      # we provide a new (and better) implementations below
      undef(&www_authenticate);
      undef(&proxy_authenticate);
  }
  
  require HTTP::Headers::Util;
  
  sub _parse_authenticate
  {
      my @ret;
      for (HTTP::Headers::Util::split_header_words(@_)) {
  	if (!defined($_->[1])) {
  	    # this is a new auth scheme
  	    push(@ret, shift(@$_) => {});
  	    shift @$_;
  	}
  	if (@ret) {
  	    # this a new parameter pair for the last auth scheme
  	    while (@$_) {
  		my $k = shift @$_;
  		my $v = shift @$_;
  	        $ret[-1]{$k} = $v;
  	    }
  	}
  	else {
  	    # something wrong, parameter pair without any scheme seen
  	    # IGNORE
  	}
      }
      @ret;
  }
  
  sub _authenticate
  {
      my $self = shift;
      my $header = shift;
      my @old = $self->_header($header);
      if (@_) {
  	$self->remove_header($header);
  	my @new = @_;
  	while (@new) {
  	    my $a_scheme = shift(@new);
  	    if ($a_scheme =~ /\s/) {
  		# assume complete valid value, pass it through
  		$self->push_header($header, $a_scheme);
  	    }
  	    else {
  		my @param;
  		if (@new) {
  		    my $p = $new[0];
  		    if (ref($p) eq "ARRAY") {
  			@param = @$p;
  			shift(@new);
  		    }
  		    elsif (ref($p) eq "HASH") {
  			@param = %$p;
  			shift(@new);
  		    }
  		}
  		my $val = ucfirst(lc($a_scheme));
  		if (@param) {
  		    my $sep = " ";
  		    while (@param) {
  			my $k = shift @param;
  			my $v = shift @param;
  			if ($v =~ /[^0-9a-zA-Z]/ || lc($k) eq "realm") {
  			    # must quote the value
  			    $v =~ s,([\\\"]),\\$1,g;
  			    $v = qq("$v");
  			}
  			$val .= "$sep$k=$v";
  			$sep = ", ";
  		    }
  		}
  		$self->push_header($header, $val);
  	    }
  	}
      }
      return unless defined wantarray;
      wantarray ? _parse_authenticate(@old) : join(", ", @old);
  }
  
  
  sub www_authenticate    { shift->_authenticate("WWW-Authenticate", @_)   }
  sub proxy_authenticate  { shift->_authenticate("Proxy-Authenticate", @_) }
  
  1;
HTTP_HEADERS_AUTH

$fatpacked{"HTTP/Headers/ETag.pm"} = <<'HTTP_HEADERS_ETAG';
  package HTTP::Headers::ETag;
  
  use strict;
  use vars qw($VERSION);
  $VERSION = "6.00";
  
  require HTTP::Date;
  
  require HTTP::Headers;
  package HTTP::Headers;
  
  sub _etags
  {
      my $self = shift;
      my $header = shift;
      my @old = _split_etag_list($self->_header($header));
      if (@_) {
  	$self->_header($header => join(", ", _split_etag_list(@_)));
      }
      wantarray ? @old : join(", ", @old);
  }
  
  sub etag          { shift->_etags("ETag", @_); }
  sub if_match      { shift->_etags("If-Match", @_); }
  sub if_none_match { shift->_etags("If-None-Match", @_); }
  
  sub if_range {
      # Either a date or an entity-tag
      my $self = shift;
      my @old = $self->_header("If-Range");
      if (@_) {
  	my $new = shift;
  	if (!defined $new) {
  	    $self->remove_header("If-Range");
  	}
  	elsif ($new =~ /^\d+$/) {
  	    $self->_date_header("If-Range", $new);
  	}
  	else {
  	    $self->_etags("If-Range", $new);
  	}
      }
      return unless defined(wantarray);
      for (@old) {
  	my $t = HTTP::Date::str2time($_);
  	$_ = $t if $t;
      }
      wantarray ? @old : join(", ", @old);
  }
  
  
  # Split a list of entity tag values.  The return value is a list
  # consisting of one element per entity tag.  Suitable for parsing
  # headers like C<If-Match>, C<If-None-Match>.  You might even want to
  # use it on C<ETag> and C<If-Range> entity tag values, because it will
  # normalize them to the common form.
  #
  #  entity-tag	  = [ weak ] opaque-tag
  #  weak		  = "W/"
  #  opaque-tag	  = quoted-string
  
  
  sub _split_etag_list
  {
      my(@val) = @_;
      my @res;
      for (@val) {
          while (length) {
              my $weak = "";
  	    $weak = "W/" if s,^\s*[wW]/,,;
              my $etag = "";
  	    if (s/^\s*(\"[^\"\\]*(?:\\.[^\"\\]*)*\")//) {
  		push(@res, "$weak$1");
              }
              elsif (s/^\s*,//) {
                  push(@res, qq(W/"")) if $weak;
              }
              elsif (s/^\s*([^,\s]+)//) {
                  $etag = $1;
  		$etag =~ s/([\"\\])/\\$1/g;
  	        push(@res, qq($weak"$etag"));
              }
              elsif (s/^\s+// || !length) {
                  push(@res, qq(W/"")) if $weak;
              }
              else {
  	 	die "This should not happen: '$_'";
              }
          }
     }
     @res;
  }
  
  1;
HTTP_HEADERS_ETAG

$fatpacked{"HTTP/Headers/Util.pm"} = <<'HTTP_HEADERS_UTIL';
  package HTTP::Headers::Util;
  
  use strict;
  use vars qw($VERSION @ISA @EXPORT_OK);
  
  $VERSION = "6.03";
  
  require Exporter;
  @ISA=qw(Exporter);
  
  @EXPORT_OK=qw(split_header_words _split_header_words join_header_words);
  
  
  
  sub split_header_words {
      my @res = &_split_header_words;
      for my $arr (@res) {
  	for (my $i = @$arr - 2; $i >= 0; $i -= 2) {
  	    $arr->[$i] = lc($arr->[$i]);
  	}
      }
      return @res;
  }
  
  sub _split_header_words
  {
      my(@val) = @_;
      my @res;
      for (@val) {
  	my @cur;
  	while (length) {
  	    if (s/^\s*(=*[^\s=;,]+)//) {  # 'token' or parameter 'attribute'
  		push(@cur, $1);
  		# a quoted value
  		if (s/^\s*=\s*\"([^\"\\]*(?:\\.[^\"\\]*)*)\"//) {
  		    my $val = $1;
  		    $val =~ s/\\(.)/$1/g;
  		    push(@cur, $val);
  		# some unquoted value
  		}
  		elsif (s/^\s*=\s*([^;,\s]*)//) {
  		    my $val = $1;
  		    $val =~ s/\s+$//;
  		    push(@cur, $val);
  		# no value, a lone token
  		}
  		else {
  		    push(@cur, undef);
  		}
  	    }
  	    elsif (s/^\s*,//) {
  		push(@res, [@cur]) if @cur;
  		@cur = ();
  	    }
  	    elsif (s/^\s*;// || s/^\s+//) {
  		# continue
  	    }
  	    else {
  		die "This should not happen: '$_'";
  	    }
  	}
  	push(@res, \@cur) if @cur;
      }
      @res;
  }
  
  
  sub join_header_words
  {
      @_ = ([@_]) if @_ && !ref($_[0]);
      my @res;
      for (@_) {
  	my @cur = @$_;
  	my @attr;
  	while (@cur) {
  	    my $k = shift @cur;
  	    my $v = shift @cur;
  	    if (defined $v) {
  		if ($v =~ /[\x00-\x20()<>@,;:\\\"\/\[\]?={}\x7F-\xFF]/ || !length($v)) {
  		    $v =~ s/([\"\\])/\\$1/g;  # escape " and \
  		    $k .= qq(="$v");
  		}
  		else {
  		    # token
  		    $k .= "=$v";
  		}
  	    }
  	    push(@attr, $k);
  	}
  	push(@res, join("; ", @attr)) if @attr;
      }
      join(", ", @res);
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Headers::Util - Header value parsing utility functions
  
  =head1 SYNOPSIS
  
    use HTTP::Headers::Util qw(split_header_words);
    @values = split_header_words($h->header("Content-Type"));
  
  =head1 DESCRIPTION
  
  This module provides a few functions that helps parsing and
  construction of valid HTTP header values.  None of the functions are
  exported by default.
  
  The following functions are available:
  
  =over 4
  
  
  =item split_header_words( @header_values )
  
  This function will parse the header values given as argument into a
  list of anonymous arrays containing key/value pairs.  The function
  knows how to deal with ",", ";" and "=" as well as quoted values after
  "=".  A list of space separated tokens are parsed as if they were
  separated by ";".
  
  If the @header_values passed as argument contains multiple values,
  then they are treated as if they were a single value separated by
  comma ",".
  
  This means that this function is useful for parsing header fields that
  follow this syntax (BNF as from the HTTP/1.1 specification, but we relax
  the requirement for tokens).
  
    headers           = #header
    header            = (token | parameter) *( [";"] (token | parameter))
  
    token             = 1*<any CHAR except CTLs or separators>
    separators        = "(" | ")" | "<" | ">" | "@"
                      | "," | ";" | ":" | "\" | <">
                      | "/" | "[" | "]" | "?" | "="
                      | "{" | "}" | SP | HT
  
    quoted-string     = ( <"> *(qdtext | quoted-pair ) <"> )
    qdtext            = <any TEXT except <">>
    quoted-pair       = "\" CHAR
  
    parameter         = attribute "=" value
    attribute         = token
    value             = token | quoted-string
  
  Each I<header> is represented by an anonymous array of key/value
  pairs.  The keys will be all be forced to lower case.
  The value for a simple token (not part of a parameter) is C<undef>.
  Syntactically incorrect headers will not necessarily be parsed as you
  would want.
  
  This is easier to describe with some examples:
  
     split_header_words('foo="bar"; port="80,81"; DISCARD, BAR=baz');
     split_header_words('text/html; charset="iso-8859-1"');
     split_header_words('Basic realm="\\"foo\\\\bar\\""');
  
  will return
  
     [foo=>'bar', port=>'80,81', discard=> undef], [bar=>'baz' ]
     ['text/html' => undef, charset => 'iso-8859-1']
     [basic => undef, realm => "\"foo\\bar\""]
  
  If you don't want the function to convert tokens and attribute keys to
  lower case you can call it as C<_split_header_words> instead (with a
  leading underscore).
  
  =item join_header_words( @arrays )
  
  This will do the opposite of the conversion done by split_header_words().
  It takes a list of anonymous arrays as arguments (or a list of
  key/value pairs) and produces a single header value.  Attribute values
  are quoted if needed.
  
  Example:
  
     join_header_words(["text/plain" => undef, charset => "iso-8859/1"]);
     join_header_words("text/plain" => undef, charset => "iso-8859/1");
  
  will both return the string:
  
     text/plain; charset="iso-8859/1"
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 1997-1998, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_HEADERS_UTIL

$fatpacked{"HTTP/Message.pm"} = <<'HTTP_MESSAGE';
  package HTTP::Message;
  
  use strict;
  use vars qw($VERSION $AUTOLOAD);
  $VERSION = "6.06";
  
  require HTTP::Headers;
  require Carp;
  
  my $CRLF = "\015\012";   # "\r\n" is not portable
  unless ($HTTP::URI_CLASS) {
      if ($ENV{PERL_HTTP_URI_CLASS}
      &&  $ENV{PERL_HTTP_URI_CLASS} =~ /^([\w:]+)$/) {
          $HTTP::URI_CLASS = $1;
      } else {
          $HTTP::URI_CLASS = "URI";
      }
  }
  eval "require $HTTP::URI_CLASS"; die $@ if $@;
  
  *_utf8_downgrade = defined(&utf8::downgrade) ?
      sub {
          utf8::downgrade($_[0], 1) or
              Carp::croak("HTTP::Message content must be bytes")
      }
      :
      sub {
      };
  
  sub new
  {
      my($class, $header, $content) = @_;
      if (defined $header) {
  	Carp::croak("Bad header argument") unless ref $header;
          if (ref($header) eq "ARRAY") {
  	    $header = HTTP::Headers->new(@$header);
  	}
  	else {
  	    $header = $header->clone;
  	}
      }
      else {
  	$header = HTTP::Headers->new;
      }
      if (defined $content) {
          _utf8_downgrade($content);
      }
      else {
          $content = '';
      }
  
      bless {
  	'_headers' => $header,
  	'_content' => $content,
      }, $class;
  }
  
  
  sub parse
  {
      my($class, $str) = @_;
  
      my @hdr;
      while (1) {
  	if ($str =~ s/^([^\s:]+)[ \t]*: ?(.*)\n?//) {
  	    push(@hdr, $1, $2);
  	    $hdr[-1] =~ s/\r\z//;
  	}
  	elsif (@hdr && $str =~ s/^([ \t].*)\n?//) {
  	    $hdr[-1] .= "\n$1";
  	    $hdr[-1] =~ s/\r\z//;
  	}
  	else {
  	    $str =~ s/^\r?\n//;
  	    last;
  	}
      }
      local $HTTP::Headers::TRANSLATE_UNDERSCORE;
      new($class, \@hdr, $str);
  }
  
  
  sub clone
  {
      my $self  = shift;
      my $clone = HTTP::Message->new($self->headers,
  				   $self->content);
      $clone->protocol($self->protocol);
      $clone;
  }
  
  
  sub clear {
      my $self = shift;
      $self->{_headers}->clear;
      $self->content("");
      delete $self->{_parts};
      return;
  }
  
  
  sub protocol {
      shift->_elem('_protocol',  @_);
  }
  
  sub headers {
      my $self = shift;
  
      # recalculation of _content might change headers, so we
      # need to force it now
      $self->_content unless exists $self->{_content};
  
      $self->{_headers};
  }
  
  sub headers_as_string {
      shift->headers->as_string(@_);
  }
  
  
  sub content  {
  
      my $self = $_[0];
      if (defined(wantarray)) {
  	$self->_content unless exists $self->{_content};
  	my $old = $self->{_content};
  	$old = $$old if ref($old) eq "SCALAR";
  	&_set_content if @_ > 1;
  	return $old;
      }
  
      if (@_ > 1) {
  	&_set_content;
      }
      else {
  	Carp::carp("Useless content call in void context") if $^W;
      }
  }
  
  
  sub _set_content {
      my $self = $_[0];
      _utf8_downgrade($_[1]);
      if (!ref($_[1]) && ref($self->{_content}) eq "SCALAR") {
  	${$self->{_content}} = $_[1];
      }
      else {
  	die "Can't set content to be a scalar reference" if ref($_[1]) eq "SCALAR";
  	$self->{_content} = $_[1];
  	delete $self->{_content_ref};
      }
      delete $self->{_parts} unless $_[2];
  }
  
  
  sub add_content
  {
      my $self = shift;
      $self->_content unless exists $self->{_content};
      my $chunkref = \$_[0];
      $chunkref = $$chunkref if ref($$chunkref);  # legacy
  
      _utf8_downgrade($$chunkref);
  
      my $ref = ref($self->{_content});
      if (!$ref) {
  	$self->{_content} .= $$chunkref;
      }
      elsif ($ref eq "SCALAR") {
  	${$self->{_content}} .= $$chunkref;
      }
      else {
  	Carp::croak("Can't append to $ref content");
      }
      delete $self->{_parts};
  }
  
  sub add_content_utf8 {
      my($self, $buf)  = @_;
      utf8::upgrade($buf);
      utf8::encode($buf);
      $self->add_content($buf);
  }
  
  sub content_ref
  {
      my $self = shift;
      $self->_content unless exists $self->{_content};
      delete $self->{_parts};
      my $old = \$self->{_content};
      my $old_cref = $self->{_content_ref};
      if (@_) {
  	my $new = shift;
  	Carp::croak("Setting content_ref to a non-ref") unless ref($new);
  	delete $self->{_content};  # avoid modifying $$old
  	$self->{_content} = $new;
  	$self->{_content_ref}++;
      }
      $old = $$old if $old_cref;
      return $old;
  }
  
  
  sub content_charset
  {
      my $self = shift;
      if (my $charset = $self->content_type_charset) {
  	return $charset;
      }
  
      # time to start guessing
      my $cref = $self->decoded_content(ref => 1, charset => "none");
  
      # Unicode BOM
      for ($$cref) {
  	return "UTF-8"     if /^\xEF\xBB\xBF/;
  	return "UTF-32LE" if /^\xFF\xFE\x00\x00/;
  	return "UTF-32BE" if /^\x00\x00\xFE\xFF/;
  	return "UTF-16LE" if /^\xFF\xFE/;
  	return "UTF-16BE" if /^\xFE\xFF/;
      }
  
      if ($self->content_is_xml) {
  	# http://www.w3.org/TR/2006/REC-xml-20060816/#sec-guessing
  	# XML entity not accompanied by external encoding information and not
  	# in UTF-8 or UTF-16 encoding must begin with an XML encoding declaration,
  	# in which the first characters must be '<?xml'
  	for ($$cref) {
  	    return "UTF-32BE" if /^\x00\x00\x00</;
  	    return "UTF-32LE" if /^<\x00\x00\x00/;
  	    return "UTF-16BE" if /^(?:\x00\s)*\x00</;
  	    return "UTF-16LE" if /^(?:\s\x00)*<\x00/;
  	    if (/^\s*(<\?xml[^\x00]*?\?>)/) {
  		if ($1 =~ /\sencoding\s*=\s*(["'])(.*?)\1/) {
  		    my $enc = $2;
  		    $enc =~ s/^\s+//; $enc =~ s/\s+\z//;
  		    return $enc if $enc;
  		}
  	    }
  	}
  	return "UTF-8";
      }
      elsif ($self->content_is_html) {
  	# look for <META charset="..."> or <META content="...">
  	# http://dev.w3.org/html5/spec/Overview.html#determining-the-character-encoding
  	require IO::HTML;
  	# Use relaxed search to match previous versions of HTTP::Message:
  	my $encoding = IO::HTML::find_charset_in($$cref, { encoding    => 1,
  	                                                   need_pragma => 0 });
  	return $encoding->mime_name if $encoding;
      }
      elsif ($self->content_type eq "application/json") {
  	for ($$cref) {
  	    # RFC 4627, ch 3
  	    return "UTF-32BE" if /^\x00\x00\x00./s;
  	    return "UTF-32LE" if /^.\x00\x00\x00/s;
  	    return "UTF-16BE" if /^\x00.\x00./s;
  	    return "UTF-16LE" if /^.\x00.\x00/s;
  	    return "UTF-8";
  	}
      }
      if ($self->content_type =~ /^text\//) {
  	for ($$cref) {
  	    if (length) {
  		return "US-ASCII" unless /[\x80-\xFF]/;
  		require Encode;
  		eval {
  		    Encode::decode_utf8($_, Encode::FB_CROAK() | Encode::LEAVE_SRC());
  		};
  		return "UTF-8" unless $@;
  		return "ISO-8859-1";
  	    }
  	}
      }
  
      return undef;
  }
  
  
  sub decoded_content
  {
      my($self, %opt) = @_;
      my $content_ref;
      my $content_ref_iscopy;
  
      eval {
  	$content_ref = $self->content_ref;
  	die "Can't decode ref content" if ref($content_ref) ne "SCALAR";
  
  	if (my $h = $self->header("Content-Encoding")) {
  	    $h =~ s/^\s+//;
  	    $h =~ s/\s+$//;
  	    for my $ce (reverse split(/\s*,\s*/, lc($h))) {
  		next unless $ce;
  		next if $ce eq "identity";
  		if ($ce eq "gzip" || $ce eq "x-gzip") {
  		    require IO::Uncompress::Gunzip;
  		    my $output;
  		    IO::Uncompress::Gunzip::gunzip($content_ref, \$output, Transparent => 0)
  			or die "Can't gunzip content: $IO::Uncompress::Gunzip::GunzipError";
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "x-bzip2" or $ce eq "bzip2") {
  		    require IO::Uncompress::Bunzip2;
  		    my $output;
  		    IO::Uncompress::Bunzip2::bunzip2($content_ref, \$output, Transparent => 0)
  			or die "Can't bunzip content: $IO::Uncompress::Bunzip2::Bunzip2Error";
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "deflate") {
  		    require IO::Uncompress::Inflate;
  		    my $output;
  		    my $status = IO::Uncompress::Inflate::inflate($content_ref, \$output, Transparent => 0);
  		    my $error = $IO::Uncompress::Inflate::InflateError;
  		    unless ($status) {
  			# "Content-Encoding: deflate" is supposed to mean the
  			# "zlib" format of RFC 1950, but Microsoft got that
  			# wrong, so some servers sends the raw compressed
  			# "deflate" data.  This tries to inflate this format.
  			$output = undef;
  			require IO::Uncompress::RawInflate;
  			unless (IO::Uncompress::RawInflate::rawinflate($content_ref, \$output)) {
  			    $self->push_header("Client-Warning" =>
  				"Could not raw inflate content: $IO::Uncompress::RawInflate::RawInflateError");
  			    $output = undef;
  			}
  		    }
  		    die "Can't inflate content: $error" unless defined $output;
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "compress" || $ce eq "x-compress") {
  		    die "Can't uncompress content";
  		}
  		elsif ($ce eq "base64") {  # not really C-T-E, but should be harmless
  		    require MIME::Base64;
  		    $content_ref = \MIME::Base64::decode($$content_ref);
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "quoted-printable") { # not really C-T-E, but should be harmless
  		    require MIME::QuotedPrint;
  		    $content_ref = \MIME::QuotedPrint::decode($$content_ref);
  		    $content_ref_iscopy++;
  		}
  		else {
  		    die "Don't know how to decode Content-Encoding '$ce'";
  		}
  	    }
  	}
  
  	if ($self->content_is_text || (my $is_xml = $self->content_is_xml)) {
  	    my $charset = lc(
  	        $opt{charset} ||
  		$self->content_type_charset ||
  		$opt{default_charset} ||
  		$self->content_charset ||
  		"ISO-8859-1"
  	    );
  	    if ($charset eq "none") {
  		# leave it asis
  	    }
  	    elsif ($charset eq "us-ascii" || $charset eq "iso-8859-1") {
  		if ($$content_ref =~ /[^\x00-\x7F]/ && defined &utf8::upgrade) {
  		    unless ($content_ref_iscopy) {
  			my $copy = $$content_ref;
  			$content_ref = \$copy;
  			$content_ref_iscopy++;
  		    }
  		    utf8::upgrade($$content_ref);
  		}
  	    }
  	    else {
  		require Encode;
  		eval {
  		    $content_ref = \Encode::decode($charset, $$content_ref,
  			 ($opt{charset_strict} ? Encode::FB_CROAK() : 0) | Encode::LEAVE_SRC());
  		};
  		if ($@) {
  		    my $retried;
  		    if ($@ =~ /^Unknown encoding/) {
  			my $alt_charset = lc($opt{alt_charset} || "");
  			if ($alt_charset && $charset ne $alt_charset) {
  			    # Retry decoding with the alternative charset
  			    $content_ref = \Encode::decode($alt_charset, $$content_ref,
  				 ($opt{charset_strict} ? Encode::FB_CROAK() : 0) | Encode::LEAVE_SRC())
  			        unless $alt_charset eq "none";
  			    $retried++;
  			}
  		    }
  		    die unless $retried;
  		}
  		die "Encode::decode() returned undef improperly" unless defined $$content_ref;
  		if ($is_xml) {
  		    # Get rid of the XML encoding declaration if present
  		    $$content_ref =~ s/^\x{FEFF}//;
  		    if ($$content_ref =~ /^(\s*<\?xml[^\x00]*?\?>)/) {
  			substr($$content_ref, 0, length($1)) =~ s/\sencoding\s*=\s*(["']).*?\1//;
  		    }
  		}
  	    }
  	}
      };
      if ($@) {
  	Carp::croak($@) if $opt{raise_error};
  	return undef;
      }
  
      return $opt{ref} ? $content_ref : $$content_ref;
  }
  
  
  sub decodable
  {
      # should match the Content-Encoding values that decoded_content can deal with
      my $self = shift;
      my @enc;
      # XXX preferably we should determine if the modules are available without loading
      # them here
      eval {
          require IO::Uncompress::Gunzip;
          push(@enc, "gzip", "x-gzip");
      };
      eval {
          require IO::Uncompress::Inflate;
          require IO::Uncompress::RawInflate;
          push(@enc, "deflate");
      };
      eval {
          require IO::Uncompress::Bunzip2;
          push(@enc, "x-bzip2");
      };
      # we don't care about announcing the 'identity', 'base64' and
      # 'quoted-printable' stuff
      return wantarray ? @enc : join(", ", @enc);
  }
  
  
  sub decode
  {
      my $self = shift;
      return 1 unless $self->header("Content-Encoding");
      if (defined(my $content = $self->decoded_content(charset => "none"))) {
  	$self->remove_header("Content-Encoding", "Content-Length", "Content-MD5");
  	$self->content($content);
  	return 1;
      }
      return 0;
  }
  
  
  sub encode
  {
      my($self, @enc) = @_;
  
      Carp::croak("Can't encode multipart/* messages") if $self->content_type =~ m,^multipart/,;
      Carp::croak("Can't encode message/* messages") if $self->content_type =~ m,^message/,;
  
      return 1 unless @enc;  # nothing to do
  
      my $content = $self->content;
      for my $encoding (@enc) {
  	if ($encoding eq "identity") {
  	    # nothing to do
  	}
  	elsif ($encoding eq "base64") {
  	    require MIME::Base64;
  	    $content = MIME::Base64::encode($content);
  	}
  	elsif ($encoding eq "gzip" || $encoding eq "x-gzip") {
  	    require IO::Compress::Gzip;
  	    my $output;
  	    IO::Compress::Gzip::gzip(\$content, \$output, Minimal => 1)
  		or die "Can't gzip content: $IO::Compress::Gzip::GzipError";
  	    $content = $output;
  	}
  	elsif ($encoding eq "deflate") {
  	    require IO::Compress::Deflate;
  	    my $output;
  	    IO::Compress::Deflate::deflate(\$content, \$output)
  		or die "Can't deflate content: $IO::Compress::Deflate::DeflateError";
  	    $content = $output;
  	}
  	elsif ($encoding eq "x-bzip2") {
  	    require IO::Compress::Bzip2;
  	    my $output;
  	    IO::Compress::Bzip2::bzip2(\$content, \$output)
  		or die "Can't bzip2 content: $IO::Compress::Bzip2::Bzip2Error";
  	    $content = $output;
  	}
  	elsif ($encoding eq "rot13") {  # for the fun of it
  	    $content =~ tr/A-Za-z/N-ZA-Mn-za-m/;
  	}
  	else {
  	    return 0;
  	}
      }
      my $h = $self->header("Content-Encoding");
      unshift(@enc, $h) if $h;
      $self->header("Content-Encoding", join(", ", @enc));
      $self->remove_header("Content-Length", "Content-MD5");
      $self->content($content);
      return 1;
  }
  
  
  sub as_string
  {
      my($self, $eol) = @_;
      $eol = "\n" unless defined $eol;
  
      # The calculation of content might update the headers
      # so we need to do that first.
      my $content = $self->content;
  
      return join("", $self->{'_headers'}->as_string($eol),
  		    $eol,
  		    $content,
  		    (@_ == 1 && length($content) &&
  		     $content !~ /\n\z/) ? "\n" : "",
  		);
  }
  
  
  sub dump
  {
      my($self, %opt) = @_;
      my $content = $self->content;
      my $chopped = 0;
      if (!ref($content)) {
  	my $maxlen = $opt{maxlength};
  	$maxlen = 512 unless defined($maxlen);
  	if ($maxlen && length($content) > $maxlen * 1.1 + 3) {
  	    $chopped = length($content) - $maxlen;
  	    $content = substr($content, 0, $maxlen) . "...";
  	}
  
  	$content =~ s/\\/\\\\/g;
  	$content =~ s/\t/\\t/g;
  	$content =~ s/\r/\\r/g;
  
  	# no need for 3 digits in escape for these
  	$content =~ s/([\0-\11\13-\037])(?!\d)/sprintf('\\%o',ord($1))/eg;
  
  	$content =~ s/([\0-\11\13-\037\177-\377])/sprintf('\\x%02X',ord($1))/eg;
  	$content =~ s/([^\12\040-\176])/sprintf('\\x{%X}',ord($1))/eg;
  
  	# remaining whitespace
  	$content =~ s/( +)\n/("\\40" x length($1)) . "\n"/eg;
  	$content =~ s/(\n+)\n/("\\n" x length($1)) . "\n"/eg;
  	$content =~ s/\n\z/\\n/;
  
  	my $no_content = $opt{no_content};
  	$no_content = "(no content)" unless defined $no_content;
  	if ($content eq $no_content) {
  	    # escape our $no_content marker
  	    $content =~ s/^(.)/sprintf('\\x%02X',ord($1))/eg;
  	}
  	elsif ($content eq "") {
  	    $content = $no_content;
  	}
      }
  
      my @dump;
      push(@dump, $opt{preheader}) if $opt{preheader};
      push(@dump, $self->{_headers}->as_string, $content);
      push(@dump, "(+ $chopped more bytes not shown)") if $chopped;
  
      my $dump = join("\n", @dump, "");
      $dump =~ s/^/$opt{prefix}/gm if $opt{prefix};
  
      print $dump unless defined wantarray;
      return $dump;
  }
  
  
  sub parts {
      my $self = shift;
      if (defined(wantarray) && (!exists $self->{_parts} || ref($self->{_content}) eq "SCALAR")) {
  	$self->_parts;
      }
      my $old = $self->{_parts};
      if (@_) {
  	my @parts = map { ref($_) eq 'ARRAY' ? @$_ : $_ } @_;
  	my $ct = $self->content_type || "";
  	if ($ct =~ m,^message/,) {
  	    Carp::croak("Only one part allowed for $ct content")
  		if @parts > 1;
  	}
  	elsif ($ct !~ m,^multipart/,) {
  	    $self->remove_content_headers;
  	    $self->content_type("multipart/mixed");
  	}
  	$self->{_parts} = \@parts;
  	_stale_content($self);
      }
      return @$old if wantarray;
      return $old->[0];
  }
  
  sub add_part {
      my $self = shift;
      if (($self->content_type || "") !~ m,^multipart/,) {
  	my $p = HTTP::Message->new($self->remove_content_headers,
  				   $self->content(""));
  	$self->content_type("multipart/mixed");
  	$self->{_parts} = [];
          if ($p->headers->header_field_names || $p->content ne "") {
              push(@{$self->{_parts}}, $p);
          }
      }
      elsif (!exists $self->{_parts} || ref($self->{_content}) eq "SCALAR") {
  	$self->_parts;
      }
  
      push(@{$self->{_parts}}, @_);
      _stale_content($self);
      return;
  }
  
  sub _stale_content {
      my $self = shift;
      if (ref($self->{_content}) eq "SCALAR") {
  	# must recalculate now
  	$self->_content;
      }
      else {
  	# just invalidate cache
  	delete $self->{_content};
  	delete $self->{_content_ref};
      }
  }
  
  
  # delegate all other method calls the the headers object.
  sub AUTOLOAD
  {
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
  
      # We create the function here so that it will not need to be
      # autoloaded the next time.
      no strict 'refs';
      *$method = sub { local $Carp::Internal{+__PACKAGE__} = 1; shift->headers->$method(@_) };
      goto &$method;
  }
  
  
  sub DESTROY {}  # avoid AUTOLOADing it
  
  
  # Private method to access members in %$self
  sub _elem
  {
      my $self = shift;
      my $elem = shift;
      my $old = $self->{$elem};
      $self->{$elem} = $_[0] if @_;
      return $old;
  }
  
  
  # Create private _parts attribute from current _content
  sub _parts {
      my $self = shift;
      my $ct = $self->content_type;
      if ($ct =~ m,^multipart/,) {
  	require HTTP::Headers::Util;
  	my @h = HTTP::Headers::Util::split_header_words($self->header("Content-Type"));
  	die "Assert" unless @h;
  	my %h = @{$h[0]};
  	if (defined(my $b = $h{boundary})) {
  	    my $str = $self->content;
  	    $str =~ s/\r?\n--\Q$b\E--.*//s;
  	    if ($str =~ s/(^|.*?\r?\n)--\Q$b\E\r?\n//s) {
  		$self->{_parts} = [map HTTP::Message->parse($_),
  				   split(/\r?\n--\Q$b\E\r?\n/, $str)]
  	    }
  	}
      }
      elsif ($ct eq "message/http") {
  	require HTTP::Request;
  	require HTTP::Response;
  	my $content = $self->content;
  	my $class = ($content =~ m,^(HTTP/.*)\n,) ?
  	    "HTTP::Response" : "HTTP::Request";
  	$self->{_parts} = [$class->parse($content)];
      }
      elsif ($ct =~ m,^message/,) {
  	$self->{_parts} = [ HTTP::Message->parse($self->content) ];
      }
  
      $self->{_parts} ||= [];
  }
  
  
  # Create private _content attribute from current _parts
  sub _content {
      my $self = shift;
      my $ct = $self->{_headers}->header("Content-Type") || "multipart/mixed";
      if ($ct =~ m,^\s*message/,i) {
  	_set_content($self, $self->{_parts}[0]->as_string($CRLF), 1);
  	return;
      }
  
      require HTTP::Headers::Util;
      my @v = HTTP::Headers::Util::split_header_words($ct);
      Carp::carp("Multiple Content-Type headers") if @v > 1;
      @v = @{$v[0]};
  
      my $boundary;
      my $boundary_index;
      for (my @tmp = @v; @tmp;) {
  	my($k, $v) = splice(@tmp, 0, 2);
  	if ($k eq "boundary") {
  	    $boundary = $v;
  	    $boundary_index = @v - @tmp - 1;
  	    last;
  	}
      }
  
      my @parts = map $_->as_string($CRLF), @{$self->{_parts}};
  
      my $bno = 0;
      $boundary = _boundary() unless defined $boundary;
   CHECK_BOUNDARY:
      {
  	for (@parts) {
  	    if (index($_, $boundary) >= 0) {
  		# must have a better boundary
  		$boundary = _boundary(++$bno);
  		redo CHECK_BOUNDARY;
  	    }
  	}
      }
  
      if ($boundary_index) {
  	$v[$boundary_index] = $boundary;
      }
      else {
  	push(@v, boundary => $boundary);
      }
  
      $ct = HTTP::Headers::Util::join_header_words(@v);
      $self->{_headers}->header("Content-Type", $ct);
  
      _set_content($self, "--$boundary$CRLF" .
  	                join("$CRLF--$boundary$CRLF", @parts) .
  			"$CRLF--$boundary--$CRLF",
                          1);
  }
  
  
  sub _boundary
  {
      my $size = shift || return "xYzZY";
      require MIME::Base64;
      my $b = MIME::Base64::encode(join("", map chr(rand(256)), 1..$size*3), "");
      $b =~ s/[\W]/X/g;  # ensure alnum only
      $b;
  }
  
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Message - HTTP style message (base class)
  
  =head1 SYNOPSIS
  
   use base 'HTTP::Message';
  
  =head1 DESCRIPTION
  
  An C<HTTP::Message> object contains some headers and a content body.
  The following methods are available:
  
  =over 4
  
  =item $mess = HTTP::Message->new
  
  =item $mess = HTTP::Message->new( $headers )
  
  =item $mess = HTTP::Message->new( $headers, $content )
  
  This constructs a new message object.  Normally you would want
  construct C<HTTP::Request> or C<HTTP::Response> objects instead.
  
  The optional $header argument should be a reference to an
  C<HTTP::Headers> object or a plain array reference of key/value pairs.
  If an C<HTTP::Headers> object is provided then a copy of it will be
  embedded into the constructed message, i.e. it will not be owned and
  can be modified afterwards without affecting the message.
  
  The optional $content argument should be a string of bytes.
  
  =item $mess = HTTP::Message->parse( $str )
  
  This constructs a new message object by parsing the given string.
  
  =item $mess->headers
  
  Returns the embedded C<HTTP::Headers> object.
  
  =item $mess->headers_as_string
  
  =item $mess->headers_as_string( $eol )
  
  Call the as_string() method for the headers in the
  message.  This will be the same as
  
      $mess->headers->as_string
  
  but it will make your program a whole character shorter :-)
  
  =item $mess->content
  
  =item $mess->content( $bytes )
  
  The content() method sets the raw content if an argument is given.  If no
  argument is given the content is not touched.  In either case the
  original raw content is returned.
  
  Note that the content should be a string of bytes.  Strings in perl
  can contain characters outside the range of a byte.  The C<Encode>
  module can be used to turn such strings into a string of bytes.
  
  =item $mess->add_content( $bytes )
  
  The add_content() methods appends more data bytes to the end of the
  current content buffer.
  
  =item $mess->add_content_utf8( $string )
  
  The add_content_utf8() method appends the UTF-8 bytes representing the
  string to the end of the current content buffer.
  
  =item $mess->content_ref
  
  =item $mess->content_ref( \$bytes )
  
  The content_ref() method will return a reference to content buffer string.
  It can be more efficient to access the content this way if the content
  is huge, and it can even be used for direct manipulation of the content,
  for instance:
  
    ${$res->content_ref} =~ s/\bfoo\b/bar/g;
  
  This example would modify the content buffer in-place.
  
  If an argument is passed it will setup the content to reference some
  external source.  The content() and add_content() methods
  will automatically dereference scalar references passed this way.  For
  other references content() will return the reference itself and
  add_content() will refuse to do anything.
  
  =item $mess->content_charset
  
  This returns the charset used by the content in the message.  The
  charset is either found as the charset attribute of the
  C<Content-Type> header or by guessing.
  
  See L<http://www.w3.org/TR/REC-html40/charset.html#spec-char-encoding>
  for details about how charset is determined.
  
  =item $mess->decoded_content( %options )
  
  Returns the content with any C<Content-Encoding> undone and for textual content
  the raw content encoded to Perl's Unicode strings.  If the C<Content-Encoding>
  or C<charset> of the message is unknown this method will fail by returning
  C<undef>.
  
  The following options can be specified.
  
  =over
  
  =item C<charset>
  
  This override the charset parameter for text content.  The value
  C<none> can used to suppress decoding of the charset.
  
  =item C<default_charset>
  
  This override the default charset guessed by content_charset() or
  if that fails "ISO-8859-1".
  
  =item C<alt_charset>
  
  If decoding fails because the charset specified in the Content-Type header
  isn't recognized by Perl's Encode module, then try decoding using this charset
  instead of failing.  The C<alt_charset> might be specified as C<none> to simply
  return the string without any decoding of charset as alternative.
  
  =item C<charset_strict>
  
  Abort decoding if malformed characters is found in the content.  By
  default you get the substitution character ("\x{FFFD}") in place of
  malformed characters.
  
  =item C<raise_error>
  
  If TRUE then raise an exception if not able to decode content.  Reason
  might be that the specified C<Content-Encoding> or C<charset> is not
  supported.  If this option is FALSE, then decoded_content() will return
  C<undef> on errors, but will still set $@.
  
  =item C<ref>
  
  If TRUE then a reference to decoded content is returned.  This might
  be more efficient in cases where the decoded content is identical to
  the raw content as no data copying is required in this case.
  
  =back
  
  =item $mess->decodable
  
  =item HTTP::Message::decodable()
  
  This returns the encoding identifiers that decoded_content() can
  process.  In scalar context returns a comma separated string of
  identifiers.
  
  This value is suitable for initializing the C<Accept-Encoding> request
  header field.
  
  =item $mess->decode
  
  This method tries to replace the content of the message with the
  decoded version and removes the C<Content-Encoding> header.  Returns
  TRUE if successful and FALSE if not.
  
  If the message does not have a C<Content-Encoding> header this method
  does nothing and returns TRUE.
  
  Note that the content of the message is still bytes after this method
  has been called and you still need to call decoded_content() if you
  want to process its content as a string.
  
  =item $mess->encode( $encoding, ... )
  
  Apply the given encodings to the content of the message.  Returns TRUE
  if successful. The "identity" (non-)encoding is always supported; other
  currently supported encodings, subject to availability of required
  additional modules, are "gzip", "deflate", "x-bzip2" and "base64".
  
  A successful call to this function will set the C<Content-Encoding>
  header.
  
  Note that C<multipart/*> or C<message/*> messages can't be encoded and
  this method will croak if you try.
  
  =item $mess->parts
  
  =item $mess->parts( @parts )
  
  =item $mess->parts( \@parts )
  
  Messages can be composite, i.e. contain other messages.  The composite
  messages have a content type of C<multipart/*> or C<message/*>.  This
  method give access to the contained messages.
  
  The argumentless form will return a list of C<HTTP::Message> objects.
  If the content type of $msg is not C<multipart/*> or C<message/*> then
  this will return the empty list.  In scalar context only the first
  object is returned.  The returned message parts should be regarded as
  read-only (future versions of this library might make it possible
  to modify the parent by modifying the parts).
  
  If the content type of $msg is C<message/*> then there will only be
  one part returned.
  
  If the content type is C<message/http>, then the return value will be
  either an C<HTTP::Request> or an C<HTTP::Response> object.
  
  If a @parts argument is given, then the content of the message will be
  modified. The array reference form is provided so that an empty list
  can be provided.  The @parts array should contain C<HTTP::Message>
  objects.  The @parts objects are owned by $mess after this call and
  should not be modified or made part of other messages.
  
  When updating the message with this method and the old content type of
  $mess is not C<multipart/*> or C<message/*>, then the content type is
  set to C<multipart/mixed> and all other content headers are cleared.
  
  This method will croak if the content type is C<message/*> and more
  than one part is provided.
  
  =item $mess->add_part( $part )
  
  This will add a part to a message.  The $part argument should be
  another C<HTTP::Message> object.  If the previous content type of
  $mess is not C<multipart/*> then the old content (together with all
  content headers) will be made part #1 and the content type made
  C<multipart/mixed> before the new part is added.  The $part object is
  owned by $mess after this call and should not be modified or made part
  of other messages.
  
  There is no return value.
  
  =item $mess->clear
  
  Will clear the headers and set the content to the empty string.  There
  is no return value
  
  =item $mess->protocol
  
  =item $mess->protocol( $proto )
  
  Sets the HTTP protocol used for the message.  The protocol() is a string
  like C<HTTP/1.0> or C<HTTP/1.1>.
  
  =item $mess->clone
  
  Returns a copy of the message object.
  
  =item $mess->as_string
  
  =item $mess->as_string( $eol )
  
  Returns the message formatted as a single string.
  
  The optional $eol parameter specifies the line ending sequence to use.
  The default is "\n".  If no $eol is given then as_string will ensure
  that the returned string is newline terminated (even when the message
  content is not).  No extra newline is appended if an explicit $eol is
  passed.
  
  =item $mess->dump( %opt )
  
  Returns the message formatted as a string.  In void context print the string.
  
  This differs from C<< $mess->as_string >> in that it escapes the bytes
  of the content so that it's safe to print them and it limits how much
  content to print.  The escapes syntax used is the same as for Perl's
  double quoted strings.  If there is no content the string "(no
  content)" is shown in its place.
  
  Options to influence the output can be passed as key/value pairs. The
  following options are recognized:
  
  =over
  
  =item maxlength => $num
  
  How much of the content to show.  The default is 512.  Set this to 0
  for unlimited.
  
  If the content is longer then the string is chopped at the limit and
  the string "...\n(### more bytes not shown)" appended.
  
  =item no_content => $str
  
  Replaces the "(no content)" marker.
  
  =item prefix => $str
  
  A string that will be prefixed to each line of the dump.
  
  =back
  
  =back
  
  All methods unknown to C<HTTP::Message> itself are delegated to the
  C<HTTP::Headers> object that is part of every message.  This allows
  convenient access to these methods.  Refer to L<HTTP::Headers> for
  details of these methods:
  
      $mess->header( $field => $val )
      $mess->push_header( $field => $val )
      $mess->init_header( $field => $val )
      $mess->remove_header( $field )
      $mess->remove_content_headers
      $mess->header_field_names
      $mess->scan( \&doit )
  
      $mess->date
      $mess->expires
      $mess->if_modified_since
      $mess->if_unmodified_since
      $mess->last_modified
      $mess->content_type
      $mess->content_encoding
      $mess->content_length
      $mess->content_language
      $mess->title
      $mess->user_agent
      $mess->server
      $mess->from
      $mess->referer
      $mess->www_authenticate
      $mess->authorization
      $mess->proxy_authorization
      $mess->authorization_basic
      $mess->proxy_authorization_basic
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_MESSAGE

$fatpacked{"HTTP/Request.pm"} = <<'HTTP_REQUEST';
  package HTTP::Request;
  
  require HTTP::Message;
  @ISA = qw(HTTP::Message);
  $VERSION = "6.00";
  
  use strict;
  
  
  
  sub new
  {
      my($class, $method, $uri, $header, $content) = @_;
      my $self = $class->SUPER::new($header, $content);
      $self->method($method);
      $self->uri($uri);
      $self;
  }
  
  
  sub parse
  {
      my($class, $str) = @_;
      my $request_line;
      if ($str =~ s/^(.*)\n//) {
  	$request_line = $1;
      }
      else {
  	$request_line = $str;
  	$str = "";
      }
  
      my $self = $class->SUPER::parse($str);
      my($method, $uri, $protocol) = split(' ', $request_line);
      $self->method($method) if defined($method);
      $self->uri($uri) if defined($uri);
      $self->protocol($protocol) if $protocol;
      $self;
  }
  
  
  sub clone
  {
      my $self = shift;
      my $clone = bless $self->SUPER::clone, ref($self);
      $clone->method($self->method);
      $clone->uri($self->uri);
      $clone;
  }
  
  
  sub method
  {
      shift->_elem('_method', @_);
  }
  
  
  sub uri
  {
      my $self = shift;
      my $old = $self->{'_uri'};
      if (@_) {
  	my $uri = shift;
  	if (!defined $uri) {
  	    # that's ok
  	}
  	elsif (ref $uri) {
  	    Carp::croak("A URI can't be a " . ref($uri) . " reference")
  		if ref($uri) eq 'HASH' or ref($uri) eq 'ARRAY';
  	    Carp::croak("Can't use a " . ref($uri) . " object as a URI")
  		unless $uri->can('scheme');
  	    $uri = $uri->clone;
  	    unless ($HTTP::URI_CLASS eq "URI") {
  		# Argh!! Hate this... old LWP legacy!
  		eval { local $SIG{__DIE__}; $uri = $uri->abs; };
  		die $@ if $@ && $@ !~ /Missing base argument/;
  	    }
  	}
  	else {
  	    $uri = $HTTP::URI_CLASS->new($uri);
  	}
  	$self->{'_uri'} = $uri;
          delete $self->{'_uri_canonical'};
      }
      $old;
  }
  
  *url = \&uri;  # legacy
  
  sub uri_canonical
  {
      my $self = shift;
      return $self->{'_uri_canonical'} ||= $self->{'_uri'}->canonical;
  }
  
  
  sub accept_decodable
  {
      my $self = shift;
      $self->header("Accept-Encoding", scalar($self->decodable));
  }
  
  sub as_string
  {
      my $self = shift;
      my($eol) = @_;
      $eol = "\n" unless defined $eol;
  
      my $req_line = $self->method || "-";
      my $uri = $self->uri;
      $uri = (defined $uri) ? $uri->as_string : "-";
      $req_line .= " $uri";
      my $proto = $self->protocol;
      $req_line .= " $proto" if $proto;
  
      return join($eol, $req_line, $self->SUPER::as_string(@_));
  }
  
  sub dump
  {
      my $self = shift;
      my @pre = ($self->method || "-", $self->uri || "-");
      if (my $prot = $self->protocol) {
  	push(@pre, $prot);
      }
  
      return $self->SUPER::dump(
          preheader => join(" ", @pre),
  	@_,
      );
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Request - HTTP style request message
  
  =head1 SYNOPSIS
  
   require HTTP::Request;
   $request = HTTP::Request->new(GET => 'http://www.example.com/');
  
  and usually used like this:
  
   $ua = LWP::UserAgent->new;
   $response = $ua->request($request);
  
  =head1 DESCRIPTION
  
  C<HTTP::Request> is a class encapsulating HTTP style requests,
  consisting of a request line, some headers, and a content body. Note
  that the LWP library uses HTTP style requests even for non-HTTP
  protocols.  Instances of this class are usually passed to the
  request() method of an C<LWP::UserAgent> object.
  
  C<HTTP::Request> is a subclass of C<HTTP::Message> and therefore
  inherits its methods.  The following additional methods are available:
  
  =over 4
  
  =item $r = HTTP::Request->new( $method, $uri )
  
  =item $r = HTTP::Request->new( $method, $uri, $header )
  
  =item $r = HTTP::Request->new( $method, $uri, $header, $content )
  
  Constructs a new C<HTTP::Request> object describing a request on the
  object $uri using method $method.  The $method argument must be a
  string.  The $uri argument can be either a string, or a reference to a
  C<URI> object.  The optional $header argument should be a reference to
  an C<HTTP::Headers> object or a plain array reference of key/value
  pairs.  The optional $content argument should be a string of bytes.
  
  =item $r = HTTP::Request->parse( $str )
  
  This constructs a new request object by parsing the given string.
  
  =item $r->method
  
  =item $r->method( $val )
  
  This is used to get/set the method attribute.  The method should be a
  short string like "GET", "HEAD", "PUT" or "POST".
  
  =item $r->uri
  
  =item $r->uri( $val )
  
  This is used to get/set the uri attribute.  The $val can be a
  reference to a URI object or a plain string.  If a string is given,
  then it should be parseable as an absolute URI.
  
  =item $r->header( $field )
  
  =item $r->header( $field => $value )
  
  This is used to get/set header values and it is inherited from
  C<HTTP::Headers> via C<HTTP::Message>.  See L<HTTP::Headers> for
  details and other similar methods that can be used to access the
  headers.
  
  =item $r->accept_decodable
  
  This will set the C<Accept-Encoding> header to the list of encodings
  that decoded_content() can decode.
  
  =item $r->content
  
  =item $r->content( $bytes )
  
  This is used to get/set the content and it is inherited from the
  C<HTTP::Message> base class.  See L<HTTP::Message> for details and
  other methods that can be used to access the content.
  
  Note that the content should be a string of bytes.  Strings in perl
  can contain characters outside the range of a byte.  The C<Encode>
  module can be used to turn such strings into a string of bytes.
  
  =item $r->as_string
  
  =item $r->as_string( $eol )
  
  Method returning a textual representation of the request.
  
  =back
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>, L<HTTP::Message>, L<HTTP::Request::Common>,
  L<HTTP::Response>
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_REQUEST

$fatpacked{"HTTP/Request/Common.pm"} = <<'HTTP_REQUEST_COMMON';
  package HTTP::Request::Common;
  
  use strict;
  use vars qw(@EXPORT @EXPORT_OK $VERSION $DYNAMIC_FILE_UPLOAD);
  
  $DYNAMIC_FILE_UPLOAD ||= 0;  # make it defined (don't know why)
  
  require Exporter;
  *import = \&Exporter::import;
  @EXPORT =qw(GET HEAD PUT POST);
  @EXPORT_OK = qw($DYNAMIC_FILE_UPLOAD DELETE);
  
  require HTTP::Request;
  use Carp();
  
  $VERSION = "6.04";
  
  my $CRLF = "\015\012";   # "\r\n" is not portable
  
  sub GET  { _simple_req('GET',  @_); }
  sub HEAD { _simple_req('HEAD', @_); }
  sub PUT  { _simple_req('PUT' , @_); }
  sub DELETE { _simple_req('DELETE', @_); }
  
  sub POST
  {
      my $url = shift;
      my $req = HTTP::Request->new(POST => $url);
      my $content;
      $content = shift if @_ and ref $_[0];
      my($k, $v);
      while (($k,$v) = splice(@_, 0, 2)) {
  	if (lc($k) eq 'content') {
  	    $content = $v;
  	}
  	else {
  	    $req->push_header($k, $v);
  	}
      }
      my $ct = $req->header('Content-Type');
      unless ($ct) {
  	$ct = 'application/x-www-form-urlencoded';
      }
      elsif ($ct eq 'form-data') {
  	$ct = 'multipart/form-data';
      }
  
      if (ref $content) {
  	if ($ct =~ m,^multipart/form-data\s*(;|$),i) {
  	    require HTTP::Headers::Util;
  	    my @v = HTTP::Headers::Util::split_header_words($ct);
  	    Carp::carp("Multiple Content-Type headers") if @v > 1;
  	    @v = @{$v[0]};
  
  	    my $boundary;
  	    my $boundary_index;
  	    for (my @tmp = @v; @tmp;) {
  		my($k, $v) = splice(@tmp, 0, 2);
  		if ($k eq "boundary") {
  		    $boundary = $v;
  		    $boundary_index = @v - @tmp - 1;
  		    last;
  		}
  	    }
  
  	    ($content, $boundary) = form_data($content, $boundary, $req);
  
  	    if ($boundary_index) {
  		$v[$boundary_index] = $boundary;
  	    }
  	    else {
  		push(@v, boundary => $boundary);
  	    }
  
  	    $ct = HTTP::Headers::Util::join_header_words(@v);
  	}
  	else {
  	    # We use a temporary URI object to format
  	    # the application/x-www-form-urlencoded content.
  	    require URI;
  	    my $url = URI->new('http:');
  	    $url->query_form(ref($content) eq "HASH" ? %$content : @$content);
  	    $content = $url->query;
  
  	    # HTML/4.01 says that line breaks are represented as "CR LF" pairs (i.e., `%0D%0A')
  	    $content =~ s/(?<!%0D)%0A/%0D%0A/g if defined($content);
  	}
      }
  
      $req->header('Content-Type' => $ct);  # might be redundant
      if (defined($content)) {
  	$req->header('Content-Length' =>
  		     length($content)) unless ref($content);
  	$req->content($content);
      }
      else {
          $req->header('Content-Length' => 0);
      }
      $req;
  }
  
  
  sub _simple_req
  {
      my($method, $url) = splice(@_, 0, 2);
      my $req = HTTP::Request->new($method => $url);
      my($k, $v);
      my $content;
      while (($k,$v) = splice(@_, 0, 2)) {
  	if (lc($k) eq 'content') {
  	    $req->add_content($v);
              $content++;
  	}
  	else {
  	    $req->push_header($k, $v);
  	}
      }
      if ($content && !defined($req->header("Content-Length"))) {
          $req->header("Content-Length", length(${$req->content_ref}));
      }
      $req;
  }
  
  
  sub form_data   # RFC1867
  {
      my($data, $boundary, $req) = @_;
      my @data = ref($data) eq "HASH" ? %$data : @$data;  # copy
      my $fhparts;
      my @parts;
      my($k,$v);
      while (($k,$v) = splice(@data, 0, 2)) {
  	if (!ref($v)) {
  	    $k =~ s/([\\\"])/\\$1/g;  # escape quotes and backslashes
  	    push(@parts,
  		 qq(Content-Disposition: form-data; name="$k"$CRLF$CRLF$v));
  	}
  	else {
  	    my($file, $usename, @headers) = @$v;
  	    unless (defined $usename) {
  		$usename = $file;
  		$usename =~ s,.*/,, if defined($usename);
  	    }
              $k =~ s/([\\\"])/\\$1/g;
  	    my $disp = qq(form-data; name="$k");
              if (defined($usename) and length($usename)) {
                  $usename =~ s/([\\\"])/\\$1/g;
                  $disp .= qq(; filename="$usename");
              }
  	    my $content = "";
  	    my $h = HTTP::Headers->new(@headers);
  	    if ($file) {
  		open(my $fh, "<", $file) or Carp::croak("Can't open file $file: $!");
  		binmode($fh);
  		if ($DYNAMIC_FILE_UPLOAD) {
  		    # will read file later, close it now in order to
                      # not accumulate to many open file handles
                      close($fh);
  		    $content = \$file;
  		}
  		else {
  		    local($/) = undef; # slurp files
  		    $content = <$fh>;
  		    close($fh);
  		}
  		unless ($h->header("Content-Type")) {
  		    require LWP::MediaTypes;
  		    LWP::MediaTypes::guess_media_type($file, $h);
  		}
  	    }
  	    if ($h->header("Content-Disposition")) {
  		# just to get it sorted first
  		$disp = $h->header("Content-Disposition");
  		$h->remove_header("Content-Disposition");
  	    }
  	    if ($h->header("Content")) {
  		$content = $h->header("Content");
  		$h->remove_header("Content");
  	    }
  	    my $head = join($CRLF, "Content-Disposition: $disp",
  			           $h->as_string($CRLF),
  			           "");
  	    if (ref $content) {
  		push(@parts, [$head, $$content]);
  		$fhparts++;
  	    }
  	    else {
  		push(@parts, $head . $content);
  	    }
  	}
      }
      return ("", "none") unless @parts;
  
      my $content;
      if ($fhparts) {
  	$boundary = boundary(10) # hopefully enough randomness
  	    unless $boundary;
  
  	# add the boundaries to the @parts array
  	for (1..@parts-1) {
  	    splice(@parts, $_*2-1, 0, "$CRLF--$boundary$CRLF");
  	}
  	unshift(@parts, "--$boundary$CRLF");
  	push(@parts, "$CRLF--$boundary--$CRLF");
  
  	# See if we can generate Content-Length header
  	my $length = 0;
  	for (@parts) {
  	    if (ref $_) {
  	 	my ($head, $f) = @$_;
  		my $file_size;
  		unless ( -f $f && ($file_size = -s _) ) {
  		    # The file is either a dynamic file like /dev/audio
  		    # or perhaps a file in the /proc file system where
  		    # stat may return a 0 size even though reading it
  		    # will produce data.  So we cannot make
  		    # a Content-Length header.  
  		    undef $length;
  		    last;
  		}
  	    	$length += $file_size + length $head;
  	    }
  	    else {
  		$length += length;
  	    }
          }
          $length && $req->header('Content-Length' => $length);
  
  	# set up a closure that will return content piecemeal
  	$content = sub {
  	    for (;;) {
  		unless (@parts) {
  		    defined $length && $length != 0 &&
  		    	Carp::croak "length of data sent did not match calculated Content-Length header.  Probably because uploaded file changed in size during transfer.";
  		    return;
  		}
  		my $p = shift @parts;
  		unless (ref $p) {
  		    $p .= shift @parts while @parts && !ref($parts[0]);
  		    defined $length && ($length -= length $p);
  		    return $p;
  		}
  		my($buf, $fh) = @$p;
                  unless (ref($fh)) {
                      my $file = $fh;
                      undef($fh);
                      open($fh, "<", $file) || Carp::croak("Can't open file $file: $!");
                      binmode($fh);
                  }
  		my $buflength = length $buf;
  		my $n = read($fh, $buf, 2048, $buflength);
  		if ($n) {
  		    $buflength += $n;
  		    unshift(@parts, ["", $fh]);
  		}
  		else {
  		    close($fh);
  		}
  		if ($buflength) {
  		    defined $length && ($length -= $buflength);
  		    return $buf 
  	    	}
  	    }
  	};
  
      }
      else {
  	$boundary = boundary() unless $boundary;
  
  	my $bno = 0;
        CHECK_BOUNDARY:
  	{
  	    for (@parts) {
  		if (index($_, $boundary) >= 0) {
  		    # must have a better boundary
  		    $boundary = boundary(++$bno);
  		    redo CHECK_BOUNDARY;
  		}
  	    }
  	    last;
  	}
  	$content = "--$boundary$CRLF" .
  	           join("$CRLF--$boundary$CRLF", @parts) .
  		   "$CRLF--$boundary--$CRLF";
      }
  
      wantarray ? ($content, $boundary) : $content;
  }
  
  
  sub boundary
  {
      my $size = shift || return "xYzZY";
      require MIME::Base64;
      my $b = MIME::Base64::encode(join("", map chr(rand(256)), 1..$size*3), "");
      $b =~ s/[\W]/X/g;  # ensure alnum only
      $b;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Request::Common - Construct common HTTP::Request objects
  
  =head1 SYNOPSIS
  
    use HTTP::Request::Common;
    $ua = LWP::UserAgent->new;
    $ua->request(GET 'http://www.sn.no/');
    $ua->request(POST 'http://somewhere/foo', [foo => bar, bar => foo]);
  
  =head1 DESCRIPTION
  
  This module provide functions that return newly created C<HTTP::Request>
  objects.  These functions are usually more convenient to use than the
  standard C<HTTP::Request> constructor for the most common requests.  The
  following functions are provided:
  
  =over 4
  
  =item GET $url
  
  =item GET $url, Header => Value,...
  
  The GET() function returns an C<HTTP::Request> object initialized with
  the "GET" method and the specified URL.  It is roughly equivalent to the
  following call
  
    HTTP::Request->new(
       GET => $url,
       HTTP::Headers->new(Header => Value,...),
    )
  
  but is less cluttered.  What is different is that a header named
  C<Content> will initialize the content part of the request instead of
  setting a header field.  Note that GET requests should normally not
  have a content, so this hack makes more sense for the PUT() and POST()
  functions described below.
  
  The get(...) method of C<LWP::UserAgent> exists as a shortcut for
  $ua->request(GET ...).
  
  =item HEAD $url
  
  =item HEAD $url, Header => Value,...
  
  Like GET() but the method in the request is "HEAD".
  
  The head(...)  method of "LWP::UserAgent" exists as a shortcut for
  $ua->request(HEAD ...).
  
  =item PUT $url
  
  =item PUT $url, Header => Value,...
  
  =item PUT $url, Header => Value,..., Content => $content
  
  Like GET() but the method in the request is "PUT".
  
  The content of the request can be specified using the "Content"
  pseudo-header.  This steals a bit of the header field namespace as
  there is no way to directly specify a header that is actually called
  "Content".  If you really need this you must update the request
  returned in a separate statement.
  
  =item DELETE $url
  
  =item DELETE $url, Header => Value,...
  
  Like GET() but the method in the request is "DELETE".  This function
  is not exported by default.
  
  =item POST $url
  
  =item POST $url, Header => Value,...
  
  =item POST $url, $form_ref, Header => Value,...
  
  =item POST $url, Header => Value,..., Content => $form_ref
  
  =item POST $url, Header => Value,..., Content => $content
  
  This works mostly like PUT() with "POST" as the method, but this
  function also takes a second optional array or hash reference
  parameter $form_ref.  As for PUT() the content can also be specified
  directly using the "Content" pseudo-header, and you may also provide
  the $form_ref this way.
  
  The $form_ref argument can be used to pass key/value pairs for the
  form content.  By default we will initialize a request using the
  C<application/x-www-form-urlencoded> content type.  This means that
  you can emulate an HTML E<lt>form> POSTing like this:
  
    POST 'http://www.perl.org/survey.cgi',
         [ name   => 'Gisle Aas',
           email  => 'gisle@aas.no',
           gender => 'M',
           born   => '1964',
           perc   => '3%',
         ];
  
  This will create an HTTP::Request object that looks like this:
  
    POST http://www.perl.org/survey.cgi
    Content-Length: 66
    Content-Type: application/x-www-form-urlencoded
  
    name=Gisle%20Aas&email=gisle%40aas.no&gender=M&born=1964&perc=3%25
  
  Multivalued form fields can be specified by either repeating the field
  name or by passing the value as an array reference.
  
  The POST method also supports the C<multipart/form-data> content used
  for I<Form-based File Upload> as specified in RFC 1867.  You trigger
  this content format by specifying a content type of C<'form-data'> as
  one of the request headers.  If one of the values in the $form_ref is
  an array reference, then it is treated as a file part specification
  with the following interpretation:
  
    [ $file, $filename, Header => Value... ]
    [ undef, $filename, Header => Value,..., Content => $content ]
  
  The first value in the array ($file) is the name of a file to open.
  This file will be read and its content placed in the request.  The
  routine will croak if the file can't be opened.  Use an C<undef> as
  $file value if you want to specify the content directly with a
  C<Content> header.  The $filename is the filename to report in the
  request.  If this value is undefined, then the basename of the $file
  will be used.  You can specify an empty string as $filename if you
  want to suppress sending the filename when you provide a $file value.
  
  If a $file is provided by no C<Content-Type> header, then C<Content-Type>
  and C<Content-Encoding> will be filled in automatically with the values
  returned by LWP::MediaTypes::guess_media_type()
  
  Sending my F<~/.profile> to the survey used as example above can be
  achieved by this:
  
    POST 'http://www.perl.org/survey.cgi',
         Content_Type => 'form-data',
         Content      => [ name  => 'Gisle Aas',
                           email => 'gisle@aas.no',
                           gender => 'M',
                           born   => '1964',
                           init   => ["$ENV{HOME}/.profile"],
                         ]
  
  This will create an HTTP::Request object that almost looks this (the
  boundary and the content of your F<~/.profile> is likely to be
  different):
  
    POST http://www.perl.org/survey.cgi
    Content-Length: 388
    Content-Type: multipart/form-data; boundary="6G+f"
  
    --6G+f
    Content-Disposition: form-data; name="name"
  
    Gisle Aas
    --6G+f
    Content-Disposition: form-data; name="email"
  
    gisle@aas.no
    --6G+f
    Content-Disposition: form-data; name="gender"
  
    M
    --6G+f
    Content-Disposition: form-data; name="born"
  
    1964
    --6G+f
    Content-Disposition: form-data; name="init"; filename=".profile"
    Content-Type: text/plain
  
    PATH=/local/perl/bin:$PATH
    export PATH
  
    --6G+f--
  
  If you set the $DYNAMIC_FILE_UPLOAD variable (exportable) to some TRUE
  value, then you get back a request object with a subroutine closure as
  the content attribute.  This subroutine will read the content of any
  files on demand and return it in suitable chunks.  This allow you to
  upload arbitrary big files without using lots of memory.  You can even
  upload infinite files like F</dev/audio> if you wish; however, if
  the file is not a plain file, there will be no Content-Length header
  defined for the request.  Not all servers (or server
  applications) like this.  Also, if the file(s) change in size between
  the time the Content-Length is calculated and the time that the last
  chunk is delivered, the subroutine will C<Croak>.
  
  The post(...)  method of "LWP::UserAgent" exists as a shortcut for
  $ua->request(POST ...).
  
  =back
  
  =head1 SEE ALSO
  
  L<HTTP::Request>, L<LWP::UserAgent>
  
  
  =head1 COPYRIGHT
  
  Copyright 1997-2004, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
HTTP_REQUEST_COMMON

$fatpacked{"HTTP/Response.pm"} = <<'HTTP_RESPONSE';
  package HTTP::Response;
  
  require HTTP::Message;
  @ISA = qw(HTTP::Message);
  $VERSION = "6.04";
  
  use strict;
  use HTTP::Status ();
  
  
  
  sub new
  {
      my($class, $rc, $msg, $header, $content) = @_;
      my $self = $class->SUPER::new($header, $content);
      $self->code($rc);
      $self->message($msg);
      $self;
  }
  
  
  sub parse
  {
      my($class, $str) = @_;
      my $status_line;
      if ($str =~ s/^(.*)\n//) {
  	$status_line = $1;
      }
      else {
  	$status_line = $str;
  	$str = "";
      }
  
      my $self = $class->SUPER::parse($str);
      my($protocol, $code, $message);
      if ($status_line =~ /^\d{3} /) {
         # Looks like a response created by HTTP::Response->new
         ($code, $message) = split(' ', $status_line, 2);
      } else {
         ($protocol, $code, $message) = split(' ', $status_line, 3);
      }
      $self->protocol($protocol) if $protocol;
      $self->code($code) if defined($code);
      $self->message($message) if defined($message);
      $self;
  }
  
  
  sub clone
  {
      my $self = shift;
      my $clone = bless $self->SUPER::clone, ref($self);
      $clone->code($self->code);
      $clone->message($self->message);
      $clone->request($self->request->clone) if $self->request;
      # we don't clone previous
      $clone;
  }
  
  
  sub code      { shift->_elem('_rc',      @_); }
  sub message   { shift->_elem('_msg',     @_); }
  sub previous  { shift->_elem('_previous',@_); }
  sub request   { shift->_elem('_request', @_); }
  
  
  sub status_line
  {
      my $self = shift;
      my $code = $self->{'_rc'}  || "000";
      my $mess = $self->{'_msg'} || HTTP::Status::status_message($code) || "Unknown code";
      return "$code $mess";
  }
  
  
  sub base
  {
      my $self = shift;
      my $base = (
  	$self->header('Content-Base'),        # used to be HTTP/1.1
  	$self->header('Content-Location'),    # HTTP/1.1
  	$self->header('Base'),                # HTTP/1.0
      )[0];
      if ($base && $base =~ /^$URI::scheme_re:/o) {
  	# already absolute
  	return $HTTP::URI_CLASS->new($base);
      }
  
      my $req = $self->request;
      if ($req) {
          # if $base is undef here, the return value is effectively
          # just a copy of $self->request->uri.
          return $HTTP::URI_CLASS->new_abs($base, $req->uri);
      }
  
      # can't find an absolute base
      return undef;
  }
  
  
  sub redirects {
      my $self = shift;
      my @r;
      my $r = $self;
      while (my $p = $r->previous) {
          push(@r, $p);
          $r = $p;
      }
      return @r unless wantarray;
      return reverse @r;
  }
  
  
  sub filename
  {
      my $self = shift;
      my $file;
  
      my $cd = $self->header('Content-Disposition');
      if ($cd) {
  	require HTTP::Headers::Util;
  	if (my @cd = HTTP::Headers::Util::split_header_words($cd)) {
  	    my ($disposition, undef, %cd_param) = @{$cd[-1]};
  	    $file = $cd_param{filename};
  
  	    # RFC 2047 encoded?
  	    if ($file && $file =~ /^=\?(.+?)\?(.+?)\?(.+)\?=$/) {
  		my $charset = $1;
  		my $encoding = uc($2);
  		my $encfile = $3;
  
  		if ($encoding eq 'Q' || $encoding eq 'B') {
  		    local($SIG{__DIE__});
  		    eval {
  			if ($encoding eq 'Q') {
  			    $encfile =~ s/_/ /g;
  			    require MIME::QuotedPrint;
  			    $encfile = MIME::QuotedPrint::decode($encfile);
  			}
  			else { # $encoding eq 'B'
  			    require MIME::Base64;
  			    $encfile = MIME::Base64::decode($encfile);
  			}
  
  			require Encode;
  			require Encode::Locale;
  			Encode::from_to($encfile, $charset, "locale_fs");
  		    };
  
  		    $file = $encfile unless $@;
  		}
  	    }
  	}
      }
  
      unless (defined($file) && length($file)) {
  	my $uri;
  	if (my $cl = $self->header('Content-Location')) {
  	    $uri = URI->new($cl);
  	}
  	elsif (my $request = $self->request) {
  	    $uri = $request->uri;
  	}
  
  	if ($uri) {
  	    $file = ($uri->path_segments)[-1];
  	}
      }
  
      if ($file) {
  	$file =~ s,.*[\\/],,;  # basename
      }
  
      if ($file && !length($file)) {
  	$file = undef;
      }
  
      $file;
  }
  
  
  sub as_string
  {
      my $self = shift;
      my($eol) = @_;
      $eol = "\n" unless defined $eol;
  
      my $status_line = $self->status_line;
      my $proto = $self->protocol;
      $status_line = "$proto $status_line" if $proto;
  
      return join($eol, $status_line, $self->SUPER::as_string(@_));
  }
  
  
  sub dump
  {
      my $self = shift;
  
      my $status_line = $self->status_line;
      my $proto = $self->protocol;
      $status_line = "$proto $status_line" if $proto;
  
      return $self->SUPER::dump(
  	preheader => $status_line,
          @_,
      );
  }
  
  
  sub is_info     { HTTP::Status::is_info     (shift->{'_rc'}); }
  sub is_success  { HTTP::Status::is_success  (shift->{'_rc'}); }
  sub is_redirect { HTTP::Status::is_redirect (shift->{'_rc'}); }
  sub is_error    { HTTP::Status::is_error    (shift->{'_rc'}); }
  
  
  sub error_as_HTML
  {
      my $self = shift;
      my $title = 'An Error Occurred';
      my $body  = $self->status_line;
      $body =~ s/&/&amp;/g;
      $body =~ s/</&lt;/g;
      return <<EOM;
  <html>
  <head><title>$title</title></head>
  <body>
  <h1>$title</h1>
  <p>$body</p>
  </body>
  </html>
  EOM
  }
  
  
  sub current_age
  {
      my $self = shift;
      my $time = shift;
  
      # Implementation of RFC 2616 section 13.2.3
      # (age calculations)
      my $response_time = $self->client_date;
      my $date = $self->date;
  
      my $age = 0;
      if ($response_time && $date) {
  	$age = $response_time - $date;  # apparent_age
  	$age = 0 if $age < 0;
      }
  
      my $age_v = $self->header('Age');
      if ($age_v && $age_v > $age) {
  	$age = $age_v;   # corrected_received_age
      }
  
      if ($response_time) {
  	my $request = $self->request;
  	if ($request) {
  	    my $request_time = $request->date;
  	    if ($request_time && $request_time < $response_time) {
  		# Add response_delay to age to get 'corrected_initial_age'
  		$age += $response_time - $request_time;
  	    }
  	}
  	$age += ($time || time) - $response_time;
      }
      return $age;
  }
  
  
  sub freshness_lifetime
  {
      my($self, %opt) = @_;
  
      # First look for the Cache-Control: max-age=n header
      for my $cc ($self->header('Cache-Control')) {
  	for my $cc_dir (split(/\s*,\s*/, $cc)) {
  	    return $1 if $cc_dir =~ /^max-age\s*=\s*(\d+)/i;
  	}
      }
  
      # Next possibility is to look at the "Expires" header
      my $date = $self->date || $self->client_date || $opt{time} || time;
      if (my $expires = $self->expires) {
  	return $expires - $date;
      }
  
      # Must apply heuristic expiration
      return undef if exists $opt{heuristic_expiry} && !$opt{heuristic_expiry};
  
      # Default heuristic expiration parameters
      $opt{h_min} ||= 60;
      $opt{h_max} ||= 24 * 3600;
      $opt{h_lastmod_fraction} ||= 0.10; # 10% since last-mod suggested by RFC2616
      $opt{h_default} ||= 3600;
  
      # Should give a warning if more than 24 hours according to
      # RFC 2616 section 13.2.4.  Here we just make this the default
      # maximum value.
  
      if (my $last_modified = $self->last_modified) {
  	my $h_exp = ($date - $last_modified) * $opt{h_lastmod_fraction};
  	return $opt{h_min} if $h_exp < $opt{h_min};
  	return $opt{h_max} if $h_exp > $opt{h_max};
  	return $h_exp;
      }
  
      # default when all else fails
      return $opt{h_min} if $opt{h_min} > $opt{h_default};
      return $opt{h_default};
  }
  
  
  sub is_fresh
  {
      my($self, %opt) = @_;
      $opt{time} ||= time;
      my $f = $self->freshness_lifetime(%opt);
      return undef unless defined($f);
      return $f > $self->current_age($opt{time});
  }
  
  
  sub fresh_until
  {
      my($self, %opt) = @_;
      $opt{time} ||= time;
      my $f = $self->freshness_lifetime(%opt);
      return undef unless defined($f);
      return $f - $self->current_age($opt{time}) + $opt{time};
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Response - HTTP style response message
  
  =head1 SYNOPSIS
  
  Response objects are returned by the request() method of the C<LWP::UserAgent>:
  
      # ...
      $response = $ua->request($request)
      if ($response->is_success) {
          print $response->decoded_content;
      }
      else {
          print STDERR $response->status_line, "\n";
      }
  
  =head1 DESCRIPTION
  
  The C<HTTP::Response> class encapsulates HTTP style responses.  A
  response consists of a response line, some headers, and a content
  body. Note that the LWP library uses HTTP style responses even for
  non-HTTP protocol schemes.  Instances of this class are usually
  created and returned by the request() method of an C<LWP::UserAgent>
  object.
  
  C<HTTP::Response> is a subclass of C<HTTP::Message> and therefore
  inherits its methods.  The following additional methods are available:
  
  =over 4
  
  =item $r = HTTP::Response->new( $code )
  
  =item $r = HTTP::Response->new( $code, $msg )
  
  =item $r = HTTP::Response->new( $code, $msg, $header )
  
  =item $r = HTTP::Response->new( $code, $msg, $header, $content )
  
  Constructs a new C<HTTP::Response> object describing a response with
  response code $code and optional message $msg.  The optional $header
  argument should be a reference to an C<HTTP::Headers> object or a
  plain array reference of key/value pairs.  The optional $content
  argument should be a string of bytes.  The meanings of these arguments are
  described below.
  
  =item $r = HTTP::Response->parse( $str )
  
  This constructs a new response object by parsing the given string.
  
  =item $r->code
  
  =item $r->code( $code )
  
  This is used to get/set the code attribute.  The code is a 3 digit
  number that encode the overall outcome of an HTTP response.  The
  C<HTTP::Status> module provide constants that provide mnemonic names
  for the code attribute.
  
  =item $r->message
  
  =item $r->message( $message )
  
  This is used to get/set the message attribute.  The message is a short
  human readable single line string that explains the response code.
  
  =item $r->header( $field )
  
  =item $r->header( $field => $value )
  
  This is used to get/set header values and it is inherited from
  C<HTTP::Headers> via C<HTTP::Message>.  See L<HTTP::Headers> for
  details and other similar methods that can be used to access the
  headers.
  
  =item $r->content
  
  =item $r->content( $bytes )
  
  This is used to get/set the raw content and it is inherited from the
  C<HTTP::Message> base class.  See L<HTTP::Message> for details and
  other methods that can be used to access the content.
  
  =item $r->decoded_content( %options )
  
  This will return the content after any C<Content-Encoding> and
  charsets have been decoded.  See L<HTTP::Message> for details.
  
  =item $r->request
  
  =item $r->request( $request )
  
  This is used to get/set the request attribute.  The request attribute
  is a reference to the the request that caused this response.  It does
  not have to be the same request passed to the $ua->request() method,
  because there might have been redirects and authorization retries in
  between.
  
  =item $r->previous
  
  =item $r->previous( $response )
  
  This is used to get/set the previous attribute.  The previous
  attribute is used to link together chains of responses.  You get
  chains of responses if the first response is redirect or unauthorized.
  The value is C<undef> if this is the first response in a chain.
  
  Note that the method $r->redirects is provided as a more convenient
  way to access the response chain.
  
  =item $r->status_line
  
  Returns the string "E<lt>code> E<lt>message>".  If the message attribute
  is not set then the official name of E<lt>code> (see L<HTTP::Status>)
  is substituted.
  
  =item $r->base
  
  Returns the base URI for this response.  The return value will be a
  reference to a URI object.
  
  The base URI is obtained from one the following sources (in priority
  order):
  
  =over 4
  
  =item 1.
  
  Embedded in the document content, for instance <BASE HREF="...">
  in HTML documents.
  
  =item 2.
  
  A "Content-Base:" or a "Content-Location:" header in the response.
  
  For backwards compatibility with older HTTP implementations we will
  also look for the "Base:" header.
  
  =item 3.
  
  The URI used to request this response. This might not be the original
  URI that was passed to $ua->request() method, because we might have
  received some redirect responses first.
  
  =back
  
  If none of these sources provide an absolute URI, undef is returned.
  
  When the LWP protocol modules produce the HTTP::Response object, then
  any base URI embedded in the document (step 1) will already have
  initialized the "Content-Base:" header. This means that this method
  only performs the last 2 steps (the content is not always available
  either).
  
  =item $r->filename
  
  Returns a filename for this response.  Note that doing sanity checks
  on the returned filename (eg. removing characters that cannot be used
  on the target filesystem where the filename would be used, and
  laundering it for security purposes) are the caller's responsibility;
  the only related thing done by this method is that it makes a simple
  attempt to return a plain filename with no preceding path segments.
  
  The filename is obtained from one the following sources (in priority
  order):
  
  =over 4
  
  =item 1.
  
  A "Content-Disposition:" header in the response.  Proper decoding of
  RFC 2047 encoded filenames requires the C<MIME::QuotedPrint> (for "Q"
  encoding), C<MIME::Base64> (for "B" encoding), and C<Encode> modules.
  
  =item 2.
  
  A "Content-Location:" header in the response.
  
  =item 3.
  
  The URI used to request this response. This might not be the original
  URI that was passed to $ua->request() method, because we might have
  received some redirect responses first.
  
  =back
  
  If a filename cannot be derived from any of these sources, undef is
  returned.
  
  =item $r->as_string
  
  =item $r->as_string( $eol )
  
  Returns a textual representation of the response.
  
  =item $r->is_info
  
  =item $r->is_success
  
  =item $r->is_redirect
  
  =item $r->is_error
  
  These methods indicate if the response was informational, successful, a
  redirection, or an error.  See L<HTTP::Status> for the meaning of these.
  
  =item $r->error_as_HTML
  
  Returns a string containing a complete HTML document indicating what
  error occurred.  This method should only be called when $r->is_error
  is TRUE.
  
  =item $r->redirects
  
  Returns the list of redirect responses that lead up to this response
  by following the $r->previous chain.  The list order is oldest first.
  
  In scalar context return the number of redirect responses leading up
  to this one.
  
  =item $r->current_age
  
  Calculates the "current age" of the response as specified by RFC 2616
  section 13.2.3.  The age of a response is the time since it was sent
  by the origin server.  The returned value is a number representing the
  age in seconds.
  
  =item $r->freshness_lifetime( %opt )
  
  Calculates the "freshness lifetime" of the response as specified by
  RFC 2616 section 13.2.4.  The "freshness lifetime" is the length of
  time between the generation of a response and its expiration time.
  The returned value is the number of seconds until expiry.
  
  If the response does not contain an "Expires" or a "Cache-Control"
  header, then this function will apply some simple heuristic based on
  the "Last-Modified" header to determine a suitable lifetime.  The
  following options might be passed to control the heuristics:
  
  =over
  
  =item heuristic_expiry => $bool
  
  If passed as a FALSE value, don't apply heuristics and just return
  C<undef> when "Expires" or "Cache-Control" is lacking.
  
  =item h_lastmod_fraction => $num
  
  This number represent the fraction of the difference since the
  "Last-Modified" timestamp to make the expiry time.  The default is
  C<0.10>, the suggested typical setting of 10% in RFC 2616.
  
  =item h_min => $sec
  
  This is the lower limit of the heuristic expiry age to use.  The
  default is C<60> (1 minute).
  
  =item h_max => $sec
  
  This is the upper limit of the heuristic expiry age to use.  The
  default is C<86400> (24 hours).
  
  =item h_default => $sec
  
  This is the expiry age to use when nothing else applies.  The default
  is C<3600> (1 hour) or "h_min" if greater.
  
  =back
  
  =item $r->is_fresh( %opt )
  
  Returns TRUE if the response is fresh, based on the values of
  freshness_lifetime() and current_age().  If the response is no longer
  fresh, then it has to be re-fetched or re-validated by the origin
  server.
  
  Options might be passed to control expiry heuristics, see the
  description of freshness_lifetime().
  
  =item $r->fresh_until( %opt )
  
  Returns the time (seconds since epoch) when this entity is no longer fresh.
  
  Options might be passed to control expiry heuristics, see the
  description of freshness_lifetime().
  
  =back
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>, L<HTTP::Message>, L<HTTP::Status>, L<HTTP::Request>
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_RESPONSE

$fatpacked{"HTTP/Status.pm"} = <<'HTTP_STATUS';
  package HTTP::Status;
  
  use strict;
  require 5.002;   # because we use prototypes
  
  use vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION);
  
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(is_info is_success is_redirect is_error status_message);
  @EXPORT_OK = qw(is_client_error is_server_error);
  $VERSION = "6.03";
  
  # Note also addition of mnemonics to @EXPORT below
  
  # Unmarked codes are from RFC 2616
  # See also: http://en.wikipedia.org/wiki/List_of_HTTP_status_codes
  
  my %StatusCode = (
      100 => 'Continue',
      101 => 'Switching Protocols',
      102 => 'Processing',                      # RFC 2518 (WebDAV)
      200 => 'OK',
      201 => 'Created',
      202 => 'Accepted',
      203 => 'Non-Authoritative Information',
      204 => 'No Content',
      205 => 'Reset Content',
      206 => 'Partial Content',
      207 => 'Multi-Status',                    # RFC 2518 (WebDAV)
      208 => 'Already Reported',		      # RFC 5842
      300 => 'Multiple Choices',
      301 => 'Moved Permanently',
      302 => 'Found',
      303 => 'See Other',
      304 => 'Not Modified',
      305 => 'Use Proxy',
      307 => 'Temporary Redirect',
      400 => 'Bad Request',
      401 => 'Unauthorized',
      402 => 'Payment Required',
      403 => 'Forbidden',
      404 => 'Not Found',
      405 => 'Method Not Allowed',
      406 => 'Not Acceptable',
      407 => 'Proxy Authentication Required',
      408 => 'Request Timeout',
      409 => 'Conflict',
      410 => 'Gone',
      411 => 'Length Required',
      412 => 'Precondition Failed',
      413 => 'Request Entity Too Large',
      414 => 'Request-URI Too Large',
      415 => 'Unsupported Media Type',
      416 => 'Request Range Not Satisfiable',
      417 => 'Expectation Failed',
      418 => 'I\'m a teapot',		      # RFC 2324
      422 => 'Unprocessable Entity',            # RFC 2518 (WebDAV)
      423 => 'Locked',                          # RFC 2518 (WebDAV)
      424 => 'Failed Dependency',               # RFC 2518 (WebDAV)
      425 => 'No code',                         # WebDAV Advanced Collections
      426 => 'Upgrade Required',                # RFC 2817
      428 => 'Precondition Required',
      429 => 'Too Many Requests',
      431 => 'Request Header Fields Too Large',
      449 => 'Retry with',                      # unofficial Microsoft
      500 => 'Internal Server Error',
      501 => 'Not Implemented',
      502 => 'Bad Gateway',
      503 => 'Service Unavailable',
      504 => 'Gateway Timeout',
      505 => 'HTTP Version Not Supported',
      506 => 'Variant Also Negotiates',         # RFC 2295
      507 => 'Insufficient Storage',            # RFC 2518 (WebDAV)
      509 => 'Bandwidth Limit Exceeded',        # unofficial
      510 => 'Not Extended',                    # RFC 2774
      511 => 'Network Authentication Required',
  );
  
  my $mnemonicCode = '';
  my ($code, $message);
  while (($code, $message) = each %StatusCode) {
      # create mnemonic subroutines
      $message =~ s/I'm/I am/;
      $message =~ tr/a-z \-/A-Z__/;
      $mnemonicCode .= "sub HTTP_$message () { $code }\n";
      $mnemonicCode .= "*RC_$message = \\&HTTP_$message;\n";  # legacy
      $mnemonicCode .= "push(\@EXPORT_OK, 'HTTP_$message');\n";
      $mnemonicCode .= "push(\@EXPORT, 'RC_$message');\n";
  }
  eval $mnemonicCode; # only one eval for speed
  die if $@;
  
  # backwards compatibility
  *RC_MOVED_TEMPORARILY = \&RC_FOUND;  # 302 was renamed in the standard
  push(@EXPORT, "RC_MOVED_TEMPORARILY");
  
  %EXPORT_TAGS = (
     constants => [grep /^HTTP_/, @EXPORT_OK],
     is => [grep /^is_/, @EXPORT, @EXPORT_OK],
  );
  
  
  sub status_message  ($) { $StatusCode{$_[0]}; }
  
  sub is_info         ($) { $_[0] >= 100 && $_[0] < 200; }
  sub is_success      ($) { $_[0] >= 200 && $_[0] < 300; }
  sub is_redirect     ($) { $_[0] >= 300 && $_[0] < 400; }
  sub is_error        ($) { $_[0] >= 400 && $_[0] < 600; }
  sub is_client_error ($) { $_[0] >= 400 && $_[0] < 500; }
  sub is_server_error ($) { $_[0] >= 500 && $_[0] < 600; }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Status - HTTP Status code processing
  
  =head1 SYNOPSIS
  
   use HTTP::Status qw(:constants :is status_message);
  
   if ($rc != HTTP_OK) {
       print status_message($rc), "\n";
   }
  
   if (is_success($rc)) { ... }
   if (is_error($rc)) { ... }
   if (is_redirect($rc)) { ... }
  
  =head1 DESCRIPTION
  
  I<HTTP::Status> is a library of routines for defining and
  classifying HTTP status codes for libwww-perl.  Status codes are
  used to encode the overall outcome of an HTTP response message.  Codes
  correspond to those defined in RFC 2616 and RFC 2518.
  
  =head1 CONSTANTS
  
  The following constant functions can be used as mnemonic status code
  names.  None of these are exported by default.  Use the C<:constants>
  tag to import them all.
  
     HTTP_CONTINUE                        (100)
     HTTP_SWITCHING_PROTOCOLS             (101)
     HTTP_PROCESSING                      (102)
  
     HTTP_OK                              (200)
     HTTP_CREATED                         (201)
     HTTP_ACCEPTED                        (202)
     HTTP_NON_AUTHORITATIVE_INFORMATION   (203)
     HTTP_NO_CONTENT                      (204)
     HTTP_RESET_CONTENT                   (205)
     HTTP_PARTIAL_CONTENT                 (206)
     HTTP_MULTI_STATUS                    (207)
     HTTP_ALREADY_REPORTED		(208)
  
     HTTP_MULTIPLE_CHOICES                (300)
     HTTP_MOVED_PERMANENTLY               (301)
     HTTP_FOUND                           (302)
     HTTP_SEE_OTHER                       (303)
     HTTP_NOT_MODIFIED                    (304)
     HTTP_USE_PROXY                       (305)
     HTTP_TEMPORARY_REDIRECT              (307)
  
     HTTP_BAD_REQUEST                     (400)
     HTTP_UNAUTHORIZED                    (401)
     HTTP_PAYMENT_REQUIRED                (402)
     HTTP_FORBIDDEN                       (403)
     HTTP_NOT_FOUND                       (404)
     HTTP_METHOD_NOT_ALLOWED              (405)
     HTTP_NOT_ACCEPTABLE                  (406)
     HTTP_PROXY_AUTHENTICATION_REQUIRED   (407)
     HTTP_REQUEST_TIMEOUT                 (408)
     HTTP_CONFLICT                        (409)
     HTTP_GONE                            (410)
     HTTP_LENGTH_REQUIRED                 (411)
     HTTP_PRECONDITION_FAILED             (412)
     HTTP_REQUEST_ENTITY_TOO_LARGE        (413)
     HTTP_REQUEST_URI_TOO_LARGE           (414)
     HTTP_UNSUPPORTED_MEDIA_TYPE          (415)
     HTTP_REQUEST_RANGE_NOT_SATISFIABLE   (416)
     HTTP_EXPECTATION_FAILED              (417)
     HTTP_I_AM_A_TEAPOT			(418)
     HTTP_UNPROCESSABLE_ENTITY            (422)
     HTTP_LOCKED                          (423)
     HTTP_FAILED_DEPENDENCY               (424)
     HTTP_NO_CODE                         (425)
     HTTP_UPGRADE_REQUIRED                (426)
     HTTP_PRECONDITION_REQUIRED		(428)
     HTTP_TOO_MANY_REQUESTS		(429)
     HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE (431)
     HTTP_RETRY_WITH                      (449)
  
     HTTP_INTERNAL_SERVER_ERROR           (500)
     HTTP_NOT_IMPLEMENTED                 (501)
     HTTP_BAD_GATEWAY                     (502)
     HTTP_SERVICE_UNAVAILABLE             (503)
     HTTP_GATEWAY_TIMEOUT                 (504)
     HTTP_HTTP_VERSION_NOT_SUPPORTED      (505)
     HTTP_VARIANT_ALSO_NEGOTIATES         (506)
     HTTP_INSUFFICIENT_STORAGE            (507)
     HTTP_BANDWIDTH_LIMIT_EXCEEDED        (509)
     HTTP_NOT_EXTENDED                    (510)
     HTTP_NETWORK_AUTHENTICATION_REQUIRED (511)
  
  =head1 FUNCTIONS
  
  The following additional functions are provided.  Most of them are
  exported by default.  The C<:is> import tag can be used to import all
  the classification functions.
  
  =over 4
  
  =item status_message( $code )
  
  The status_message() function will translate status codes to human
  readable strings. The string is the same as found in the constant
  names above.  If the $code is unknown, then C<undef> is returned.
  
  =item is_info( $code )
  
  Return TRUE if C<$code> is an I<Informational> status code (1xx).  This
  class of status code indicates a provisional response which can't have
  any content.
  
  =item is_success( $code )
  
  Return TRUE if C<$code> is a I<Successful> status code (2xx).
  
  =item is_redirect( $code )
  
  Return TRUE if C<$code> is a I<Redirection> status code (3xx). This class of
  status code indicates that further action needs to be taken by the
  user agent in order to fulfill the request.
  
  =item is_error( $code )
  
  Return TRUE if C<$code> is an I<Error> status code (4xx or 5xx).  The function
  returns TRUE for both client and server error status codes.
  
  =item is_client_error( $code )
  
  Return TRUE if C<$code> is a I<Client Error> status code (4xx). This class
  of status code is intended for cases in which the client seems to have
  erred.
  
  This function is B<not> exported by default.
  
  =item is_server_error( $code )
  
  Return TRUE if C<$code> is a I<Server Error> status code (5xx). This class
  of status codes is intended for cases in which the server is aware
  that it has erred or is incapable of performing the request.
  
  This function is B<not> exported by default.
  
  =back
  
  =head1 BUGS
  
  For legacy reasons all the C<HTTP_> constants are exported by default
  with the prefix C<RC_>.  It's recommended to use explicit imports and
  the C<:constants> tag instead of relying on this.
HTTP_STATUS

$fatpacked{"IO/Socket/SSL.pm"} = <<'IO_SOCKET_SSL';
  #!/usr/bin/perl -w
  #
  # IO::Socket::SSL:
  #	 a drop-in replacement for IO::Socket::INET that encapsulates
  #	 data passed over a network with SSL.
  #
  # Current Code Shepherd: Steffen Ullrich <steffen at genua.de>
  # Code Shepherd before: Peter Behroozi, <behrooz at fas.harvard.edu>
  #
  # The original version of this module was written by
  # Marko Asplund, <marko.asplund at kronodoc.fi>, who drew from
  # Crypt::SSLeay (Net::SSL) by Gisle Aas.
  #
  
  package IO::Socket::SSL;
  
  use IO::Socket;
  use Net::SSLeay 1.21;
  use Exporter ();
  use Errno qw( EAGAIN ETIMEDOUT );
  use Carp;
  use strict;
  
  use constant {
  	SSL_VERIFY_NONE => Net::SSLeay::VERIFY_NONE(),
  	SSL_VERIFY_PEER => Net::SSLeay::VERIFY_PEER(),
  	SSL_VERIFY_FAIL_IF_NO_PEER_CERT => Net::SSLeay::VERIFY_FAIL_IF_NO_PEER_CERT(),
  	SSL_VERIFY_CLIENT_ONCE => Net::SSLeay::VERIFY_CLIENT_ONCE(),
  	# from openssl/ssl.h, should be better in Net::SSLeay
  	SSL_SENT_SHUTDOWN => 1,
  	SSL_RECEIVED_SHUTDOWN => 2,
  };
  
  
  
  # non-XS Versions of Scalar::Util will fail
  BEGIN{
  	eval { use Scalar::Util 'dualvar'; dualvar(0,'') };
  	die "You need the XS Version of Scalar::Util for dualvar() support"
  		if $@;
  }
  
  use vars qw(@ISA $VERSION $DEBUG $SSL_ERROR $GLOBAL_CONTEXT_ARGS @EXPORT );
  
  {
  	# These constants will be used in $! at return from SSL_connect,
  	# SSL_accept, generic_read and write, thus notifying the caller
  	# the usual way of problems. Like with EAGAIN, EINPROGRESS..
  	# these are especially important for non-blocking sockets
  
  	my $x = Net::SSLeay::ERROR_WANT_READ();
  	use constant SSL_WANT_READ	=> dualvar( \$x, 'SSL wants a read first' );
  	my $y = Net::SSLeay::ERROR_WANT_WRITE();
  	use constant SSL_WANT_WRITE => dualvar( \$y, 'SSL wants a write first' );
  
  	@EXPORT = qw(
  		SSL_WANT_READ SSL_WANT_WRITE SSL_VERIFY_NONE SSL_VERIFY_PEER
  		SSL_VERIFY_FAIL_IF_NO_PEER_CERT SSL_VERIFY_CLIENT_ONCE
  		$SSL_ERROR GEN_DNS GEN_IPADD
  	);
  }
  
  my @caller_force_inet4; # in case inet4 gets forced we store here who forced it
  my $can_ipv6;           # true if we successfully enabled ipv6 while loading
  
  BEGIN {
  	# Declare @ISA, $VERSION, $GLOBAL_CONTEXT_ARGS
  
  	# if we have IO::Socket::INET6 we will use this not IO::Socket::INET, because
  	# it can handle both IPv4 and IPv6. If we don't have INET6 available fall back
  	# to INET
  	if ( ! eval {
  		require Socket6;
  		Socket6->import( 'inet_pton' );
  		require IO::Socket::INET6;
  		@ISA = qw(IO::Socket::INET6);
  		$can_ipv6 = 1;
  	}) {
  		@ISA = qw(IO::Socket::INET);
  	}
  	$VERSION = '1.38';
  	$GLOBAL_CONTEXT_ARGS = {};
  
  	#Make $DEBUG another name for $Net::SSLeay::trace
  	*DEBUG = \$Net::SSLeay::trace;
  
  	#Compability
  	*ERROR = \$SSL_ERROR;
  
  	# Do Net::SSLeay initialization
  	Net::SSLeay::load_error_strings();
  	Net::SSLeay::SSLeay_add_ssl_algorithms();
  	Net::SSLeay::randomize();
  }
  
  sub DEBUG {
  	$DEBUG>=shift or return; # check against debug level
  	my (undef,$file,$line) = caller;
  	my $msg = shift;
  	$file = '...'.substr( $file,-17 ) if length($file)>20;
  	$msg = sprintf $msg,@_ if @_;
  	print STDERR "DEBUG: $file:$line: $msg\n";
  }
  
  BEGIN {
  	# import some constants from Net::SSLeay or use hard-coded defaults
  	# if Net::SSLeay isn't recent enough to provide the constants
  	my %const = (
  		NID_CommonName => 13,
  		GEN_DNS => 2,
  		GEN_IPADD => 7,
  	);
  	while ( my ($name,$value) = each %const ) {
  		no strict 'refs';
  		*{$name} = UNIVERSAL::can( 'Net::SSLeay', $name ) || sub { $value };
  	}
  
  	# check if we have something to handle IDN
  	local $SIG{__DIE__}; local $SIG{__WARN__}; # be silent
  	if ( eval { require Net::IDN::Encode }) {
  		*{idn_to_ascii} = \&Net::IDN::Encode::domain_to_ascii;
  	} elsif ( eval { require Net::LibIDN }) {
  		*{idn_to_ascii} = \&Net::LibIDN::idn_to_ascii;
  	} else {
  		# default: croak if we really got an unencoded international domain
  		*{idn_to_ascii} = sub {
  			my $domain = shift;
  			return $domain if $domain =~m{^[a-zA-Z0-9-_\.]+$};
  			croak "cannot handle international domains, please install Net::LibIDN or Net::IDN::Encode"
  		}
  	}
  }
  
  # Export some stuff
  # inet4|inet6|debug will be handeled by myself, everything
  # else will be handeld the Exporter way
  sub import {
  	my $class = shift;
  
  	my @export;
  	foreach (@_) {
  		if ( /^inet4$/i ) {
  			# explicitly fall back to inet4
  			@ISA = 'IO::Socket::INET';
  			@caller_force_inet4 = caller(); # save for warnings for 'inet6' case
  		} elsif ( /^inet6$/i ) {
  			# check if we have already ipv6 as base
  			if ( ! UNIVERSAL::isa( $class, 'IO::Socket::INET6' )) {
  				# either we don't support it or we disabled it by explicitly
  				# loading it with 'inet4'. In this case re-enable but warn
  				# because this is probably an error
  				if ( $can_ipv6 ) {
  					@ISA = 'IO::Socket::INET6';
  					warn "IPv6 support re-enabled in __PACKAGE__, got disabled in file $caller_force_inet4[1] line $caller_force_inet4[2]";
  				} else {
  					die "INET6 is not supported, missing Socket6 or IO::Socket::INET6";
  				}
  			}
  		} elsif ( /^:?debug(\d+)/ ) {
  			$DEBUG=$1;
  		} else {
  			push @export,$_
  		}
  	}
  
  	@_ = ( $class,@export );
  	goto &Exporter::import;
  }
  
  # You might be expecting to find a new() subroutine here, but that is
  # not how IO::Socket::INET works.  All configuration gets performed in
  # the calls to configure() and either connect() or accept().
  
  #Call to configure occurs when a new socket is made using
  #IO::Socket::INET.	Returns false (empty list) on failure.
  sub configure {
  	my ($self, $arg_hash) = @_;
  	return _invalid_object() unless($self);
  
  	# work around Bug in IO::Socket::INET6 where it doesn't use the
  	# right family for the socket on BSD systems:
  	# http://rt.cpan.org/Ticket/Display.html?id=39550
  	if ( $can_ipv6 && ! $arg_hash->{Domain} &&
  		! ( $arg_hash->{LocalAddr} || $arg_hash->{LocalHost} ) &&
  		(my $peer = $arg_hash->{PeerAddr} || $arg_hash->{PeerHost})) {
  		# set Domain to AF_INET/AF_INET6 if there is only one choice
  		($peer, my $port) = IO::Socket::INET6::_sock_info( $peer,$arg_hash->{PeerPort},6 );
  		my @res = Socket6::getaddrinfo( $peer,$port,AF_UNSPEC,SOCK_STREAM );
  		if (@res == 5) {
  			$arg_hash->{Domain} = $res[0];
  			DEBUG(2,'set domain to '.$res[0] );
  		}
  	}
  
  	# force initial blocking
  	# otherwise IO::Socket::SSL->new might return undef if the
  	# socket is nonblocking and it fails to connect immediatly
  	# for real nonblocking behavior one should create a nonblocking
  	# socket and later call connect explicitly
  	my $blocking = delete $arg_hash->{Blocking};
  
  	# because Net::HTTPS simple redefines blocking() to {} (e.g
  	# return undef) and IO::Socket::INET does not like this we
  
  	# set Blocking only explicitly if it was set
  	$arg_hash->{Blocking} = 1 if defined ($blocking);
  
  	$self->configure_SSL($arg_hash) || return;
  
  	$self->SUPER::configure($arg_hash)
  		|| return $self->error("@ISA configuration failed");
  
  	$self->blocking(0) if defined $blocking && !$blocking;
  	return $self;
  }
  
  sub configure_SSL {
  	my ($self, $arg_hash) = @_;
  
  	my $is_server = $arg_hash->{'SSL_server'} || $arg_hash->{'Listen'} || 0;
  
  	my %default_args = (
  		Proto => 'tcp',
  		SSL_server => $is_server,
  		SSL_use_cert => $is_server,
  		SSL_check_crl => 0,
  		SSL_version	=> 'sslv23',
  		SSL_verify_mode => SSL_VERIFY_NONE,
  		SSL_verify_callback => undef,
  		SSL_verifycn_scheme => undef,  # don't verify cn
  		SSL_verifycn_name => undef,    # use from PeerAddr/PeerHost
  	);
  
  	# common problem forgetting SSL_use_cert
  	# if client cert is given but SSL_use_cert undef assume that it
  	# should be set
  	if ( ! $is_server && ! defined $arg_hash->{SSL_use_cert}
  		&& ( grep { $arg_hash->{$_} } qw(SSL_cert SSL_cert_file))
  		&& ( grep { $arg_hash->{$_} } qw(SSL_key SSL_key_file)) ) {
  		$arg_hash->{SSL_use_cert} = 1
  	}
  
  	# SSL_key_file and SSL_cert_file will only be set in defaults if
  	# SSL_key|SSL_key_file resp SSL_cert|SSL_cert_file are not set in
  	# $args_hash
  	foreach my $k (qw( key cert )) {
  		next if exists $arg_hash->{ "SSL_${k}" };
  		next if exists $arg_hash->{ "SSL_${k}_file" };
  		$default_args{ "SSL_${k}_file" } = $is_server
  			?  "certs/server-${k}.pem"
  			:  "certs/client-${k}.pem";
  	}
  
  	# add only SSL_ca_* if not in args
  	if ( ! exists $arg_hash->{SSL_ca_file} && ! exists $arg_hash->{SSL_ca_path} ) {
  		if ( -f 'certs/my-ca.pem' ) {
  			$default_args{SSL_ca_file} = 'certs/my-ca.pem'
  		} elsif ( -d 'ca/' ) {
  			$default_args{SSL_ca_path} = 'ca/'
  		}
  	}
  
  	#Replace nonexistent entries with defaults
  	%$arg_hash = ( %default_args, %$GLOBAL_CONTEXT_ARGS, %$arg_hash );
  
  	#Avoid passing undef arguments to Net::SSLeay
  	defined($arg_hash->{$_}) or delete($arg_hash->{$_}) foreach (keys %$arg_hash);
  
  	my $vcn_scheme = delete $arg_hash->{SSL_verifycn_scheme};
  	if ( $vcn_scheme && $vcn_scheme ne 'none' ) {
  		# don't access ${*self} inside callback - this seems to create
  		# circular references from the ssl object to the context and back
  
  		# use SSL_verifycn_name or determine from PeerAddr
  		my $host = $arg_hash->{SSL_verifycn_name};
  		if (not defined($host)) {
  			if ( $host = $arg_hash->{PeerAddr} || $arg_hash->{PeerHost} ) {
  				$host =~s{:[a-zA-Z0-9_\-]+$}{};
  			}
  		}
  		$host ||= ref($vcn_scheme) && $vcn_scheme->{callback} && 'unknown';
  		$host or return $self->error( "Cannot determine peer hostname for verification" );
  
  		my $vcb = $arg_hash->{SSL_verify_callback};
  		$arg_hash->{SSL_verify_callback} = sub {
  			my ($ok,$ctx_store,$certname,$error,$cert) = @_;
  			$ok = $vcb->($ok,$ctx_store,$certname,$error,$cert) if $vcb;
  			$ok or return;
  			my $depth = Net::SSLeay::X509_STORE_CTX_get_error_depth($ctx_store);
  			return $ok if $depth != 0;
  
  			# verify name
  			my $rv = verify_hostname_of_cert( $host,$cert,$vcn_scheme );
  			# just do some code here against optimization because x509 has no
  			# increased reference and CRYPTO_add is not available from Net::SSLeay
  			return $rv;
  		};
  	}
  
  	${*$self}{'_SSL_arguments'} = $arg_hash;
  	${*$self}{'_SSL_ctx'} = IO::Socket::SSL::SSL_Context->new($arg_hash) || return;
  	${*$self}{'_SSL_opened'} = 1 if $is_server;
  
  	return $self;
  }
  
  
  sub _set_rw_error {
  	my ($self,$ssl,$rv) = @_;
  	my $err = Net::SSLeay::get_error($ssl,$rv);
  	$SSL_ERROR =
  		$err == Net::SSLeay::ERROR_WANT_READ()	? SSL_WANT_READ :
  		$err == Net::SSLeay::ERROR_WANT_WRITE() ? SSL_WANT_WRITE :
  		return;
  	$! ||= EAGAIN;
  	${*$self}{'_SSL_last_err'} = $SSL_ERROR if ref($self);
  	return 1;
  }
  
  
  #Call to connect occurs when a new client socket is made using
  #IO::Socket::INET
  sub connect {
  	my $self = shift || return _invalid_object();
  	return $self if ${*$self}{'_SSL_opened'};  # already connected
  
  	if ( ! ${*$self}{'_SSL_opening'} ) {
  		# call SUPER::connect if the underlying socket is not connected
  		# if this fails this might not be an error (e.g. if $! = EINPROGRESS
  		# and socket is nonblocking this is normal), so keep any error
  		# handling to the client
  		DEBUG(2, 'socket not yet connected' );
  		$self->SUPER::connect(@_) || return;
  		DEBUG(2,'socket connected' );
  	}
  	return $self->connect_SSL;
  }
  
  
  sub connect_SSL {
  	my $self = shift;
  	my $args = @_>1 ? {@_}: $_[0]||{};
  
  	my ($ssl,$ctx);
  	if ( ! ${*$self}{'_SSL_opening'} ) {
  		# start ssl connection
  		DEBUG(2,'ssl handshake not started' );
  		${*$self}{'_SSL_opening'} = 1;
  		my $arg_hash = ${*$self}{'_SSL_arguments'};
  
  		my $fileno = ${*$self}{'_SSL_fileno'} = fileno($self);
  		return $self->error("Socket has no fileno") unless (defined $fileno);
  
  		$ctx = ${*$self}{'_SSL_ctx'};  # Reference to real context
  		$ssl = ${*$self}{'_SSL_object'} = Net::SSLeay::new($ctx->{context})
  			|| return $self->error("SSL structure creation failed");
  
  		Net::SSLeay::set_fd($ssl, $fileno)
  			|| return $self->error("SSL filehandle association failed");
  
  		if ( my $cl = $arg_hash->{SSL_cipher_list} ) {
  			Net::SSLeay::set_cipher_list($ssl, $cl )
  				|| return $self->error("Failed to set SSL cipher list");
  		}
  
  		$arg_hash->{PeerAddr} || $self->_update_peer;
  		my $session = $ctx->session_cache( $arg_hash->{PeerAddr}, $arg_hash->{PeerPort} );
  		Net::SSLeay::set_session($ssl, $session) if ($session);
  	}
  
  	$ssl ||= ${*$self}{'_SSL_object'};
  
  	$SSL_ERROR = undef;
  	my $timeout = exists $args->{Timeout}
  		? $args->{Timeout}
  		: ${*$self}{io_socket_timeout}; # from IO::Socket
  	if ( defined($timeout) && $timeout>0 && $self->blocking(0) ) {
  		DEBUG(2, "set socket to non-blocking to enforce timeout=$timeout" );
  		# timeout was given and socket was blocking
  		# enforce timeout with now non-blocking socket
  	} else {
  		# timeout does not apply because invalid or socket non-blocking
  		$timeout = undef;
  	}
  
  	my $start = defined($timeout) && time();
  	for my $dummy (1) {
  		#DEBUG( 'calling ssleay::connect' );
  		my $rv = Net::SSLeay::connect($ssl);
  		DEBUG( 3,"Net::SSLeay::connect -> $rv" );
  		if ( $rv < 0 ) {
  			unless ( $self->_set_rw_error( $ssl,$rv )) {
  				$self->error("SSL connect attempt failed with unknown error");
  				delete ${*$self}{'_SSL_opening'};
  				${*$self}{'_SSL_opened'} = -1;
  				DEBUG(1, "fatal SSL error: $SSL_ERROR" );
  				return $self->fatal_ssl_error();
  			}
  
  			DEBUG(2,'ssl handshake in progress' );
  			# connect failed because handshake needs to be completed
  			# if socket was non-blocking or no timeout was given return with this error
  			return if ! defined($timeout);
  
  			# wait until socket is readable or writable
  			my $rv;
  			if ( $timeout>0 ) {
  				my $vec = '';
  				vec($vec,$self->fileno,1) = 1;
  				DEBUG(2, "waiting for fd to become ready: $SSL_ERROR" );
  				$rv =
  					$SSL_ERROR == SSL_WANT_READ ? select( $vec,undef,undef,$timeout) :
  					$SSL_ERROR == SSL_WANT_WRITE ? select( undef,$vec,undef,$timeout) :
  					undef;
  			} else {
  				DEBUG(2,"handshake failed because no more time" );
  				$! = ETIMEDOUT
  			}
  			if ( ! $rv ) {
  				DEBUG(2,"handshake failed because socket did not became ready" );
  				# failed because of timeout, return
  				$! ||= ETIMEDOUT;
  				delete ${*$self}{'_SSL_opening'};
  				${*$self}{'_SSL_opened'} = -1;
  				$self->blocking(1); # was blocking before
  				return
  			}
  
  			# socket is ready, try non-blocking connect again after recomputing timeout
  			DEBUG(2,"socket ready, retrying connect" );
  			my $now = time();
  			$timeout -= $now - $start;
  			$start = $now;
  			redo;
  
  		} elsif ( $rv == 0 ) {
  			delete ${*$self}{'_SSL_opening'};
  			DEBUG(2,"connection failed - connect returned 0" );
  			$self->error("SSL connect attempt failed because of handshake problems" );
  			${*$self}{'_SSL_opened'} = -1;
  			return $self->fatal_ssl_error();
  		}
  	}
  
  	DEBUG(2,'ssl handshake done' );
  	# ssl connect successful
  	delete ${*$self}{'_SSL_opening'};
  	${*$self}{'_SSL_opened'}=1;
  	$self->blocking(1) if defined($timeout); # was blocking before
  
  	$ctx ||= ${*$self}{'_SSL_ctx'};
  	if ( $ctx->has_session_cache ) {
  		my $arg_hash = ${*$self}{'_SSL_arguments'};
  		$arg_hash->{PeerAddr} || $self->_update_peer;
  		my ($addr,$port) = ( $arg_hash->{PeerAddr}, $arg_hash->{PeerPort} );
  		my $session = $ctx->session_cache( $addr,$port );
  		$ctx->session_cache( $addr,$port, Net::SSLeay::get1_session($ssl) ) if !$session;
  	}
  
  	tie *{$self}, "IO::Socket::SSL::SSL_HANDLE", $self;
  
  	return $self;
  }
  
  # called if PeerAddr is not set in ${*$self}{'_SSL_arguments'}
  # this can be the case if start_SSL is called with a normal IO::Socket::INET
  # so that PeerAddr|PeerPort are not set from args
  sub _update_peer {
  	my $self = shift;
  	my $arg_hash = ${*$self}{'_SSL_arguments'};
  	eval {
  		my ($port,$addr) = sockaddr_in( getpeername( $self ));
  		$arg_hash->{PeerAddr} = inet_ntoa( $addr );
  		$arg_hash->{PeerPort} = $port;
  	}
  }
  
  #Call to accept occurs when a new client connects to a server using
  #IO::Socket::SSL
  sub accept {
  	my $self = shift || return _invalid_object();
  	my $class = shift || 'IO::Socket::SSL';
  
  	my $socket = ${*$self}{'_SSL_opening'};
  	if ( ! $socket ) {
  		# underlying socket not done
  		DEBUG(2,'no socket yet' );
  		$socket = $self->SUPER::accept($class) || return;
  		DEBUG(2,'accept created normal socket '.$socket );
  	}
  
  	$self->accept_SSL($socket) || return;
  	DEBUG(2,'accept_SSL ok' );
  
  	return wantarray ? ($socket, getpeername($socket) ) : $socket;
  }
  
  sub accept_SSL {
  	my $self = shift;
  	my $socket = ( @_ && UNIVERSAL::isa( $_[0], 'IO::Handle' )) ? shift : $self;
  	my $args = @_>1 ? {@_}: $_[0]||{};
  
  	my $ssl;
  	if ( ! ${*$self}{'_SSL_opening'} ) {
  		DEBUG(2,'starting sslifying' );
  		${*$self}{'_SSL_opening'} = $socket;
  		my $arg_hash = ${*$self}{'_SSL_arguments'};
  		${*$socket}{'_SSL_arguments'} = { %$arg_hash, SSL_server => 0 };
  		my $ctx = ${*$socket}{'_SSL_ctx'} = ${*$self}{'_SSL_ctx'};
  
  		my $fileno = ${*$socket}{'_SSL_fileno'} = fileno($socket);
  		return $socket->error("Socket has no fileno") unless (defined $fileno);
  
  		$ssl = ${*$socket}{'_SSL_object'} = Net::SSLeay::new($ctx->{context})
  			|| return $socket->error("SSL structure creation failed");
  
  		Net::SSLeay::set_fd($ssl, $fileno)
  			|| return $socket->error("SSL filehandle association failed");
  
  		if ( my $cl = $arg_hash->{SSL_cipher_list} ) {
  			Net::SSLeay::set_cipher_list($ssl, $cl )
  				|| return $socket->error("Failed to set SSL cipher list");
  		}
  	}
  
  	$ssl ||= ${*$socket}{'_SSL_object'};
  
  	$SSL_ERROR = undef;
  	#DEBUG(2,'calling ssleay::accept' );
  
  	my $timeout = exists $args->{Timeout}
  		? $args->{Timeout}
  		: ${*$self}{io_socket_timeout}; # from IO::Socket
  	if ( defined($timeout) && $timeout>0 && $socket->blocking(0) ) {
  		# timeout was given and socket was blocking
  		# enforce timeout with now non-blocking socket
  	} else {
  		# timeout does not apply because invalid or socket non-blocking
  		$timeout = undef;
  	}
  
  	my $start = defined($timeout) && time();
  	for my $dummy (1) {
  		my $rv = Net::SSLeay::accept($ssl);
  		DEBUG(3, "Net::SSLeay::accept -> $rv" );
  		if ( $rv < 0 ) {
  			unless ( $socket->_set_rw_error( $ssl,$rv )) {
  				$socket->error("SSL accept attempt failed with unknown error");
  				delete ${*$self}{'_SSL_opening'};
  				${*$socket}{'_SSL_opened'} = -1;
  				return $socket->fatal_ssl_error();
  			}
  
  			# accept failed because handshake needs to be completed
  			# if socket was non-blocking or no timeout was given return with this error
  			return if ! defined($timeout);
  
  			# wait until socket is readable or writable
  			my $rv;
  			if ( $timeout>0 ) {
  				my $vec = '';
  				vec($vec,$socket->fileno,1) = 1;
  				$rv =
  					$SSL_ERROR == SSL_WANT_READ ? select( $vec,undef,undef,$timeout) :
  					$SSL_ERROR == SSL_WANT_WRITE ? select( undef,$vec,undef,$timeout) :
  					undef;
  			} else {
  				$! = ETIMEDOUT
  			}
  			if ( ! $rv ) {
  				# failed because of timeout, return
  				$! ||= ETIMEDOUT;
  				delete ${*$self}{'_SSL_opening'};
  				${*$socket}{'_SSL_opened'} = -1;
  				$socket->blocking(1); # was blocking before
  				return
  			}
  
  			# socket is ready, try non-blocking accept again after recomputing timeout
  			my $now = time();
  			$timeout -= $now - $start;
  			$start = $now;
  			redo;
  
  		} elsif ( $rv == 0 ) {
  			$socket->error("SSL connect accept failed because of handshake problems" );
  			delete ${*$self}{'_SSL_opening'};
  			${*$socket}{'_SSL_opened'} = -1;
  			return $socket->fatal_ssl_error();
  		}
  	}
  
  	DEBUG(2,'handshake done, socket ready' );
  	# socket opened
  	delete ${*$self}{'_SSL_opening'};
  	${*$socket}{'_SSL_opened'} = 1;
  	$socket->blocking(1) if defined($timeout); # was blocking before
  
  	tie *{$socket}, "IO::Socket::SSL::SSL_HANDLE", $socket;
  
  	return $socket;
  }
  
  
  ####### I/O subroutines ########################
  
  sub generic_read {
  	my ($self, $read_func, undef, $length, $offset) = @_;
  	my $ssl = $self->_get_ssl_object || return;
  	my $buffer=\$_[2];
  
  	$SSL_ERROR = undef;
  	my $data = $read_func->($ssl, $length);
  	if ( !defined($data)) {
  		$self->_set_rw_error( $ssl,-1 ) || $self->error("SSL read error");
  		return;
  	}
  
  	$length = length($data);
  	$$buffer = '' if !defined $$buffer;
  	$offset ||= 0;
  	if ($offset>length($$buffer)) {
  		$$buffer.="\0" x ($offset-length($$buffer));  #mimic behavior of read
  	}
  
  	substr($$buffer, $offset, length($$buffer), $data);
  	return $length;
  }
  
  sub read {
  	my $self = shift;
  	return $self->generic_read(
  		$self->blocking ? \&Net::SSLeay::ssl_read_all : \&Net::SSLeay::read,
  		@_
  	);
  }
  
  # contrary to the behavior of read sysread can read partial data
  sub sysread {
  	my $self = shift;
  	return $self->generic_read( \&Net::SSLeay::read, @_ );
  }
  
  sub peek {
  	my $self = shift;
  	if (Net::SSLeay::OPENSSL_VERSION_NUMBER() >= 0x0090601f) {
  		return $self->generic_read(\&Net::SSLeay::peek, @_);
  	} else {
  		return $self->error("SSL_peek not supported for OpenSSL < v0.9.6a");
  	}
  }
  
  
  sub generic_write {
  	my ($self, $write_all, undef, $length, $offset) = @_;
  
  	my $ssl = $self->_get_ssl_object || return;
  	my $buffer = \$_[2];
  
  	my $buf_len = length($$buffer);
  	$length ||= $buf_len;
  	$offset ||= 0;
  	return $self->error("Invalid offset for SSL write") if ($offset>$buf_len);
  	return 0 if ($offset == $buf_len);
  
  	$SSL_ERROR = undef;
  	my $written;
  	if ( $write_all ) {
  		my $data = $length < $buf_len-$offset ? substr($$buffer, $offset, $length) : $$buffer;
  		($written, my $errs) = Net::SSLeay::ssl_write_all($ssl, $data);
  		# ssl_write_all returns number of bytes written
  		$written = undef if ! $written && $errs;
  	} else {
  		$written = Net::SSLeay::write_partial( $ssl,$offset,$length,$$buffer );
  		# write_partial does SSL_write which returns -1 on error
  		$written = undef if $written < 0;
  	}
  	if ( !defined($written) ) {
  		$self->_set_rw_error( $ssl,-1 )
  			|| $self->error("SSL write error");
  		return;
  	}
  
  	return $written;
  }
  
  # if socket is blocking write() should return only on error or
  # if all data are written
  sub write {
  	my $self = shift;
  	return $self->generic_write( scalar($self->blocking),@_ );
  }
  
  # contrary to write syswrite() returns already if only
  # a part of the data is written
  sub syswrite {
  	my $self = shift;
  	return $self->generic_write( 0,@_ );
  }
  
  sub print {
  	my $self = shift;
  	my $string = join(($, or ''), @_, ($\ or ''));
  	return $self->write( $string );
  }
  
  sub printf {
  	my ($self,$format) = (shift,shift);
  	return $self->write(sprintf($format, @_));
  }
  
  sub getc {
  	my ($self, $buffer) = (shift, undef);
  	return $buffer if $self->read($buffer, 1, 0);
  }
  
  sub readline {
  	my $self = shift;
  	my $ssl = $self->_get_ssl_object || return;
  
  	if (wantarray) {
  		my ($buf,$err) = Net::SSLeay::ssl_read_all($ssl);
  		return $self->error( "SSL read error" ) if $err;
  		if ( !defined($/) ) {
  			return $buf;
  		} elsif ( ref($/) ) {
  			my $size = ${$/};
  			die "bad value in ref \$/: $size" unless $size>0;
  			return $buf=~m{\G(.{1,$size})}g;
  		} elsif ( $/ eq '' ) {
  			return $buf =~m{\G(.*\n\n+|.+)}g;
  		} else {
  			return $buf =~m{\G(.*$/|.+)}g;
  		}
  	}
  
  	if ( !defined($/) ) {
  		my ($buf,$err) = Net::SSLeay::ssl_read_all($ssl);
  		return $self->error( "SSL read error" ) if $err;
  		return $buf;
  	} elsif ( ref($/) ) {
  		my $size = ${$/};
  		die "bad value in ref \$/: $size" unless $size>0;
  		my ($buf,$err) = Net::SSLeay::ssl_read_all($ssl,$size);
  		return $self->error( "SSL read error" ) if $err;
  		return $buf;
  	} elsif ( $/ ne '' ) {
  		my $line = Net::SSLeay::ssl_read_until($ssl,$/);
  		return $self->error( "SSL read error" ) if $line eq '';
  		return $line;
  	} else {
  		# $/ is ''
  		# ^.*?\n\n+, need peek to find all \n at the end
  		die "empty \$/ is not supported if I don't have peek"
  			if Net::SSLeay::OPENSSL_VERSION_NUMBER() < 0x0090601f;
  
  		# find first occurence of \n\n
  		my $buf = '';
  		my $eon = 0;
  		while (1) {
  			defined( Net::SSLeay::peek($ssl,1)) || last; # peek more, can block
  			my $pending = Net::SSLeay::pending($ssl);
  			$buf .= Net::SSLeay::peek( $ssl,$pending );	 # will not block
  			if ( !$eon ) {
  				my $pos = index( $buf,"\n\n");
  				next if $pos<0; # newlines not found
  				$eon = $pos+2;	# pos after second newline
  			}
  			# $eon >= 2	 == bytes incl last known \n
  			while ( index( $buf,"\n",$eon ) == $eon ) {
  				# the next char ist \n too
  				$eon++;
  			}
  			last if $eon < length($buf); # found last \n before end of buf
  		}
  		if ( $eon > 0 ) {
  			# found something
  			# readed peeked data until $eon from $ssl
  			return Net::SSLeay::ssl_read_all( $ssl,$eon );
  		} else {
  			# found nothing
  			# return all what we have
  			if ( my $l = length($buf)) {
  				return Net::SSLeay::ssl_read_all( $ssl,$l );
  			} else {
  				return $self->error( "SSL read error" );
  			}
  		}
  	}
  }
  
  sub close {
  	my $self = shift || return _invalid_object();
  	my $close_args = (ref($_[0]) eq 'HASH') ? $_[0] : {@_};
  
  	return if ! $self->stop_SSL(
  		SSL_fast_shutdown => 1,
  		%$close_args,
  		_SSL_ioclass_downgrade => 0,
  	);
  
  	if ( ! $close_args->{_SSL_in_DESTROY} ) {
  		untie( *$self );
  		return $self->SUPER::close;
  	}
  	return 1;
  }
  
  sub stop_SSL {
  	my $self = shift || return _invalid_object();
  	my $stop_args = (ref($_[0]) eq 'HASH') ? $_[0] : {@_};
  	$stop_args->{SSL_no_shutdown} = 1 if ! ${*$self}{_SSL_opened};
  
  	if (my $ssl = ${*$self}{'_SSL_object'}) {
  		my $shutdown_done;
  		if ( $stop_args->{SSL_no_shutdown} ) {
  			$shutdown_done = 1;
  		} else {
  			my $fast = $stop_args->{SSL_fast_shutdown};
  			my $status = Net::SSLeay::get_shutdown($ssl);
  			if ( $status == SSL_RECEIVED_SHUTDOWN
  				|| ( $status != 0 && $fast )) {
  				# shutdown done
  				$shutdown_done = 1;
  			} else {
  				# need to initiate/continue shutdown
  				local $SIG{PIPE} = sub{};
  				for my $try (1,2 ) {
  					my $rv = Net::SSLeay::shutdown($ssl);
  					if ( $rv < 0 ) {
  						# non-blocking socket?
  						$self->_set_rw_error( $ssl,$rv );
  						# need to try again
  						return;
  					} elsif ( $rv
  						|| ( $rv == 0 && $fast )) {
  						# shutdown finished
  						$shutdown_done = 1;
  						last;
  					} else {
  						# shutdown partly finished (e.g. one direction)
  						# call again
  					}
  				}
  			}
  		}
  
  		return if ! $shutdown_done;
  		Net::SSLeay::free($ssl);
  		delete ${*$self}{_SSL_object};
  	}
  
  	if ($stop_args->{'SSL_ctx_free'}) {
  		my $ctx = delete ${*$self}{'_SSL_ctx'};
  		$ctx && $ctx->DESTROY();
  	}
  
  	if (my $cert = delete ${*$self}{'_SSL_certificate'}) {
  		Net::SSLeay::X509_free($cert);
  	}
  
  	${*$self}{'_SSL_opened'} = 0;
  
  	if ( ! $stop_args->{_SSL_in_DESTROY} ) {
  
  		my $downgrade = $stop_args->{_SSL_ioclass_downgrade};
  		if ( $downgrade || ! defined $downgrade ) {
  			# rebless to original class from start_SSL
  			if ( my $orig_class = delete ${*$self}{'_SSL_ioclass_upgraded'} ) {
  				bless $self,$orig_class;
  				untie(*$self);
  				# FIXME: if original class was tied too we need to restore the tie
  			}
  			# remove all _SSL related from *$self
  			my @sslkeys = grep { m{^_?SSL_} } keys %{*$self};
  			delete @{*$self}{@sslkeys} if @sslkeys;
  		}
  	}
  	return 1;
  }
  
  
  sub fileno {
  	my $self = shift;
  	my $fn = ${*$self}{'_SSL_fileno'};
  		return defined($fn) ? $fn : $self->SUPER::fileno();
  }
  
  
  ####### IO::Socket::SSL specific functions #######
  # _get_ssl_object is for internal use ONLY!
  sub _get_ssl_object {
  	my $self = shift;
  	my $ssl = ${*$self}{'_SSL_object'};
  	return IO::Socket::SSL->error("Undefined SSL object") unless($ssl);
  	return $ssl;
  }
  
  # default error for undefined arguments
  sub _invalid_object {
  	return IO::Socket::SSL->error("Undefined IO::Socket::SSL object");
  }
  
  
  sub pending {
  	my $ssl = shift()->_get_ssl_object || return;
  	return Net::SSLeay::pending($ssl);
  }
  
  sub start_SSL {
  	my ($class,$socket) = (shift,shift);
  	return $class->error("Not a socket") unless(ref($socket));
  	my $arg_hash = (ref($_[0]) eq 'HASH') ? $_[0] : {@_};
  	my %to = exists $arg_hash->{Timeout} ? ( Timeout => delete $arg_hash->{Timeout} ) :();
  	my $original_class = ref($socket);
  	my $original_fileno = (UNIVERSAL::can($socket, "fileno"))
  		? $socket->fileno : CORE::fileno($socket);
  	return $class->error("Socket has no fileno") unless defined $original_fileno;
  
  	bless $socket, $class;
  	$socket->configure_SSL($arg_hash) or bless($socket, $original_class) && return;
  
  	${*$socket}{'_SSL_fileno'} = $original_fileno;
  	${*$socket}{'_SSL_ioclass_upgraded'} = $original_class;
  
  	my $start_handshake = $arg_hash->{SSL_startHandshake};
  	if ( ! defined($start_handshake) || $start_handshake ) {
  		# if we have no callback force blocking mode
  		DEBUG(2, "start handshake" );
  		my $blocking = $socket->blocking(1);
  		my $result = ${*$socket}{'_SSL_arguments'}{SSL_server}
  			? $socket->accept_SSL(%to)
  			: $socket->connect_SSL(%to);
  		$socket->blocking(0) if !$blocking;
  		return $result ? $socket : (bless($socket, $original_class) && ());
  	} else {
  		DEBUG(2, "dont start handshake: $socket" );
  		return $socket; # just return upgraded socket
  	}
  
  }
  
  sub new_from_fd {
  	my ($class, $fd) = (shift,shift);
  	# Check for accidental inclusion of MODE in the argument list
  	if (length($_[0]) < 4) {
  		(my $mode = $_[0]) =~ tr/+<>//d;
  		shift unless length($mode);
  	}
  	my $handle = $ISA[0]->new_from_fd($fd, '+<')
  		|| return($class->error("Could not create socket from file descriptor."));
  
  	# Annoying workaround for Perl 5.6.1 and below:
  	$handle = $ISA[0]->new_from_fd($handle, '+<');
  
  	return $class->start_SSL($handle, @_);
  }
  
  
  sub dump_peer_certificate {
  	my $ssl = shift()->_get_ssl_object || return;
  	return Net::SSLeay::dump_peer_certificate($ssl);
  }
  
  {
  	my %dispatcher = (
  		issuer =>  sub { Net::SSLeay::X509_NAME_oneline( Net::SSLeay::X509_get_issuer_name( shift )) },
  		subject => sub { Net::SSLeay::X509_NAME_oneline( Net::SSLeay::X509_get_subject_name( shift )) },
  	);
  	if ( $Net::SSLeay::VERSION >= 1.30 ) {
  		# I think X509_NAME_get_text_by_NID got added in 1.30
  		$dispatcher{commonName} = sub {
  			my $cn = Net::SSLeay::X509_NAME_get_text_by_NID(
  				Net::SSLeay::X509_get_subject_name( shift ), NID_CommonName);
  			$cn =~s{\0$}{}; # work around Bug in Net::SSLeay <1.33
  			$cn;
  		}
  	} else {
  		$dispatcher{commonName} = sub {
  			croak "you need at least Net::SSLeay version 1.30 for getting commonName"
  		}
  	}
  
  	if ( $Net::SSLeay::VERSION >= 1.33 ) {
  		# X509_get_subjectAltNames did not really work before
  		$dispatcher{subjectAltNames} = sub { Net::SSLeay::X509_get_subjectAltNames( shift ) };
  	} else {
  		$dispatcher{subjectAltNames} = sub {
  			croak "you need at least Net::SSLeay version 1.33 for getting subjectAltNames"
  		};
  	}
  
  	# alternative names
  	$dispatcher{authority} = $dispatcher{issuer};
  	$dispatcher{owner}     = $dispatcher{subject};
  	$dispatcher{cn}	       = $dispatcher{commonName};
  
  	sub peer_certificate {
  		my ($self, $field) = @_;
  		my $ssl = $self->_get_ssl_object or return;
  
  		my $cert = ${*$self}{_SSL_certificate}
  			||= Net::SSLeay::get_peer_certificate($ssl)
  			or return $self->error("Could not retrieve peer certificate");
  
  		if ($field) {
  			my $sub = $dispatcher{$field} or croak
  				"invalid argument for peer_certificate, valid are: ".join( " ",keys %dispatcher ).
  				"\nMaybe you need to upgrade your Net::SSLeay";
  			return $sub->($cert);
  		} else {
  			return $cert
  		}
  	}
  
  	# known schemes, possible attributes are:
  	#  - wildcards_in_alt (0, 'leftmost', 'anywhere')
  	#  - wildcards_in_cn (0, 'leftmost', 'anywhere')
  	#  - check_cn (0, 'always', 'when_only')
  
  	my %scheme = (
  		# rfc 4513
  		ldap => {
  			wildcards_in_cn	 => 0,
  			wildcards_in_alt => 'leftmost',
  			check_cn         => 'always',
  		},
  		# rfc 2818
  		http => {
  			wildcards_in_cn	 => 'anywhere',
  			wildcards_in_alt => 'anywhere',
  			check_cn         => 'when_only',
  		},
  		# rfc 3207
  		# This is just a dumb guess
  		# RFC3207 itself just says, that the client should expect the
  		# domain name of the server in the certificate. It doesn't say
  		# anything about wildcards, so I forbid them. It doesn't say
  		# anything about alt names, but other documents show, that alt
  		# names should be possible. The check_cn value again is a guess.
  		# Fix the spec!
  		smtp => {
  			wildcards_in_cn	 => 0,
  			wildcards_in_alt => 0,
  			check_cn         => 'always'
  		},
  		none => {}, # do not check
  	);
  
  	$scheme{www}  = $scheme{http}; # alias
  	$scheme{xmpp} = $scheme{http}; # rfc 3920
  	$scheme{pop3} = $scheme{ldap}; # rfc 2595
  	$scheme{imap} = $scheme{ldap}; # rfc 2595
  	$scheme{acap} = $scheme{ldap}; # rfc 2595
  	$scheme{nntp} = $scheme{ldap}; # rfc 4642
  	$scheme{ftp}  = $scheme{http}; # rfc 4217
  
  	# function to verify the hostname
  	#
  	# as every application protocol has its own rules to do this
  	# we provide some default rules as well as a user-defined
  	# callback
  
  	sub verify_hostname_of_cert {
  		my $identity = shift;
  		my $cert = shift;
  		my $scheme = shift || 'none';
  		if ( ! ref($scheme) ) {
  			DEBUG(3, "scheme=$scheme cert=$cert" );
  			$scheme = $scheme{$scheme} or croak "scheme $scheme not defined";
  		}
  
  		# get data from certificate
  		my $commonName = $dispatcher{cn}->($cert);
  		my @altNames = $dispatcher{subjectAltNames}->($cert);
  		DEBUG(3,"identity=$identity cn=$commonName alt=@altNames" );
  
  		if ( my $sub = $scheme->{callback} ) {
  			# use custom callback
  			return $sub->($identity,$commonName,@altNames);
  		}
  
  		# is the given hostname an IP address? Then we have to convert to network byte order [RFC791][RFC2460]
  
  		my $ipn;
  		if ( $identity =~m{:} ) {
  			# no IPv4 or hostname have ':'	in it, try IPv6.
  			#  make sure that Socket6 was loaded properly
  			UNIVERSAL::can( __PACKAGE__, 'inet_pton' ) or croak
  				q[Looks like IPv6 address, make sure that Socket6 is loaded or make "use IO::Socket::SSL 'inet6'];
  			$ipn = inet_pton( $identity ) or croak "'$identity' is not IPv6, but neither IPv4 nor hostname";
  		} elsif ( $identity =~m{^\d+\.\d+\.\d+\.\d+$} ) {
  			 # definitly no hostname, try IPv4
  			$ipn = inet_aton( $identity ) or croak "'$identity' is not IPv4, but neither IPv6 nor hostname";
  		} else {
  			# assume hostname, check for umlauts etc
  			if ( $identity =~m{[^a-zA-Z0-9_.\-]} ) {
  				$identity =~m{\0} and croak("name '$identity' has \\0 byte");
  				$identity = idn_to_ascii($identity) or
  					croak "Warning: Given name '$identity' could not be converted to IDNA!";
  			}
  		}
  
  		# do the actual verification
  		my $check_name = sub {
  			my ($name,$identity,$wtyp) = @_;
  			$wtyp ||= '';
  			my $pattern;
  			### IMPORTANT!
  			# we accept only a single wildcard and only for a single part of the FQDN
  			# e.g *.example.org does match www.example.org but not bla.www.example.org
  			# The RFCs are in this regard unspecific but we don't want to have to
  			# deal with certificates like *.com, *.co.uk or even *
  			# see also http://nils.toedtmann.net/pub/subjectAltName.txt
  			if ( $wtyp eq 'anywhere' and $name =~m{^([a-zA-Z0-9_\-]*)\*(.+)} ) {
  				$pattern = qr{^\Q$1\E[a-zA-Z0-9_\-]*\Q$2\E$}i;
  			} elsif ( $wtyp eq 'leftmost' and $name =~m{^\*(\..+)$} ) {
  				$pattern = qr{^[a-zA-Z0-9_\-]*\Q$1\E$}i;
  			} else {
  				$pattern = qr{^\Q$name\E$}i;
  			}
  			return $identity =~ $pattern;
  		};
  
  		my $alt_dnsNames = 0;
  		while (@altNames) {
  			my ($type, $name) = splice (@altNames, 0, 2);
  			if ( $ipn and $type == GEN_IPADD ) {
  				# exakt match needed for IP
  				# $name is already packed format (inet_xton)
  				return 1 if $ipn eq $name;
  
  			} elsif ( ! $ipn and $type == GEN_DNS ) {
  				$name =~s/\s+$//; $name =~s/^\s+//;
  				$alt_dnsNames++;
  				$check_name->($name,$identity,$scheme->{wildcards_in_alt})
  					and return 1;
  			}
  		}
  
  		if ( ! $ipn and (
  			$scheme->{check_cn} eq 'always' or
  			$scheme->{check_cn} eq 'when_only' and !$alt_dnsNames)) {
  			$check_name->($commonName,$identity,$scheme->{wildcards_in_cn})
  				and return 1;
  		}
  
  		return 0; # no match
  	}
  }
  
  sub verify_hostname {
  	my $self = shift;
  	my $host = shift;
  	my $cert = $self->peer_certificate;
  	return verify_hostname_of_cert( $host,$cert,@_ );
  }
  
  
  sub get_cipher {
  	my $ssl = shift()->_get_ssl_object || return;
  	return Net::SSLeay::get_cipher($ssl);
  }
  
  sub errstr {
  	my $self = shift;
  	return ((ref($self) ? ${*$self}{'_SSL_last_err'} : $SSL_ERROR) or '');
  }
  
  sub fatal_ssl_error {
  	my $self = shift;
  	my $error_trap = ${*$self}{'_SSL_arguments'}->{'SSL_error_trap'};
  	$@ = $self->errstr;
  	if (defined $error_trap and ref($error_trap) eq 'CODE') {
  		$error_trap->($self, $self->errstr()."\n".$self->get_ssleay_error());
  	} elsif ( ${*$self}{'_SSL_ioclass_upgraded'} ) {
  		# downgrade only
  		$self->stop_SSL;
  	} else {
  		# kill socket
  		$self->close
  	}
  	return;
  }
  
  sub get_ssleay_error {
  	#Net::SSLeay will print out the errors itself unless we explicitly
  	#undefine $Net::SSLeay::trace while running print_errs()
  	local $Net::SSLeay::trace;
  	return Net::SSLeay::print_errs('SSL error: ') || '';
  }
  
  sub error {
  	my ($self, $error, $destroy_socket) = @_;
  	$error .= Net::SSLeay::ERR_error_string(Net::SSLeay::ERR_get_error());
  	DEBUG(2, $error."\n".$self->get_ssleay_error());
  	$SSL_ERROR = dualvar( -1, $error );
  	${*$self}{'_SSL_last_err'} = $SSL_ERROR if (ref($self));
  	return;
  }
  
  
  sub DESTROY {
  	my $self = shift || return;
  	$self->close(_SSL_in_DESTROY => 1, SSL_no_shutdown => 1)
  		if ${*$self}{'_SSL_opened'};
  	delete(${*$self}{'_SSL_ctx'});
  }
  
  
  #######Extra Backwards Compatibility Functionality#######
  sub socket_to_SSL { IO::Socket::SSL->start_SSL(@_); }
  sub socketToSSL { IO::Socket::SSL->start_SSL(@_); }
  sub kill_socket { shift->close }
  
  sub issuer_name { return(shift()->peer_certificate("issuer")) }
  sub subject_name { return(shift()->peer_certificate("subject")) }
  sub get_peer_certificate { return shift() }
  
  sub context_init {
  	return($GLOBAL_CONTEXT_ARGS = (ref($_[0]) eq 'HASH') ? $_[0] : {@_});
  }
  
  sub set_default_context {
  	$GLOBAL_CONTEXT_ARGS->{'SSL_reuse_ctx'} = shift;
  }
  
  sub set_default_session_cache {
  	$GLOBAL_CONTEXT_ARGS->{SSL_session_cache} = shift;
  }
  
  sub set_ctx_defaults {
  	my %args = @_;
  	while ( my ($k,$v) = each %args ) {
  		$k =~s{^(SSL_)?}{SSL_};
  		$GLOBAL_CONTEXT_ARGS->{$k} = $v;
  	}
  }
  
  
  sub opened {
  	my $self = shift;
  	return IO::Handle::opened($self) && ${*$self}{'_SSL_opened'};
  }
  
  sub opening {
  	my $self = shift;
  	return ${*$self}{'_SSL_opening'};
  }
  
  sub want_read  { shift->errstr == SSL_WANT_READ }
  sub want_write { shift->errstr == SSL_WANT_WRITE }
  
  
  #Redundant IO::Handle functionality
  sub getline { return(scalar shift->readline()) }
  sub getlines {
  	return(shift->readline()) if wantarray();
  	croak("Use of getlines() not allowed in scalar context");
  }
  
  #Useless IO::Handle functionality
  sub truncate { croak("Use of truncate() not allowed with SSL") }
  sub stat     { croak("Use of stat() not allowed with SSL" ) }
  sub setbuf   { croak("Use of setbuf() not allowed with SSL" ) }
  sub setvbuf  { croak("Use of setvbuf() not allowed with SSL" ) }
  sub fdopen   { croak("Use of fdopen() not allowed with SSL" ) }
  
  #Unsupported socket functionality
  sub ungetc { croak("Use of ungetc() not implemented in IO::Socket::SSL") }
  sub send   { croak("Use of send() not implemented in IO::Socket::SSL; use print/printf/syswrite instead") }
  sub recv   { croak("Use of recv() not implemented in IO::Socket::SSL; use read/sysread instead") }
  
  package IO::Socket::SSL::SSL_HANDLE;
  use strict;
  use vars qw($HAVE_WEAKREF);
  use Errno 'EBADF';
  
  BEGIN {
  	local ($@, $SIG{__DIE__});
  
  	#Use Scalar::Util or WeakRef if possible:
  	eval "use Scalar::Util qw(weaken isweak); 1" or
  		eval "use WeakRef";
  	$HAVE_WEAKREF = $@ ? 0 : 1;
  }
  
  
  sub TIEHANDLE {
  	my ($class, $handle) = @_;
  	weaken($handle) if $HAVE_WEAKREF;
  	bless \$handle, $class;
  }
  
  sub READ     { ${shift()}->sysread(@_) }
  sub READLINE { ${shift()}->readline(@_) }
  sub GETC     { ${shift()}->getc(@_) }
  
  sub PRINT    { ${shift()}->print(@_) }
  sub PRINTF   { ${shift()}->printf(@_) }
  sub WRITE    { ${shift()}->syswrite(@_) }
  
  sub FILENO   { ${shift()}->fileno(@_) }
  
  sub TELL     { $! = EBADF; return -1 }
  sub BINMODE  { return 0 }  # not perfect, but better than not implementing the method
  
  sub CLOSE {							 #<---- Do not change this function!
  	my $ssl = ${$_[0]};
  	local @_;
  	$ssl->close();
  }
  
  
  package IO::Socket::SSL::SSL_Context;
  use Carp;
  use strict;
  
  my %CTX_CREATED_IN_THIS_THREAD;
  *DEBUG = *IO::Socket::SSL::DEBUG;
  
  # should be better taken from Net::SSLeay, but they are not (yet) defined there
  use constant SSL_MODE_ENABLE_PARTIAL_WRITE => 1;
  use constant SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER => 2;
  
  
  # Note that the final object will actually be a reference to the scalar
  # (C-style pointer) returned by Net::SSLeay::CTX_*_new() so that
  # it can be blessed.
  sub new {
  	my $class = shift;
  	#DEBUG( "$class @_" );
  	my $arg_hash = (ref($_[0]) eq 'HASH') ? $_[0] : {@_};
  
  	my $ctx_object = $arg_hash->{'SSL_reuse_ctx'};
  	if ($ctx_object) {
  		return $ctx_object if ($ctx_object->isa('IO::Socket::SSL::SSL_Context') and
  			$ctx_object->{context});
  
  		# The following "double entendre" applies only if someone passed
  		# in an IO::Socket::SSL object instead of an actual context.
  		return $ctx_object if ($ctx_object = ${*$ctx_object}{'_SSL_ctx'});
  	}
  
  	my $ctx;
  	foreach ($arg_hash->{'SSL_version'}) {
  		$ctx = /^sslv2$/i ? Net::SSLeay::CTX_v2_new()	 :
  			   /^sslv3$/i ? Net::SSLeay::CTX_v3_new()	 :
  			   /^tlsv1$/i ? Net::SSLeay::CTX_tlsv1_new() :
  							Net::SSLeay::CTX_new();
  	}
  
  	$ctx || return IO::Socket::SSL->error("SSL Context init failed");
  
  	Net::SSLeay::CTX_set_options($ctx, Net::SSLeay::OP_ALL());
  
  	# SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER makes syswrite return if at least one
  	# buffer was written and not block for the rest
  	# SSL_MODE_ENABLE_PARTIAL_WRITE can be necessary for non-blocking because we
  	# cannot guarantee, that the location of the buffer stays constant
  	Net::SSLeay::CTX_set_mode( $ctx,
  		SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER|SSL_MODE_ENABLE_PARTIAL_WRITE);
  
  
  	my $verify_mode = $arg_hash->{SSL_verify_mode};
  	if ( $verify_mode != Net::SSLeay::VERIFY_NONE() and
  	    ( defined $arg_hash->{SSL_ca_file} || defined $arg_hash->{SSL_ca_path}) and
  		! Net::SSLeay::CTX_load_verify_locations(
  			$ctx, $arg_hash->{SSL_ca_file} || '',$arg_hash->{SSL_ca_path} || '') ) {
  		return IO::Socket::SSL->error("Invalid certificate authority locations");
  	}
  
  	if ($arg_hash->{'SSL_check_crl'}) {
  		if (Net::SSLeay::OPENSSL_VERSION_NUMBER() >= 0x0090702f) {
  		    Net::SSLeay::X509_STORE_set_flags(
  			Net::SSLeay::CTX_get_cert_store($ctx),
  			Net::SSLeay::X509_V_FLAG_CRL_CHECK()
  		      );
  		    if ($arg_hash->{'SSL_crl_file'}) {
  			my $bio = Net::SSLeay::BIO_new_file($arg_hash->{'SSL_crl_file'}, 'r');
  			my $crl = Net::SSLeay::PEM_read_bio_X509_CRL($bio);
  			if ( $crl ) {
  			    Net::SSLeay::X509_STORE_add_crl(Net::SSLeay::CTX_get_cert_store($ctx), $crl);
  			} else {
  			    return IO::Socket::SSL->error("Invalid certificate revocation list");
  			}
  		    }
  		} else {
  			return IO::Socket::SSL->error("CRL not supported for OpenSSL < v0.9.7b");
  		}
  	}
  
  	if ($arg_hash->{'SSL_server'} || $arg_hash->{'SSL_use_cert'}) {
  		my $filetype = Net::SSLeay::FILETYPE_PEM();
  
  		if ($arg_hash->{'SSL_passwd_cb'}) {
  			Net::SSLeay::CTX_set_default_passwd_cb($ctx, $arg_hash->{'SSL_passwd_cb'});
  		}
  
  		if ( my $pkey= $arg_hash->{SSL_key} ) {
  			# binary, e.g. EVP_PKEY*
  			Net::SSLeay::CTX_use_PrivateKey($ctx, $pkey)
  				|| return IO::Socket::SSL->error("Failed to use Private Key");
  		} elsif ( my $f = $arg_hash->{SSL_key_file} ) {
  			Net::SSLeay::CTX_use_PrivateKey_file($ctx, $f, $filetype)
  				|| return IO::Socket::SSL->error("Failed to open Private Key");
  		}
  
  		if ( my $x509 = $arg_hash->{SSL_cert} ) {
  			# binary, e.g. X509*
  			# we habe either a single certificate or a list with
  			# a chain of certificates
  			my @x509 = ref($x509) eq 'ARRAY' ? @$x509: ($x509);
  			my $cert = shift @x509;
  			Net::SSLeay::CTX_use_certificate( $ctx,$cert )
  				|| return IO::Socket::SSL->error("Failed to use Certificate");
  			foreach my $ca (@x509) {
  				Net::SSLeay::CTX_add_extra_chain_cert( $ctx,$ca )
  					|| return IO::Socket::SSL->error("Failed to use Certificate");
  			}
  		} elsif ( my $f = $arg_hash->{SSL_cert_file} ) {
  			Net::SSLeay::CTX_use_certificate_chain_file($ctx, $f)
  				|| return IO::Socket::SSL->error("Failed to open Certificate");
  		}
  
  		if ( my $dh = $arg_hash->{SSL_dh} ) {
  			# binary, e.g. DH*
  			Net::SSLeay::CTX_set_tmp_dh( $ctx,$dh )
  				|| return IO::Socket::SSL->error( "Failed to set DH from SSL_dh" );
  		} elsif ( my $f = $arg_hash->{SSL_dh_file} ) {
  			my $bio = Net::SSLeay::BIO_new_file( $f,'r' )
  				|| return IO::Socket::SSL->error( "Failed to open DH file $f" );
  			my $dh = Net::SSLeay::PEM_read_bio_DHparams($bio);
  			Net::SSLeay::BIO_free($bio);
  			$dh || return IO::Socket::SSL->error( "Failed to read PEM for DH from $f - wrong format?" );
  			my $rv = Net::SSLeay::CTX_set_tmp_dh( $ctx,$dh );
  			Net::SSLeay::DH_free( $dh );
  			$rv || return IO::Socket::SSL->error( "Failed to set DH from $f" );
  		}
  	}
  
  	my $verify_cb = $arg_hash->{SSL_verify_callback};
  	my $verify_callback = $verify_cb && sub {
  		my ($ok, $ctx_store) = @_;
  		my ($certname,$cert,$error);
  		if ($ctx_store) {
  			$cert = Net::SSLeay::X509_STORE_CTX_get_current_cert($ctx_store);
  			$error = Net::SSLeay::X509_STORE_CTX_get_error($ctx_store);
  			$certname = Net::SSLeay::X509_NAME_oneline(Net::SSLeay::X509_get_issuer_name($cert)).
  				Net::SSLeay::X509_NAME_oneline(Net::SSLeay::X509_get_subject_name($cert));
  			$error &&= Net::SSLeay::ERR_error_string($error);
  		}
  		DEBUG(3, "ok=$ok cert=$cert" );
  		return $verify_cb->($ok,$ctx_store,$certname,$error,$cert);
  	};
  
  	Net::SSLeay::CTX_set_verify($ctx, $verify_mode, $verify_callback);
  
  	$ctx_object = { context => $ctx };
  	$ctx_object->{has_verifycb} = 1 if $verify_callback;
  	DEBUG(3, "new ctx $ctx" );
  	$CTX_CREATED_IN_THIS_THREAD{$ctx} = 1;
  
  	if ( my $cache = $arg_hash->{SSL_session_cache} ) {
  		# use predefined cache
  		$ctx_object->{session_cache} = $cache
  	} elsif ( my $size = $arg_hash->{SSL_session_cache_size}) {
  		return IO::Socket::SSL->error("Session caches not supported for Net::SSLeay < v1.26")
  			if $Net::SSLeay::VERSION < 1.26;
  		$ctx_object->{session_cache} = IO::Socket::SSL::Session_Cache->new( $size );
  	}
  
  	return bless $ctx_object, $class;
  }
  
  
  sub session_cache {
  	my $ctx = shift;
  	my $cache = $ctx->{'session_cache'} || return;
  	my ($addr,$port,$session) = @_;
  	$port ||= $addr =~s{:(\w+)$}{} && $1; # host:port
  	my $key = "$addr:$port";
  	return defined($session)
  		? $cache->add_session($key, $session)
  		: $cache->get_session($key);
  }
  
  sub has_session_cache {
  	return defined shift->{session_cache};
  }
  
  
  sub CLONE { %CTX_CREATED_IN_THIS_THREAD = (); }
  sub DESTROY {
  	my $self = shift;
  	if ( my $ctx = $self->{context} ) {
  		DEBUG( 3,"free ctx $ctx open=".join( " ",keys %CTX_CREATED_IN_THIS_THREAD ));
  		if ( %CTX_CREATED_IN_THIS_THREAD and
  			delete $CTX_CREATED_IN_THIS_THREAD{$ctx} ) {
  			# remove any verify callback for this context
  			if ( $self->{has_verifycb}) {
  				DEBUG( 3,"free ctx $ctx callback" );
  				Net::SSLeay::CTX_set_verify($ctx, 0,undef);
  			}
  			DEBUG( 3,"OK free ctx $ctx" );
  			Net::SSLeay::CTX_free($ctx);
  		}
  	}
  	delete(@{$self}{'context','session_cache'});
  }
  
  package IO::Socket::SSL::Session_Cache;
  use strict;
  
  sub new {
  	my ($class, $size) = @_;
  	$size>0 or return;
  	return bless { _maxsize => $size }, $class;
  }
  
  
  sub get_session {
  	my ($self, $key) = @_;
  	my $session = $self->{$key} || return;
  	return $session->{session} if ($self->{'_head'} eq $session);
  	$session->{prev}->{next} = $session->{next};
  	$session->{next}->{prev} = $session->{prev};
  	$session->{next} = $self->{'_head'};
  	$session->{prev} = $self->{'_head'}->{prev};
  	$self->{'_head'}->{prev} = $self->{'_head'}->{prev}->{next} = $session;
  	$self->{'_head'} = $session;
  	return $session->{session};
  }
  
  sub add_session {
  	my ($self, $key, $val) = @_;
  	return if ($key eq '_maxsize' or $key eq '_head');
  
  	if ((keys %$self) > $self->{'_maxsize'} + 1) {
  		my $last = $self->{'_head'}->{prev};
  		Net::SSLeay::SESSION_free($last->{session});
  		delete($self->{$last->{key}});
  		$self->{'_head'}->{prev} = $self->{'_head'}->{prev}->{prev};
  		delete($self->{'_head'}) if ($self->{'_maxsize'} == 1);
  	}
  
  	my $session = $self->{$key} = { session => $val, key => $key };
  
  	if ($self->{'_head'}) {
  		$session->{next} = $self->{'_head'};
  		$session->{prev} = $self->{'_head'}->{prev};
  		$self->{'_head'}->{prev}->{next} = $session;
  		$self->{'_head'}->{prev} = $session;
  	} else {
  		$session->{next} = $session->{prev} = $session;
  	}
  	$self->{'_head'} = $session;
  	return $session;
  }
  
  sub DESTROY {
  	my $self = shift;
  	delete(@{$self}{'_head','_maxsize'});
  	foreach my $key (keys %$self) {
  		Net::SSLeay::SESSION_free($self->{$key}->{session});
  	}
  }
  
  
  1;
  
  
  =head1 NAME
  
  IO::Socket::SSL -- Nearly transparent SSL encapsulation for IO::Socket::INET.
  
  =head1 SYNOPSIS
  
  	use strict;
  	use IO::Socket::SSL;
  
  	my $client = IO::Socket::SSL->new("www.example.com:https")
  		|| warn "I encountered a problem: ".IO::Socket::SSL::errstr();
  	$client->verify_hostname( 'www.example.com','http' )
  		|| die "hostname verification failed";
  
  	print $client "GET / HTTP/1.0\r\n\r\n";
  	print <$client>;
  
  
  =head1 DESCRIPTION
  
  This module is a true drop-in replacement for IO::Socket::INET that uses
  SSL to encrypt data before it is transferred to a remote server or
  client.	 IO::Socket::SSL supports all the extra features that one needs
  to write a full-featured SSL client or server application: multiple SSL contexts,
  cipher selection, certificate verification, and SSL version selection.	As an
  extra bonus, it works perfectly with mod_perl.
  
  If you have never used SSL before, you should read the appendix labelled 'Using SSL'
  before attempting to use this module.
  
  If you have used this module before, read on, as versions 0.93 and above
  have several changes from the previous IO::Socket::SSL versions (especially
  see the note about return values).
  
  If you are using non-blocking sockets read on, as version 0.98 added better
  support for non-blocking.
  
  If you are trying to use it with threads see the BUGS section.
  
  =head1 METHODS
  
  IO::Socket::SSL inherits its methods from IO::Socket::INET, overriding them
  as necessary.  If there is an SSL error, the method or operation will return an
  empty list (false in all contexts).	 The methods that have changed from the
  perspective of the user are re-documented here:
  
  =over 4
  
  =item B<new(...)>
  
  Creates a new IO::Socket::SSL object.  You may use all the friendly options
  that came bundled with IO::Socket::INET, plus (optionally) the ones that follow:
  
  =over 2
  
  =item SSL_version
  
  Sets the version of the SSL protocol used to transmit data.	 The default is SSLv2/3,
  which auto-negotiates between SSLv2 and SSLv3.	You may specify 'SSLv2', 'SSLv3', or
  'TLSv1' (case-insensitive) if you do not want this behavior.
  
  =item SSL_cipher_list
  
  If this option is set the cipher list for the connection will be set to the
  given value, e.g. something like 'ALL:!LOW:!EXP:!ADH'. Look into the OpenSSL
  documentation (L<http://www.openssl.org/docs/apps/ciphers.html#CIPHER_STRINGS>)
  for more details.
  If this option is not used the openssl builtin default is used which is suitable
  for most cases.
  
  =item SSL_use_cert
  
  If this is set, it forces IO::Socket::SSL to use a certificate and key, even if
  you are setting up an SSL client.  If this is set to 0 (the default), then you will
  only need a certificate and key if you are setting up a server.
  
  SSL_use_cert will implicitly be set if SSL_server is set.
  For convinience it is also set if it was not given but a cert was given for use
  (SSL_cert_file or similar).
  
  =item SSL_server
  
  Use this, if the socket should be used as a server.
  If this is not explicitly set it is assumed, if Listen with given when creating
  the socket.
  
  =item SSL_key_file
  
  If your RSA private key is not in default place (F<certs/server-key.pem> for servers,
  F<certs/client-key.pem> for clients), then this is the option that you would use to
  specify a different location.  Keys should be PEM formatted, and if they are
  encrypted, you will be prompted to enter a password before the socket is formed
  (unless you specified the SSL_passwd_cb option).
  
  =item SSL_key
  
  This is an EVP_PKEY* and can be used instead of SSL_key_file.
  Useful if you don't have your key in a file but create it dynamically or get it from
  a string (see openssl PEM_read_bio_PrivateKey etc for getting a EVP_PKEY* from
  a string).
  
  =item SSL_cert_file
  
  If your SSL certificate is not in the default place (F<certs/server-cert.pem> for servers,
  F<certs/client-cert.pem> for clients), then you should use this option to specify the
  location of your certificate.  Note that a key and certificate are only required for an
  SSL server, so you do not need to bother with these trifling options should you be
  setting up an unauthenticated client.
  
  =item SSL_cert
  
  This is an X509* or an array of X509*.
  The first X509* is the internal representation of the certificate while the following
  ones are extra certificates. Useful if you create your certificate dynamically (like
  in a SSL intercepting proxy) or get it from a string (see openssl PEM_read_bio_X509 etc
  for getting a X509* from a string).
  
  =item SSL_dh_file
  
  If you want Diffie-Hellman key exchange you need to supply a suitable file here
  or use the SSL_dh parameter. See dhparam command in openssl for more information.
  
  =item SSL_dh
  
  Like SSL_dh_file, but instead of giving a file you use a preloaded or generated DH*.
  
  =item SSL_passwd_cb
  
  If your private key is encrypted, you might not want the default password prompt from
  Net::SSLeay.  This option takes a reference to a subroutine that should return the
  password required to decrypt your private key.
  
  =item SSL_ca_file
  
  If you want to verify that the peer certificate has been signed by a reputable
  certificate authority, then you should use this option to locate the file
  containing the certificateZ<>(s) of the reputable certificate authorities if it is
  not already in the file F<certs/my-ca.pem>.
  If you definitly want no SSL_ca_file used you should set it to undef.
  
  =item SSL_ca_path
  
  If you are unusually friendly with the OpenSSL documentation, you might have set
  yourself up a directory containing several trusted certificates as separate files
  as well as an index of the certificates.  If you want to use that directory for
  validation purposes, and that directory is not F<ca/>, then use this option to
  point IO::Socket::SSL to the right place to look.
  If you definitly want no SSL_ca_path used you should set it to undef.
  
  =item SSL_verify_mode
  
  This option sets the verification mode for the peer certificate.  The default
  (0x00) does no authentication.	You may combine 0x01 (verify peer), 0x02 (fail
  verification if no peer certificate exists; ignored for clients), and 0x04
  (verify client once) to change the default.
  
  See OpenSSL man page for SSL_CTX_set_verify for more information.
  
  =item SSL_verify_callback
  
  If you want to verify certificates yourself, you can pass a sub reference along
  with this parameter to do so.  When the callback is called, it will be passed:
  
  =over 4
  
  =item 1.
  a true/false value that indicates what OpenSSL thinks of the certificate,
  
  =item 2.
  a C-style memory address of the certificate store,
  
  =item 3.
  a string containing the certificate's issuer attributes and owner attributes, and
  
  =item 4.
  a string containing any errors encountered (0 if no errors).
  
  =item 5.
  a C-style memory address of the peer's own certificate (convertible to
  PEM form with Net::SSLeay::PEM_get_string_X509()).
  
  =back
  
  The function should return 1 or 0, depending on whether it thinks the certificate
  is valid or invalid.  The default is to let OpenSSL do all of the busy work.
  
  The callback will be called for each element in the certificate chain.
  
  See the OpenSSL documentation for SSL_CTX_set_verify for more information.
  
  =item SSL_verifycn_scheme
  
  Set the scheme used to automatically verify the hostname of the peer.
  See the information about the verification schemes in B<verify_hostname>.
  The default is undef, e.g. to not automatically verify the hostname.
  
  =item SSL_verifycn_name
  
  Set the name which is used in verification of hostname. If SSL_verifycn_scheme
  is set and no SSL_verifycn_name is given it will try to use the PeerHost and
  PeerAddr settings and fail if no name caan be determined.
  
  Using PeerHost or PeerAddr works only if you create the connection directly
  with C<< IO::Socket::SSL->new >>, if an IO::Socket::INET object is upgraded
  with B<start_SSL> the name has to be given in B<SSL_verifycn_name>.
  
  =item SSL_check_crl
  
  If you want to verify that the peer certificate has not been revoked
  by the signing authority, set this value to true. OpenSSL will search
  for the CRL in your SSL_ca_path, or use the file specified by
  SSL_crl_file.  See the Net::SSLeay documentation for more details.
  Note that this functionality appears to be broken with OpenSSL <
  v0.9.7b, so its use with lower versions will result in an error.
  
  =item SSL_crl_file
  
  If you want to specify the CRL file to be used, set this value to the
  pathname to be used.  This must be used in addition to setting
  SSL_check_crl.
  
  =item SSL_reuse_ctx
  
  If you have already set the above options (SSL_version through SSL_check_crl;
  this does not include SSL_cipher_list yet) for a previous instance of
  IO::Socket::SSL, then you can reuse the SSL context of that instance by passing
  it as the value for the SSL_reuse_ctx parameter.  You may also create a
  new instance of the IO::Socket::SSL::SSL_Context class, using any context options
  that you desire without specifying connection options, and pass that here instead.
  
  If you use this option, all other context-related options that you pass
  in the same call to new() will be ignored unless the context supplied was invalid.
  Note that, contrary to versions of IO::Socket::SSL below v0.90, a global SSL context
  will not be implicitly used unless you use the set_default_context() function.
  
  =item SSL_session_cache_size
  
  If you make repeated connections to the same host/port and the SSL renegotiation time
  is an issue, you can turn on client-side session caching with this option by specifying a
  positive cache size.  For successive connections, pass the SSL_reuse_ctx option to
  the new() calls (or use set_default_context()) to make use of the cached sessions.
  The session cache size refers to the number of unique host/port pairs that can be
  stored at one time; the oldest sessions in the cache will be removed if new ones are
  added.
  
  =item SSL_session_cache
  
  Specifies session cache object which should be used instead of creating a new.
  Overrules SSL_session_cache_size.
  This option is useful if you want to reuse the cache, but not the rest of
  the context.
  
  A session cache object can be created using
  C<< IO::Socket::SSL::Session_Cache->new( cachesize ) >>.
  
  Use set_default_session_cache() to set a global cache object.
  
  =item SSL_error_trap
  
  When using the accept() or connect() methods, it may be the case that the
  actual socket connection works but the SSL negotiation fails, as in the case of
  an HTTP client connecting to an HTTPS server.  Passing a subroutine ref attached
  to this parameter allows you to gain control of the orphaned socket instead of having it
  be closed forcibly.	 The subroutine, if called, will be passed two parameters:
  a reference to the socket on which the SSL negotiation failed and and the full
  text of the error message.
  
  =back
  
  =item B<close(...)>
  
  There are a number of nasty traps that lie in wait if you are not careful about using
  close().  The first of these will bite you if you have been using shutdown() on your
  sockets.  Since the SSL protocol mandates that a SSL "close notify" message be
  sent before the socket is closed, a shutdown() that closes the socket's write channel
  will cause the close() call to hang.  For a similar reason, if you try to close a
  copy of a socket (as in a forking server) you will affect the original socket as well.
  To get around these problems, call close with an object-oriented syntax
  (e.g. $socket->close(SSL_no_shutdown => 1))
  and one or more of the following parameters:
  
  =over 2
  
  =item SSL_no_shutdown
  
  If set to a true value, this option will make close() not use the SSL_shutdown() call
  on the socket in question so that the close operation can complete without problems
  if you have used shutdown() or are working on a copy of a socket.
  
  =item SSL_fast_shutdown
  
  If set to true only a unidirectional shutdown will be done, e.g. only the
  close_notify (see SSL_shutdown(3)) will be called. Otherwise a bidrectional
  shutdown will be done. If used within close() it defaults to true, if used
  within stop_SSL() it defaults to false.
  
  =item SSL_ctx_free
  
  If you want to make sure that the SSL context of the socket is destroyed when
  you close it, set this option to a true value.
  
  =back
  
  =item B<peek(...)>
  
  This function has exactly the same syntax as sysread(), and performs nearly the same
  task (reading data from the socket) but will not advance the read position so
  that successive calls to peek() with the same arguments will return the same results.
  This function requires OpenSSL 0.9.6a or later to work.
  
  
  =item B<pending()>
  
  This function will let you know how many bytes of data are immediately ready for reading
  from the socket.  This is especially handy if you are doing reads on a blocking socket
  or just want to know if new data has been sent over the socket.
  
  
  =item B<get_cipher()>
  
  Returns the string form of the cipher that the IO::Socket::SSL object is using.
  
  =item B<dump_peer_certificate()>
  
  Returns a parsable string with select fields from the peer SSL certificate.	 This
  method directly returns the result of the dump_peer_certificate() method of Net::SSLeay.
  
  =item B<peer_certificate($field)>
  
  If a peer certificate exists, this function can retrieve values from it.
  If no field is given the internal representation of certificate from Net::SSLeay is
  returned.
  The following fields can be queried:
  
  =over 8
  
  =item authority (alias issuer)
  
  The certificate authority which signed the certificate.
  
  =item owner (alias subject)
  
  The owner of the certificate.
  
  =item commonName (alias cn) - only for Net::SSLeay version >=1.30
  
  The common name, usually the server name for SSL certificates.
  
  =item subjectAltNames - only for Net::SSLeay version >=1.33
  
  Alternative names for the subject, usually different names for the same
  server, like example.org, example.com, *.example.com.
  
  It returns a list of (typ,value) with typ GEN_DNS, GEN_IPADD etc (these
  constants are exported from IO::Socket::SSL).
  See Net::SSLeay::X509_get_subjectAltNames.
  
  =back
  
  =item B<verify_hostname($hostname,$scheme)>
  
  This verifies the given hostname against the peer certificate using the
  given scheme. Hostname is usually what you specify within the PeerAddr.
  
  Verification of hostname against a certificate is different between various
  applications and RFCs. Some scheme allow wildcards for hostnames, some only
  in subjectAltNames, and even their different wildcard schemes are possible.
  
  To ease the verification the following schemes are predefined:
  
  =over 8
  
  =item ldap (rfc4513), pop3,imap,acap (rfc2995), nntp (rfc4642)
  
  Simple wildcards in subjectAltNames are possible, e.g. *.example.org matches
  www.example.org but not lala.www.example.org. If nothing from subjectAltNames
  match it checks against the common name, but there are no wildcards allowed.
  
  =item http (rfc2818), alias is www
  
  Extended wildcards in subjectAltNames are possible, e.g. *.example.org or
  even www*.example.org. Wildcards in the common name are not allowed. The common
  name will be only checked if no names are given in subjectAltNames.
  
  =item smtp (rfc3207)
  
  This RFC doesn't say much useful about the verification so it just assumes
  that subjectAltNames are possible, but no wildcards are possible anywhere.
  
  =back
  
  The scheme can be given either by specifying the name for one of the above predefined
  schemes, by using a callback (see below) or by using a hash which can have the
  following keys and values:
  
  =over 8
  
  =item check_cn:  0|'always'|'when_only'
  
  Determines if the common name gets checked. If 'always' it will always be checked
  (like in ldap), if 'when_only' it will only be checked if no names are given in
  subjectAltNames (like in http), for any other values the common name will not be checked.
  
  =item wildcards_in_alt: 0|'leftmost'|'anywhere'
  
  Determines if and where wildcards in subjectAltNames are possible. If 'leftmost'
  only cases like *.example.org will be possible (like in ldap), for 'anywhere'
  www*.example.org is possible too (like http), dangerous things like but www.*.org
  or even '*' will not be allowed.
  
  =item wildcards_in_cn: 0|'leftmost'|'anywhere'
  
  Similar to wildcards_in_alt, but checks the common name. There is no predefined
  scheme which allows wildcards in common names.
  
  =back
  
  If you give a subroutine for verification it will be called with the arguments
  ($hostname,$commonName,@subjectAltNames), where hostname is the name given for
  verification, commonName is the result from peer_certificate('cn') and
  subjectAltNames is the result from peer_certificate('subjectAltNames').
  
  =item B<errstr()>
  
  Returns the last error (in string form) that occurred.	If you do not have a real
  object to perform this method on, call IO::Socket::SSL::errstr() instead.
  
  For read and write errors on non-blocking sockets, this method may include the string
  C<SSL wants a read first!> or C<SSL wants a write first!> meaning that the other side
  is expecting to read from or write to the socket and wants to be satisfied before you
  get to do anything. But with version 0.98 you are better comparing the global exported
  variable $SSL_ERROR against the exported symbols SSL_WANT_READ and SSL_WANT_WRITE.
  
  =item B<opened()>
  
  This returns false if the socket could not be opened, 1 if the socket could be opened
  and the SSL handshake was successful done and -1 if the underlying IO::Handle is open,
  but the SSL handshake failed.
  
  =item B<< IO::Socket::SSL->start_SSL($socket, ... ) >>
  
  This will convert a glob reference or a socket that you provide to an IO::Socket::SSL
  object.	 You may also pass parameters to specify context or connection options as with
  a call to new().  If you are using this function on an accept()ed socket, you must
  set the parameter "SSL_server" to 1, i.e. IO::Socket::SSL->start_SSL($socket, SSL_server => 1).
  If you have a class that inherits from IO::Socket::SSL and you want the $socket to be blessed
  into your own class instead, use MyClass->start_SSL($socket) to achieve the desired effect.
  
  Note that if start_SSL() fails in SSL negotiation, $socket will remain blessed in its
  original class.	 For non-blocking sockets you better just upgrade the socket to
  IO::Socket::SSL and call accept_SSL or connect_SSL and the upgraded object. To
  just upgrade the socket set B<SSL_startHandshake> explicitly to 0. If you call start_SSL
  w/o this parameter it will revert to blocking behavior for accept_SSL and connect_SSL.
  
  If given the parameter "Timeout" it will stop if after the timeout no SSL connection
  was established. This parameter is only used for blocking sockets, if it is not given the
  default Timeout from the underlying IO::Socket will be used.
  
  =item B<stop_SSL(...)>
  
  This is the opposite of start_SSL(), e.g. it will shutdown the SSL connection
  and return to the class before start_SSL(). It gets the same arguments as close(),
  in fact close() calls stop_SSL() (but without downgrading the class).
  
  Will return true if it suceeded and undef if failed. This might be the case for
  non-blocking sockets. In this case $! is set to EAGAIN and the ssl error to
  SSL_WANT_READ or SSL_WANT_WRITE. In this case the call should be retried again with
  the same arguments once the socket is ready is until it succeeds.
  
  =item B<< IO::Socket::SSL->new_from_fd($fd, ...) >>
  
  This will convert a socket identified via a file descriptor into an SSL socket.
  Note that the argument list does not include a "MODE" argument; if you supply one,
  it will be thoughtfully ignored (for compatibility with IO::Socket::INET).	Instead,
  a mode of '+<' is assumed, and the file descriptor passed must be able to handle such
  I/O because the initial SSL handshake requires bidirectional communication.
  
  =item B<IO::Socket::SSL::set_default_context(...)>
  
  You may use this to make IO::Socket::SSL automatically re-use a given context (unless
  specifically overridden in a call to new()).  It accepts one argument, which should
  be either an IO::Socket::SSL object or an IO::Socket::SSL::SSL_Context object.	See
  the SSL_reuse_ctx option of new() for more details.	 Note that this sets the default
  context globally, so use with caution (esp. in mod_perl scripts).
  
  =item B<IO::Socket::SSL::set_default_session_cache(...)>
  
  You may use this to make IO::Socket::SSL automatically re-use a given session cache
  (unless specifically overridden in a call to new()).  It accepts one argument, which should
  be an IO::Socket::SSL::Session_Cache object or similar (e.g something which implements
  get_session and add_session like IO::Socket::SSL::Session_Cache does).
  See the SSL_session_cache option of new() for more details.	 Note that this sets the default
  cache globally, so use with caution.
  
  =item B<IO::Socket::SSL::set_ctx_defaults(%args)>
  
  With this function one can set defaults for all SSL_* parameter used for creation of
  the context, like the SSL_verify* parameter.
  
  =over 8
  
  =item mode - set default SSL_verify_mode
  
  =item callback - set default SSL_verify_callback
  
  =item scheme - set default SSL_verifycn_scheme
  
  =item name - set default SSL_verifycn_name
  
  If not given and scheme is hash reference with key callback it will be set to 'unknown'
  
  =back
  
  =back
  
  The following methods are unsupported (not to mention futile!) and IO::Socket::SSL
  will emit a large CROAK() if you are silly enough to use them:
  
  =over 4
  
  =item truncate
  
  =item stat
  
  =item ungetc
  
  =item setbuf
  
  =item setvbuf
  
  =item fdopen
  
  =item send/recv
  
  Note that send() and recv() cannot be reliably trapped by a tied filehandle (such as
  that used by IO::Socket::SSL) and so may send unencrypted data over the socket.	 Object-oriented
  calls to these functions will fail, telling you to use the print/printf/syswrite
  and read/sysread families instead.
  
  =back
  
  =head1 IPv6
  
  Support for IPv6 with IO::Socket::SSL is expected to work and basic testing is done.
  If IO::Socket::INET6 is available it will automatically use it instead of
  IO::Socket::INET4.
  
  Please be aware of the associated problems: If you give a name as a host and the
  host resolves to both IPv6 and IPv4 it will try IPv6 first and if there is no IPv6
  connectivity it will fail.
  
  To avoid these problems you can either force IPv4 by specifying and AF_INET as the
  Domain (this is per socket) or load IO::Socket::SSL with the option 'inet4'
  (This is a global setting, e.g. affects all IO::Socket::SSL objects in the program).
  
  =head1 RETURN VALUES
  
  A few changes have gone into IO::Socket::SSL v0.93 and later with respect to
  return values.	The behavior on success remains unchanged, but for I<all> functions,
  the return value on error is now an empty list.	 Therefore, the return value will be
  false in all contexts, but those who have been using the return values as arguments
  to subroutines (like C<mysub(IO::Socket::SSL(...)->new, ...)>) may run into problems.
  The moral of the story: I<always> check the return values of these functions before
  using them in any way that you consider meaningful.
  
  
  =head1 DEBUGGING
  
  If you are having problems using IO::Socket::SSL despite the fact that can recite backwards
  the section of this documentation labelled 'Using SSL', you should try enabling debugging.	To
  specify the debug level, pass 'debug#' (where # is a number from 0 to 3) to IO::Socket::SSL
  when calling it.
  The debug level will also be propagated to Net::SSLeay::trace, see also L<Net::SSLeay>:
  
  =over 4
  
  =item use IO::Socket::SSL qw(debug0);
  
  No debugging (default).
  
  =item use IO::Socket::SSL qw(debug1);
  
  Print out errors from IO::Socket::SSL and ciphers from Net::SSLeay.
  
  =item use IO::Socket::SSL qw(debug2);
  
  Print also information about call flow from IO::Socket::SSL and progress
  information from Net::SSLeay.
  
  =item use IO::Socket::SSL qw(debug3);
  
  Print also some data dumps from IO::Socket::SSL and from Net::SSLeay.
  
  =back
  
  =head1 EXAMPLES
  
  See the 'example' directory.
  
  =head1 BUGS
  
  IO::Socket::SSL is not threadsafe.
  This is because IO::Socket::SSL is based on Net::SSLeay which
  uses a global object to access some of the API of openssl
  and is therefore not threadsafe.
  It might probably work if you don't use SSL_verify_callback and
  SSL_password_cb.
  
  IO::Socket::SSL does not work together with Storable::fd_retrieve/fd_store.
  See BUGS file for more information and how to work around the problem.
  
  Non-blocking and timeouts (which are based on non-blocking) are not
  supported on Win32, because the underlying IO::Socket::INET does not support
  non-blocking on this platform.
  
  =head1 LIMITATIONS
  
  IO::Socket::SSL uses Net::SSLeay as the shiny interface to OpenSSL, which is
  the shiny interface to the ugliness of SSL.	 As a result, you will need both Net::SSLeay
  and OpenSSL on your computer before using this module.
  
  If you have Scalar::Util (standard with Perl 5.8.0 and above) or WeakRef, IO::Socket::SSL
  sockets will auto-close when they go out of scope, just like IO::Socket::INET sockets.	If
  you do not have one of these modules, then IO::Socket::SSL sockets will stay open until the
  program ends or you explicitly close them.	This is due to the fact that a circular reference
  is required to make IO::Socket::SSL sockets act simultaneously like objects and glob references.
  
  =head1 DEPRECATIONS
  
  The following functions are deprecated and are only retained for compatibility:
  
  =over 2
  
  =item context_init()
  
  use the SSL_reuse_ctx option if you want to re-use a context
  
  
  =item socketToSSL() and socket_to_SSL()
  
  use IO::Socket::SSL->start_SSL() instead
  
  =item kill_socket()
  
  use close() instead
  
  =item get_peer_certificate()
  
  use the peer_certificate() function instead.
  Used to return X509_Certificate with methods subject_name and issuer_name.
  Now simply returns $self which has these methods (although depreceated).
  
  =item issuer_name()
  
  use peer_certificate( 'issuer' ) instead
  
  =item subject_name()
  
  use peer_certificate( 'subject' ) instead
  
  =back
  
  The following classes have been removed:
  
  =over 2
  
  =item SSL_SSL
  
  (not that you should have been directly accessing this anyway):
  
  =item X509_Certificate
  
  (but get_peer_certificate() will still Do The Right Thing)
  
  =back
  
  =head1 SEE ALSO
  
  IO::Socket::INET, IO::Socket::INET6, Net::SSLeay.
  
  =head1 AUTHORS
  
  Steffen Ullrich, <steffen at genua.de> is the current maintainer.
  
  Peter Behroozi, <behrooz at fas.harvard.edu> (Note the lack of an "i" at the end of "behrooz")
  
  Marko Asplund, <marko.asplund at kronodoc.fi>, was the original author of IO::Socket::SSL.
  
  Patches incorporated from various people, see file Changes.
  
  =head1 COPYRIGHT
  
  Working support for non-blocking was added by Steffen Ullrich.
  
  The rewrite of this module is Copyright (C) 2002-2005 Peter Behroozi.
  
  The original versions of this module are Copyright (C) 1999-2002 Marko Asplund.
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =head1 Appendix: Using SSL
  
  If you are unfamiliar with the way OpenSSL works, good references may be found in
  both the book "Network Security with OpenSSL" (Oreilly & Assoc.) and the web site
  L<http://www.tldp.org/HOWTO/SSL-Certificates-HOWTO/>.  Read on for a quick overview.
  
  =head2 The Long of It (Detail)
  
  The usual reason for using SSL is to keep your data safe.  This means that not only
  do you have to encrypt the data while it is being transported over a network, but
  you also have to make sure that the right person gets the data.	 To accomplish this
  with SSL, you have to use certificates.	 A certificate closely resembles a
  Government-issued ID (at least in places where you can trust them).	 The ID contains some sort of
  identifying information such as a name and address, and is usually stamped with a seal
  of Government Approval.	 Theoretically, this means that you may trust the information on
  the card and do business with the owner of the card.  The same ideas apply to SSL certificates,
  which have some identifying information and are "stamped" [most people refer to this as
  I<signing> instead] by someone (a Certificate Authority) who you trust will adequately
  verify the identifying information.	 In this case, because of some clever number theory,
  it is extremely difficult to falsify the stamping process.	Another useful consequence
  of number theory is that the certificate is linked to the encryption process, so you may
  encrypt data (using information on the certificate) that only the certificate owner can
  decrypt.
  
  What does this mean for you?  It means that at least one person in the party has to
  have an ID to get drinks :-).  Seriously, it means that one of the people communicating
  has to have a certificate to ensure that your data is safe.	 For client/server
  interactions, the server must B<always> have a certificate.	 If the server wants to
  verify that the client is safe, then the client must also have a personal certificate.
  To verify that a certificate is safe, one compares the stamped "seal" [commonly called
  an I<encrypted digest/hash/signature>] on the certificate with the official "seal" of
  the Certificate Authority to make sure that they are the same.	To do this, you will
  need the [unfortunately named] certificate of the Certificate Authority.  With all these
  in hand, you can set up a SSL connection and be reasonably confident that no-one is
  reading your data.
  
  =head2 The Short of It (Summary)
  
  For servers, you will need to generate a cryptographic private key and a certificate
  request.  You will need to send the certificate request to a Certificate Authority to
  get a real certificate back, after which you can start serving people.	For clients,
  you will not need anything unless the server wants validation, in which case you will
  also need a private key and a real certificate.	 For more information about how to
  get these, see L<http://www.modssl.org/docs/2.8/ssl_faq.html#ToC24>.
  
  =cut
IO_SOCKET_SSL

$fatpacked{"JSON/PP.pm"} = <<'JSON_PP';
  package JSON::PP;
  
  # JSON-2.0
  
  use 5.005;
  use strict;
  use base qw(Exporter);
  use overload ();
  
  use Carp ();
  use B ();
  #use Devel::Peek;
  
  $JSON::PP::VERSION = '2.27202';
  
  @JSON::PP::EXPORT = qw(encode_json decode_json from_json to_json);
  
  # instead of hash-access, i tried index-access for speed.
  # but this method is not faster than what i expected. so it will be changed.
  
  use constant P_ASCII                => 0;
  use constant P_LATIN1               => 1;
  use constant P_UTF8                 => 2;
  use constant P_INDENT               => 3;
  use constant P_CANONICAL            => 4;
  use constant P_SPACE_BEFORE         => 5;
  use constant P_SPACE_AFTER          => 6;
  use constant P_ALLOW_NONREF         => 7;
  use constant P_SHRINK               => 8;
  use constant P_ALLOW_BLESSED        => 9;
  use constant P_CONVERT_BLESSED      => 10;
  use constant P_RELAXED              => 11;
  
  use constant P_LOOSE                => 12;
  use constant P_ALLOW_BIGNUM         => 13;
  use constant P_ALLOW_BAREKEY        => 14;
  use constant P_ALLOW_SINGLEQUOTE    => 15;
  use constant P_ESCAPE_SLASH         => 16;
  use constant P_AS_NONBLESSED        => 17;
  
  use constant P_ALLOW_UNKNOWN        => 18;
  
  use constant OLD_PERL => $] < 5.008 ? 1 : 0;
  
  BEGIN {
      my @xs_compati_bit_properties = qw(
              latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink
              allow_blessed convert_blessed relaxed allow_unknown
      );
      my @pp_bit_properties = qw(
              allow_singlequote allow_bignum loose
              allow_barekey escape_slash as_nonblessed
      );
  
      # Perl version check, Unicode handling is enable?
      # Helper module sets @JSON::PP::_properties.
      if ($] < 5.008 ) {
          my $helper = $] >= 5.006 ? 'JSON::PP::Compat5006' : 'JSON::PP::Compat5005';
          eval qq| require $helper |;
          if ($@) { Carp::croak $@; }
      }
  
      for my $name (@xs_compati_bit_properties, @pp_bit_properties) {
          my $flag_name = 'P_' . uc($name);
  
          eval qq/
              sub $name {
                  my \$enable = defined \$_[1] ? \$_[1] : 1;
  
                  if (\$enable) {
                      \$_[0]->{PROPS}->[$flag_name] = 1;
                  }
                  else {
                      \$_[0]->{PROPS}->[$flag_name] = 0;
                  }
  
                  \$_[0];
              }
  
              sub get_$name {
                  \$_[0]->{PROPS}->[$flag_name] ? 1 : '';
              }
          /;
      }
  
  }
  
  
  
  # Functions
  
  my %encode_allow_method
       = map {($_ => 1)} qw/utf8 pretty allow_nonref latin1 self_encode escape_slash
                            allow_blessed convert_blessed indent indent_length allow_bignum
                            as_nonblessed
                          /;
  my %decode_allow_method
       = map {($_ => 1)} qw/utf8 allow_nonref loose allow_singlequote allow_bignum
                            allow_barekey max_size relaxed/;
  
  
  my $JSON; # cache
  
  sub encode_json ($) { # encode
      ($JSON ||= __PACKAGE__->new->utf8)->encode(@_);
  }
  
  
  sub decode_json { # decode
      ($JSON ||= __PACKAGE__->new->utf8)->decode(@_);
  }
  
  # Obsoleted
  
  sub to_json($) {
     Carp::croak ("JSON::PP::to_json has been renamed to encode_json.");
  }
  
  
  sub from_json($) {
     Carp::croak ("JSON::PP::from_json has been renamed to decode_json.");
  }
  
  
  # Methods
  
  sub new {
      my $class = shift;
      my $self  = {
          max_depth   => 512,
          max_size    => 0,
          indent      => 0,
          FLAGS       => 0,
          fallback      => sub { encode_error('Invalid value. JSON can only reference.') },
          indent_length => 3,
      };
  
      bless $self, $class;
  }
  
  
  sub encode {
      return $_[0]->PP_encode_json($_[1]);
  }
  
  
  sub decode {
      return $_[0]->PP_decode_json($_[1], 0x00000000);
  }
  
  
  sub decode_prefix {
      return $_[0]->PP_decode_json($_[1], 0x00000001);
  }
  
  
  # accessor
  
  
  # pretty printing
  
  sub pretty {
      my ($self, $v) = @_;
      my $enable = defined $v ? $v : 1;
  
      if ($enable) { # indent_length(3) for JSON::XS compatibility
          $self->indent(1)->indent_length(3)->space_before(1)->space_after(1);
      }
      else {
          $self->indent(0)->space_before(0)->space_after(0);
      }
  
      $self;
  }
  
  # etc
  
  sub max_depth {
      my $max  = defined $_[1] ? $_[1] : 0x80000000;
      $_[0]->{max_depth} = $max;
      $_[0];
  }
  
  
  sub get_max_depth { $_[0]->{max_depth}; }
  
  
  sub max_size {
      my $max  = defined $_[1] ? $_[1] : 0;
      $_[0]->{max_size} = $max;
      $_[0];
  }
  
  
  sub get_max_size { $_[0]->{max_size}; }
  
  
  sub filter_json_object {
      $_[0]->{cb_object} = defined $_[1] ? $_[1] : 0;
      $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
      $_[0];
  }
  
  sub filter_json_single_key_object {
      if (@_ > 1) {
          $_[0]->{cb_sk_object}->{$_[1]} = $_[2];
      }
      $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
      $_[0];
  }
  
  sub indent_length {
      if (!defined $_[1] or $_[1] > 15 or $_[1] < 0) {
          Carp::carp "The acceptable range of indent_length() is 0 to 15.";
      }
      else {
          $_[0]->{indent_length} = $_[1];
      }
      $_[0];
  }
  
  sub get_indent_length {
      $_[0]->{indent_length};
  }
  
  sub sort_by {
      $_[0]->{sort_by} = defined $_[1] ? $_[1] : 1;
      $_[0];
  }
  
  sub allow_bigint {
      Carp::carp("allow_bigint() is obsoleted. use allow_bignum() insted.");
  }
  
  ###############################
  
  ###
  ### Perl => JSON
  ###
  
  
  { # Convert
  
      my $max_depth;
      my $indent;
      my $ascii;
      my $latin1;
      my $utf8;
      my $space_before;
      my $space_after;
      my $canonical;
      my $allow_blessed;
      my $convert_blessed;
  
      my $indent_length;
      my $escape_slash;
      my $bignum;
      my $as_nonblessed;
  
      my $depth;
      my $indent_count;
      my $keysort;
  
  
      sub PP_encode_json {
          my $self = shift;
          my $obj  = shift;
  
          $indent_count = 0;
          $depth        = 0;
  
          my $idx = $self->{PROPS};
  
          ($ascii, $latin1, $utf8, $indent, $canonical, $space_before, $space_after, $allow_blessed,
              $convert_blessed, $escape_slash, $bignum, $as_nonblessed)
           = @{$idx}[P_ASCII .. P_SPACE_AFTER, P_ALLOW_BLESSED, P_CONVERT_BLESSED,
                      P_ESCAPE_SLASH, P_ALLOW_BIGNUM, P_AS_NONBLESSED];
  
          ($max_depth, $indent_length) = @{$self}{qw/max_depth indent_length/};
  
          $keysort = $canonical ? sub { $a cmp $b } : undef;
  
          if ($self->{sort_by}) {
              $keysort = ref($self->{sort_by}) eq 'CODE' ? $self->{sort_by}
                       : $self->{sort_by} =~ /\D+/       ? $self->{sort_by}
                       : sub { $a cmp $b };
          }
  
          encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")
               if(!ref $obj and !$idx->[ P_ALLOW_NONREF ]);
  
          my $str  = $self->object_to_json($obj);
  
          $str .= "\n" if ( $indent ); # JSON::XS 2.26 compatible
  
          unless ($ascii or $latin1 or $utf8) {
              utf8::upgrade($str);
          }
  
          if ($idx->[ P_SHRINK ]) {
              utf8::downgrade($str, 1);
          }
  
          return $str;
      }
  
  
      sub object_to_json {
          my ($self, $obj) = @_;
          my $type = ref($obj);
  
          if($type eq 'HASH'){
              return $self->hash_to_json($obj);
          }
          elsif($type eq 'ARRAY'){
              return $self->array_to_json($obj);
          }
          elsif ($type) { # blessed object?
              if (blessed($obj)) {
  
                  return $self->value_to_json($obj) if ( $obj->isa('JSON::PP::Boolean') );
  
                  if ( $convert_blessed and $obj->can('TO_JSON') ) {
                      my $result = $obj->TO_JSON();
                      if ( defined $result and ref( $result ) ) {
                          if ( refaddr( $obj ) eq refaddr( $result ) ) {
                              encode_error( sprintf(
                                  "%s::TO_JSON method returned same object as was passed instead of a new one",
                                  ref $obj
                              ) );
                          }
                      }
  
                      return $self->object_to_json( $result );
                  }
  
                  return "$obj" if ( $bignum and _is_bignum($obj) );
                  return $self->blessed_to_json($obj) if ($allow_blessed and $as_nonblessed); # will be removed.
  
                  encode_error( sprintf("encountered object '%s', but neither allow_blessed "
                      . "nor convert_blessed settings are enabled", $obj)
                  ) unless ($allow_blessed);
  
                  return 'null';
              }
              else {
                  return $self->value_to_json($obj);
              }
          }
          else{
              return $self->value_to_json($obj);
          }
      }
  
  
      sub hash_to_json {
          my ($self, $obj) = @_;
          my @res;
  
          encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                           if (++$depth > $max_depth);
  
          my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
          my $del = ($space_before ? ' ' : '') . ':' . ($space_after ? ' ' : '');
  
          for my $k ( _sort( $obj ) ) {
              if ( OLD_PERL ) { utf8::decode($k) } # key for Perl 5.6 / be optimized
              push @res, string_to_json( $self, $k )
                            .  $del
                            . ( $self->object_to_json( $obj->{$k} ) || $self->value_to_json( $obj->{$k} ) );
          }
  
          --$depth;
          $self->_down_indent() if ($indent);
  
          return   '{' . ( @res ? $pre : '' ) . ( @res ? join( ",$pre", @res ) . $post : '' )  . '}';
      }
  
  
      sub array_to_json {
          my ($self, $obj) = @_;
          my @res;
  
          encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                           if (++$depth > $max_depth);
  
          my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
  
          for my $v (@$obj){
              push @res, $self->object_to_json($v) || $self->value_to_json($v);
          }
  
          --$depth;
          $self->_down_indent() if ($indent);
  
          return '[' . ( @res ? $pre : '' ) . ( @res ? join( ",$pre", @res ) . $post : '' ) . ']';
      }
  
  
      sub value_to_json {
          my ($self, $value) = @_;
  
          return 'null' if(!defined $value);
  
          my $b_obj = B::svref_2object(\$value);  # for round trip problem
          my $flags = $b_obj->FLAGS;
  
          return $value # as is 
              if $flags & ( B::SVp_IOK | B::SVp_NOK ) and !( $flags & B::SVp_POK ); # SvTYPE is IV or NV?
  
          my $type = ref($value);
  
          if(!$type){
              return string_to_json($self, $value);
          }
          elsif( blessed($value) and  $value->isa('JSON::PP::Boolean') ){
              return $$value == 1 ? 'true' : 'false';
          }
          elsif ($type) {
              if ((overload::StrVal($value) =~ /=(\w+)/)[0]) {
                  return $self->value_to_json("$value");
              }
  
              if ($type eq 'SCALAR' and defined $$value) {
                  return   $$value eq '1' ? 'true'
                         : $$value eq '0' ? 'false'
                         : $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ? 'null'
                         : encode_error("cannot encode reference to scalar");
              }
  
               if ( $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ) {
                   return 'null';
               }
               else {
                   if ( $type eq 'SCALAR' or $type eq 'REF' ) {
                      encode_error("cannot encode reference to scalar");
                   }
                   else {
                      encode_error("encountered $value, but JSON can only represent references to arrays or hashes");
                   }
               }
  
          }
          else {
              return $self->{fallback}->($value)
                   if ($self->{fallback} and ref($self->{fallback}) eq 'CODE');
              return 'null';
          }
  
      }
  
  
      my %esc = (
          "\n" => '\n',
          "\r" => '\r',
          "\t" => '\t',
          "\f" => '\f',
          "\b" => '\b',
          "\"" => '\"',
          "\\" => '\\\\',
          "\'" => '\\\'',
      );
  
  
      sub string_to_json {
          my ($self, $arg) = @_;
  
          $arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;
          $arg =~ s/\//\\\//g if ($escape_slash);
          $arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;
  
          if ($ascii) {
              $arg = JSON_PP_encode_ascii($arg);
          }
  
          if ($latin1) {
              $arg = JSON_PP_encode_latin1($arg);
          }
  
          if ($utf8) {
              utf8::encode($arg);
          }
  
          return '"' . $arg . '"';
      }
  
  
      sub blessed_to_json {
          my $reftype = reftype($_[1]) || '';
          if ($reftype eq 'HASH') {
              return $_[0]->hash_to_json($_[1]);
          }
          elsif ($reftype eq 'ARRAY') {
              return $_[0]->array_to_json($_[1]);
          }
          else {
              return 'null';
          }
      }
  
  
      sub encode_error {
          my $error  = shift;
          Carp::croak "$error";
      }
  
  
      sub _sort {
          defined $keysort ? (sort $keysort (keys %{$_[0]})) : keys %{$_[0]};
      }
  
  
      sub _up_indent {
          my $self  = shift;
          my $space = ' ' x $indent_length;
  
          my ($pre,$post) = ('','');
  
          $post = "\n" . $space x $indent_count;
  
          $indent_count++;
  
          $pre = "\n" . $space x $indent_count;
  
          return ($pre,$post);
      }
  
  
      sub _down_indent { $indent_count--; }
  
  
      sub PP_encode_box {
          {
              depth        => $depth,
              indent_count => $indent_count,
          };
      }
  
  } # Convert
  
  
  sub _encode_ascii {
      join('',
          map {
              $_ <= 127 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
          } unpack('U*', $_[0])
      );
  }
  
  
  sub _encode_latin1 {
      join('',
          map {
              $_ <= 255 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
          } unpack('U*', $_[0])
      );
  }
  
  
  sub _encode_surrogates { # from perlunicode
      my $uni = $_[0] - 0x10000;
      return ($uni / 0x400 + 0xD800, $uni % 0x400 + 0xDC00);
  }
  
  
  sub _is_bignum {
      $_[0]->isa('Math::BigInt') or $_[0]->isa('Math::BigFloat');
  }
  
  
  
  #
  # JSON => Perl
  #
  
  my $max_intsize;
  
  BEGIN {
      my $checkint = 1111;
      for my $d (5..64) {
          $checkint .= 1;
          my $int   = eval qq| $checkint |;
          if ($int =~ /[eE]/) {
              $max_intsize = $d - 1;
              last;
          }
      }
  }
  
  { # PARSE 
  
      my %escapes = ( #  by Jeremy Muhlich <jmuhlich [at] bitflood.org>
          b    => "\x8",
          t    => "\x9",
          n    => "\xA",
          f    => "\xC",
          r    => "\xD",
          '\\' => '\\',
          '"'  => '"',
          '/'  => '/',
      );
  
      my $text; # json data
      my $at;   # offset
      my $ch;   # 1chracter
      my $len;  # text length (changed according to UTF8 or NON UTF8)
      # INTERNAL
      my $depth;          # nest counter
      my $encoding;       # json text encoding
      my $is_valid_utf8;  # temp variable
      my $utf8_len;       # utf8 byte length
      # FLAGS
      my $utf8;           # must be utf8
      my $max_depth;      # max nest nubmer of objects and arrays
      my $max_size;
      my $relaxed;
      my $cb_object;
      my $cb_sk_object;
  
      my $F_HOOK;
  
      my $allow_bigint;   # using Math::BigInt
      my $singlequote;    # loosely quoting
      my $loose;          # 
      my $allow_barekey;  # bareKey
  
      # $opt flag
      # 0x00000001 .... decode_prefix
      # 0x10000000 .... incr_parse
  
      sub PP_decode_json {
          my ($self, $opt); # $opt is an effective flag during this decode_json.
  
          ($self, $text, $opt) = @_;
  
          ($at, $ch, $depth) = (0, '', 0);
  
          if ( !defined $text or ref $text ) {
              decode_error("malformed JSON string, neither array, object, number, string or atom");
          }
  
          my $idx = $self->{PROPS};
  
          ($utf8, $relaxed, $loose, $allow_bigint, $allow_barekey, $singlequote)
              = @{$idx}[P_UTF8, P_RELAXED, P_LOOSE .. P_ALLOW_SINGLEQUOTE];
  
          if ( $utf8 ) {
              utf8::downgrade( $text, 1 ) or Carp::croak("Wide character in subroutine entry");
          }
          else {
              utf8::upgrade( $text );
          }
  
          $len = length $text;
  
          ($max_depth, $max_size, $cb_object, $cb_sk_object, $F_HOOK)
               = @{$self}{qw/max_depth  max_size cb_object cb_sk_object F_HOOK/};
  
          if ($max_size > 1) {
              use bytes;
              my $bytes = length $text;
              decode_error(
                  sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s"
                      , $bytes, $max_size), 1
              ) if ($bytes > $max_size);
          }
  
          # Currently no effect
          # should use regexp
          my @octets = unpack('C4', $text);
          $encoding =   ( $octets[0] and  $octets[1]) ? 'UTF-8'
                      : (!$octets[0] and  $octets[1]) ? 'UTF-16BE'
                      : (!$octets[0] and !$octets[1]) ? 'UTF-32BE'
                      : ( $octets[2]                ) ? 'UTF-16LE'
                      : (!$octets[2]                ) ? 'UTF-32LE'
                      : 'unknown';
  
          white(); # remove head white space
  
          my $valid_start = defined $ch; # Is there a first character for JSON structure?
  
          my $result = value();
  
          return undef if ( !$result && ( $opt & 0x10000000 ) ); # for incr_parse
  
          decode_error("malformed JSON string, neither array, object, number, string or atom") unless $valid_start;
  
          if ( !$idx->[ P_ALLOW_NONREF ] and !ref $result ) {
                  decode_error(
                  'JSON text must be an object or array (but found number, string, true, false or null,'
                         . ' use allow_nonref to allow this)', 1);
          }
  
          Carp::croak('something wrong.') if $len < $at; # we won't arrive here.
  
          my $consumed = defined $ch ? $at - 1 : $at; # consumed JSON text length
  
          white(); # remove tail white space
  
          if ( $ch ) {
              return ( $result, $consumed ) if ($opt & 0x00000001); # all right if decode_prefix
              decode_error("garbage after JSON object");
          }
  
          ( $opt & 0x00000001 ) ? ( $result, $consumed ) : $result;
      }
  
  
      sub next_chr {
          return $ch = undef if($at >= $len);
          $ch = substr($text, $at++, 1);
      }
  
  
      sub value {
          white();
          return          if(!defined $ch);
          return object() if($ch eq '{');
          return array()  if($ch eq '[');
          return string() if($ch eq '"' or ($singlequote and $ch eq "'"));
          return number() if($ch =~ /[0-9]/ or $ch eq '-');
          return word();
      }
  
      sub string {
          my ($i, $s, $t, $u);
          my $utf16;
          my $is_utf8;
  
          ($is_valid_utf8, $utf8_len) = ('', 0);
  
          $s = ''; # basically UTF8 flag on
  
          if($ch eq '"' or ($singlequote and $ch eq "'")){
              my $boundChar = $ch;
  
              OUTER: while( defined(next_chr()) ){
  
                  if($ch eq $boundChar){
                      next_chr();
  
                      if ($utf16) {
                          decode_error("missing low surrogate character in surrogate pair");
                      }
  
                      utf8::decode($s) if($is_utf8);
  
                      return $s;
                  }
                  elsif($ch eq '\\'){
                      next_chr();
                      if(exists $escapes{$ch}){
                          $s .= $escapes{$ch};
                      }
                      elsif($ch eq 'u'){ # UNICODE handling
                          my $u = '';
  
                          for(1..4){
                              $ch = next_chr();
                              last OUTER if($ch !~ /[0-9a-fA-F]/);
                              $u .= $ch;
                          }
  
                          # U+D800 - U+DBFF
                          if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/) { # UTF-16 high surrogate?
                              $utf16 = $u;
                          }
                          # U+DC00 - U+DFFF
                          elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/) { # UTF-16 low surrogate?
                              unless (defined $utf16) {
                                  decode_error("missing high surrogate character in surrogate pair");
                              }
                              $is_utf8 = 1;
                              $s .= JSON_PP_decode_surrogates($utf16, $u) || next;
                              $utf16 = undef;
                          }
                          else {
                              if (defined $utf16) {
                                  decode_error("surrogate pair expected");
                              }
  
                              if ( ( my $hex = hex( $u ) ) > 127 ) {
                                  $is_utf8 = 1;
                                  $s .= JSON_PP_decode_unicode($u) || next;
                              }
                              else {
                                  $s .= chr $hex;
                              }
                          }
  
                      }
                      else{
                          unless ($loose) {
                              $at -= 2;
                              decode_error('illegal backslash escape sequence in string');
                          }
                          $s .= $ch;
                      }
                  }
                  else{
  
                      if ( ord $ch  > 127 ) {
                          if ( $utf8 ) {
                              unless( $ch = is_valid_utf8($ch) ) {
                                  $at -= 1;
                                  decode_error("malformed UTF-8 character in JSON string");
                              }
                              else {
                                  $at += $utf8_len - 1;
                              }
                          }
                          else {
                              utf8::encode( $ch );
                          }
  
                          $is_utf8 = 1;
                      }
  
                      if (!$loose) {
                          if ($ch =~ /[\x00-\x1f\x22\x5c]/)  { # '/' ok
                              $at--;
                              decode_error('invalid character encountered while parsing JSON string');
                          }
                      }
  
                      $s .= $ch;
                  }
              }
          }
  
          decode_error("unexpected end of string while parsing JSON string");
      }
  
  
      sub white {
          while( defined $ch  ){
              if($ch le ' '){
                  next_chr();
              }
              elsif($ch eq '/'){
                  next_chr();
                  if(defined $ch and $ch eq '/'){
                      1 while(defined(next_chr()) and $ch ne "\n" and $ch ne "\r");
                  }
                  elsif(defined $ch and $ch eq '*'){
                      next_chr();
                      while(1){
                          if(defined $ch){
                              if($ch eq '*'){
                                  if(defined(next_chr()) and $ch eq '/'){
                                      next_chr();
                                      last;
                                  }
                              }
                              else{
                                  next_chr();
                              }
                          }
                          else{
                              decode_error("Unterminated comment");
                          }
                      }
                      next;
                  }
                  else{
                      $at--;
                      decode_error("malformed JSON string, neither array, object, number, string or atom");
                  }
              }
              else{
                  if ($relaxed and $ch eq '#') { # correctly?
                      pos($text) = $at;
                      $text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;
                      $at = pos($text);
                      next_chr;
                      next;
                  }
  
                  last;
              }
          }
      }
  
  
      sub array {
          my $a  = $_[0] || []; # you can use this code to use another array ref object.
  
          decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                      if (++$depth > $max_depth);
  
          next_chr();
          white();
  
          if(defined $ch and $ch eq ']'){
              --$depth;
              next_chr();
              return $a;
          }
          else {
              while(defined($ch)){
                  push @$a, value();
  
                  white();
  
                  if (!defined $ch) {
                      last;
                  }
  
                  if($ch eq ']'){
                      --$depth;
                      next_chr();
                      return $a;
                  }
  
                  if($ch ne ','){
                      last;
                  }
  
                  next_chr();
                  white();
  
                  if ($relaxed and $ch eq ']') {
                      --$depth;
                      next_chr();
                      return $a;
                  }
  
              }
          }
  
          decode_error(", or ] expected while parsing array");
      }
  
  
      sub object {
          my $o = $_[0] || {}; # you can use this code to use another hash ref object.
          my $k;
  
          decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                  if (++$depth > $max_depth);
          next_chr();
          white();
  
          if(defined $ch and $ch eq '}'){
              --$depth;
              next_chr();
              if ($F_HOOK) {
                  return _json_object_hook($o);
              }
              return $o;
          }
          else {
              while (defined $ch) {
                  $k = ($allow_barekey and $ch ne '"' and $ch ne "'") ? bareKey() : string();
                  white();
  
                  if(!defined $ch or $ch ne ':'){
                      $at--;
                      decode_error("':' expected");
                  }
  
                  next_chr();
                  $o->{$k} = value();
                  white();
  
                  last if (!defined $ch);
  
                  if($ch eq '}'){
                      --$depth;
                      next_chr();
                      if ($F_HOOK) {
                          return _json_object_hook($o);
                      }
                      return $o;
                  }
  
                  if($ch ne ','){
                      last;
                  }
  
                  next_chr();
                  white();
  
                  if ($relaxed and $ch eq '}') {
                      --$depth;
                      next_chr();
                      if ($F_HOOK) {
                          return _json_object_hook($o);
                      }
                      return $o;
                  }
  
              }
  
          }
  
          $at--;
          decode_error(", or } expected while parsing object/hash");
      }
  
  
      sub bareKey { # doesn't strictly follow Standard ECMA-262 3rd Edition
          my $key;
          while($ch =~ /[^\x00-\x23\x25-\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/){
              $key .= $ch;
              next_chr();
          }
          return $key;
      }
  
  
      sub word {
          my $word =  substr($text,$at-1,4);
  
          if($word eq 'true'){
              $at += 3;
              next_chr;
              return $JSON::PP::true;
          }
          elsif($word eq 'null'){
              $at += 3;
              next_chr;
              return undef;
          }
          elsif($word eq 'fals'){
              $at += 3;
              if(substr($text,$at,1) eq 'e'){
                  $at++;
                  next_chr;
                  return $JSON::PP::false;
              }
          }
  
          $at--; # for decode_error report
  
          decode_error("'null' expected")  if ($word =~ /^n/);
          decode_error("'true' expected")  if ($word =~ /^t/);
          decode_error("'false' expected") if ($word =~ /^f/);
          decode_error("malformed JSON string, neither array, object, number, string or atom");
      }
  
  
      sub number {
          my $n    = '';
          my $v;
  
          # According to RFC4627, hex or oct digts are invalid.
          if($ch eq '0'){
              my $peek = substr($text,$at,1);
              my $hex  = $peek =~ /[xX]/; # 0 or 1
  
              if($hex){
                  decode_error("malformed number (leading zero must not be followed by another digit)");
                  ($n) = ( substr($text, $at+1) =~ /^([0-9a-fA-F]+)/);
              }
              else{ # oct
                  ($n) = ( substr($text, $at) =~ /^([0-7]+)/);
                  if (defined $n and length $n > 1) {
                      decode_error("malformed number (leading zero must not be followed by another digit)");
                  }
              }
  
              if(defined $n and length($n)){
                  if (!$hex and length($n) == 1) {
                     decode_error("malformed number (leading zero must not be followed by another digit)");
                  }
                  $at += length($n) + $hex;
                  next_chr;
                  return $hex ? hex($n) : oct($n);
              }
          }
  
          if($ch eq '-'){
              $n = '-';
              next_chr;
              if (!defined $ch or $ch !~ /\d/) {
                  decode_error("malformed number (no digits after initial minus)");
              }
          }
  
          while(defined $ch and $ch =~ /\d/){
              $n .= $ch;
              next_chr;
          }
  
          if(defined $ch and $ch eq '.'){
              $n .= '.';
  
              next_chr;
              if (!defined $ch or $ch !~ /\d/) {
                  decode_error("malformed number (no digits after decimal point)");
              }
              else {
                  $n .= $ch;
              }
  
              while(defined(next_chr) and $ch =~ /\d/){
                  $n .= $ch;
              }
          }
  
          if(defined $ch and ($ch eq 'e' or $ch eq 'E')){
              $n .= $ch;
              next_chr;
  
              if(defined($ch) and ($ch eq '+' or $ch eq '-')){
                  $n .= $ch;
                  next_chr;
                  if (!defined $ch or $ch =~ /\D/) {
                      decode_error("malformed number (no digits after exp sign)");
                  }
                  $n .= $ch;
              }
              elsif(defined($ch) and $ch =~ /\d/){
                  $n .= $ch;
              }
              else {
                  decode_error("malformed number (no digits after exp sign)");
              }
  
              while(defined(next_chr) and $ch =~ /\d/){
                  $n .= $ch;
              }
  
          }
  
          $v .= $n;
  
          if ($v !~ /[.eE]/ and length $v > $max_intsize) {
              if ($allow_bigint) { # from Adam Sussman
                  require Math::BigInt;
                  return Math::BigInt->new($v);
              }
              else {
                  return "$v";
              }
          }
          elsif ($allow_bigint) {
              require Math::BigFloat;
              return Math::BigFloat->new($v);
          }
  
          return 0+$v;
      }
  
  
      sub is_valid_utf8 {
  
          $utf8_len = $_[0] =~ /[\x00-\x7F]/  ? 1
                    : $_[0] =~ /[\xC2-\xDF]/  ? 2
                    : $_[0] =~ /[\xE0-\xEF]/  ? 3
                    : $_[0] =~ /[\xF0-\xF4]/  ? 4
                    : 0
                    ;
  
          return unless $utf8_len;
  
          my $is_valid_utf8 = substr($text, $at - 1, $utf8_len);
  
          return ( $is_valid_utf8 =~ /^(?:
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
          )$/x )  ? $is_valid_utf8 : '';
      }
  
  
      sub decode_error {
          my $error  = shift;
          my $no_rep = shift;
          my $str    = defined $text ? substr($text, $at) : '';
          my $mess   = '';
          my $type   = $] >= 5.008           ? 'U*'
                     : $] <  5.006           ? 'C*'
                     : utf8::is_utf8( $str ) ? 'U*' # 5.6
                     : 'C*'
                     ;
  
          for my $c ( unpack( $type, $str ) ) { # emulate pv_uni_display() ?
              $mess .=  $c == 0x07 ? '\a'
                      : $c == 0x09 ? '\t'
                      : $c == 0x0a ? '\n'
                      : $c == 0x0d ? '\r'
                      : $c == 0x0c ? '\f'
                      : $c <  0x20 ? sprintf('\x{%x}', $c)
                      : $c == 0x5c ? '\\\\'
                      : $c <  0x80 ? chr($c)
                      : sprintf('\x{%x}', $c)
                      ;
              if ( length $mess >= 20 ) {
                  $mess .= '...';
                  last;
              }
          }
  
          unless ( length $mess ) {
              $mess = '(end of string)';
          }
  
          Carp::croak (
              $no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")"
          );
  
      }
  
  
      sub _json_object_hook {
          my $o    = $_[0];
          my @ks = keys %{$o};
  
          if ( $cb_sk_object and @ks == 1 and exists $cb_sk_object->{ $ks[0] } and ref $cb_sk_object->{ $ks[0] } ) {
              my @val = $cb_sk_object->{ $ks[0] }->( $o->{$ks[0]} );
              if (@val == 1) {
                  return $val[0];
              }
          }
  
          my @val = $cb_object->($o) if ($cb_object);
          if (@val == 0 or @val > 1) {
              return $o;
          }
          else {
              return $val[0];
          }
      }
  
  
      sub PP_decode_box {
          {
              text    => $text,
              at      => $at,
              ch      => $ch,
              len     => $len,
              depth   => $depth,
              encoding      => $encoding,
              is_valid_utf8 => $is_valid_utf8,
          };
      }
  
  } # PARSE
  
  
  sub _decode_surrogates { # from perlunicode
      my $uni = 0x10000 + (hex($_[0]) - 0xD800) * 0x400 + (hex($_[1]) - 0xDC00);
      my $un  = pack('U*', $uni);
      utf8::encode( $un );
      return $un;
  }
  
  
  sub _decode_unicode {
      my $un = pack('U', hex shift);
      utf8::encode( $un );
      return $un;
  }
  
  #
  # Setup for various Perl versions (the code from JSON::PP58)
  #
  
  BEGIN {
  
      unless ( defined &utf8::is_utf8 ) {
         require Encode;
         *utf8::is_utf8 = *Encode::is_utf8;
      }
  
      if ( $] >= 5.008 ) {
          *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
          *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
          *JSON::PP::JSON_PP_decode_surrogates = \&_decode_surrogates;
          *JSON::PP::JSON_PP_decode_unicode    = \&_decode_unicode;
      }
  
      if ($] >= 5.008 and $] < 5.008003) { # join() in 5.8.0 - 5.8.2 is broken.
          package JSON::PP;
          require subs;
          subs->import('join');
          eval q|
              sub join {
                  return '' if (@_ < 2);
                  my $j   = shift;
                  my $str = shift;
                  for (@_) { $str .= $j . $_; }
                  return $str;
              }
          |;
      }
  
  
      sub JSON::PP::incr_parse {
          local $Carp::CarpLevel = 1;
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_parse( @_ );
      }
  
  
      sub JSON::PP::incr_skip {
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_skip;
      }
  
  
      sub JSON::PP::incr_reset {
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_reset;
      }
  
      eval q{
          sub JSON::PP::incr_text : lvalue {
              $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
              if ( $_[0]->{_incr_parser}->{incr_parsing} ) {
                  Carp::croak("incr_text can not be called when the incremental parser already started parsing");
              }
              $_[0]->{_incr_parser}->{incr_text};
          }
      } if ( $] >= 5.006 );
  
  } # Setup for various Perl versions (the code from JSON::PP58)
  
  
  ###############################
  # Utilities
  #
  
  BEGIN {
      eval 'require Scalar::Util';
      unless($@){
          *JSON::PP::blessed = \&Scalar::Util::blessed;
          *JSON::PP::reftype = \&Scalar::Util::reftype;
          *JSON::PP::refaddr = \&Scalar::Util::refaddr;
      }
      else{ # This code is from Sclar::Util.
          # warn $@;
          eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';
          *JSON::PP::blessed = sub {
              local($@, $SIG{__DIE__}, $SIG{__WARN__});
              ref($_[0]) ? eval { $_[0]->a_sub_not_likely_to_be_here } : undef;
          };
          my %tmap = qw(
              B::NULL   SCALAR
              B::HV     HASH
              B::AV     ARRAY
              B::CV     CODE
              B::IO     IO
              B::GV     GLOB
              B::REGEXP REGEXP
          );
          *JSON::PP::reftype = sub {
              my $r = shift;
  
              return undef unless length(ref($r));
  
              my $t = ref(B::svref_2object($r));
  
              return
                  exists $tmap{$t} ? $tmap{$t}
                : length(ref($$r)) ? 'REF'
                :                    'SCALAR';
          };
          *JSON::PP::refaddr = sub {
            return undef unless length(ref($_[0]));
  
            my $addr;
            if(defined(my $pkg = blessed($_[0]))) {
              $addr .= bless $_[0], 'Scalar::Util::Fake';
              bless $_[0], $pkg;
            }
            else {
              $addr .= $_[0]
            }
  
            $addr =~ /0x(\w+)/;
            local $^W;
            #no warnings 'portable';
            hex($1);
          }
      }
  }
  
  
  # shamely copied and modified from JSON::XS code.
  
  $JSON::PP::true  = do { bless \(my $dummy = 1), "JSON::PP::Boolean" };
  $JSON::PP::false = do { bless \(my $dummy = 0), "JSON::PP::Boolean" };
  
  sub is_bool { defined $_[0] and UNIVERSAL::isa($_[0], "JSON::PP::Boolean"); }
  
  sub true  { $JSON::PP::true  }
  sub false { $JSON::PP::false }
  sub null  { undef; }
  
  ###############################
  
  package JSON::PP::Boolean;
  
  use overload (
     "0+"     => sub { ${$_[0]} },
     "++"     => sub { $_[0] = ${$_[0]} + 1 },
     "--"     => sub { $_[0] = ${$_[0]} - 1 },
     fallback => 1,
  );
  
  
  ###############################
  
  package JSON::PP::IncrParser;
  
  use strict;
  
  use constant INCR_M_WS   => 0; # initial whitespace skipping
  use constant INCR_M_STR  => 1; # inside string
  use constant INCR_M_BS   => 2; # inside backslash
  use constant INCR_M_JSON => 3; # outside anything, count nesting
  use constant INCR_M_C0   => 4;
  use constant INCR_M_C1   => 5;
  
  $JSON::PP::IncrParser::VERSION = '1.01';
  
  my $unpack_format = $] < 5.006 ? 'C*' : 'U*';
  
  sub new {
      my ( $class ) = @_;
  
      bless {
          incr_nest    => 0,
          incr_text    => undef,
          incr_parsing => 0,
          incr_p       => 0,
      }, $class;
  }
  
  
  sub incr_parse {
      my ( $self, $coder, $text ) = @_;
  
      $self->{incr_text} = '' unless ( defined $self->{incr_text} );
  
      if ( defined $text ) {
          if ( utf8::is_utf8( $text ) and !utf8::is_utf8( $self->{incr_text} ) ) {
              utf8::upgrade( $self->{incr_text} ) ;
              utf8::decode( $self->{incr_text} ) ;
          }
          $self->{incr_text} .= $text;
      }
  
  
      my $max_size = $coder->get_max_size;
  
      if ( defined wantarray ) {
  
          $self->{incr_mode} = INCR_M_WS unless defined $self->{incr_mode};
  
          if ( wantarray ) {
              my @ret;
  
              $self->{incr_parsing} = 1;
  
              do {
                  push @ret, $self->_incr_parse( $coder, $self->{incr_text} );
  
                  unless ( !$self->{incr_nest} and $self->{incr_mode} == INCR_M_JSON ) {
                      $self->{incr_mode} = INCR_M_WS if $self->{incr_mode} != INCR_M_STR;
                  }
  
              } until ( length $self->{incr_text} >= $self->{incr_p} );
  
              $self->{incr_parsing} = 0;
  
              return @ret;
          }
          else { # in scalar context
              $self->{incr_parsing} = 1;
              my $obj = $self->_incr_parse( $coder, $self->{incr_text} );
              $self->{incr_parsing} = 0 if defined $obj; # pointed by Martin J. Evans
              return $obj ? $obj : undef; # $obj is an empty string, parsing was completed.
          }
  
      }
  
  }
  
  
  sub _incr_parse {
      my ( $self, $coder, $text, $skip ) = @_;
      my $p = $self->{incr_p};
      my $restore = $p;
  
      my @obj;
      my $len = length $text;
  
      if ( $self->{incr_mode} == INCR_M_WS ) {
          while ( $len > $p ) {
              my $s = substr( $text, $p, 1 );
              $p++ and next if ( 0x20 >= unpack($unpack_format, $s) );
              $self->{incr_mode} = INCR_M_JSON;
              last;
         }
      }
  
      while ( $len > $p ) {
          my $s = substr( $text, $p++, 1 );
  
          if ( $s eq '"' ) {
              if (substr( $text, $p - 2, 1 ) eq '\\' ) {
                  next;
              }
  
              if ( $self->{incr_mode} != INCR_M_STR  ) {
                  $self->{incr_mode} = INCR_M_STR;
              }
              else {
                  $self->{incr_mode} = INCR_M_JSON;
                  unless ( $self->{incr_nest} ) {
                      last;
                  }
              }
          }
  
          if ( $self->{incr_mode} == INCR_M_JSON ) {
  
              if ( $s eq '[' or $s eq '{' ) {
                  if ( ++$self->{incr_nest} > $coder->get_max_depth ) {
                      Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)');
                  }
              }
              elsif ( $s eq ']' or $s eq '}' ) {
                  last if ( --$self->{incr_nest} <= 0 );
              }
              elsif ( $s eq '#' ) {
                  while ( $len > $p ) {
                      last if substr( $text, $p++, 1 ) eq "\n";
                  }
              }
  
          }
  
      }
  
      $self->{incr_p} = $p;
  
      return if ( $self->{incr_mode} == INCR_M_STR and not $self->{incr_nest} );
      return if ( $self->{incr_mode} == INCR_M_JSON and $self->{incr_nest} > 0 );
  
      return '' unless ( length substr( $self->{incr_text}, 0, $p ) );
  
      local $Carp::CarpLevel = 2;
  
      $self->{incr_p} = $restore;
      $self->{incr_c} = $p;
  
      my ( $obj, $tail ) = $coder->PP_decode_json( substr( $self->{incr_text}, 0, $p ), 0x10000001 );
  
      $self->{incr_text} = substr( $self->{incr_text}, $p );
      $self->{incr_p} = 0;
  
      return $obj or '';
  }
  
  
  sub incr_text {
      if ( $_[0]->{incr_parsing} ) {
          Carp::croak("incr_text can not be called when the incremental parser already started parsing");
      }
      $_[0]->{incr_text};
  }
  
  
  sub incr_skip {
      my $self  = shift;
      $self->{incr_text} = substr( $self->{incr_text}, $self->{incr_c} );
      $self->{incr_p} = 0;
  }
  
  
  sub incr_reset {
      my $self = shift;
      $self->{incr_text}    = undef;
      $self->{incr_p}       = 0;
      $self->{incr_mode}    = 0;
      $self->{incr_nest}    = 0;
      $self->{incr_parsing} = 0;
  }
  
  ###############################
  
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  JSON::PP - JSON::XS compatible pure-Perl module.
  
  =head1 SYNOPSIS
  
   use JSON::PP;
  
   # exported functions, they croak on error
   # and expect/generate UTF-8
  
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
  
   # OO-interface
  
   $coder = JSON::PP->new->ascii->pretty->allow_nonref;
   
   $json_text   = $json->encode( $perl_scalar );
   $perl_scalar = $json->decode( $json_text );
   
   $pretty_printed = $json->pretty->encode( $perl_scalar ); # pretty-printing
   
   # Note that JSON version 2.0 and above will automatically use
   # JSON::XS or JSON::PP, so you should be able to just:
   
   use JSON;
  
  
  =head1 VERSION
  
      2.27202
  
  L<JSON::XS> 2.27 (~2.30) compatible.
  
  =head1 NOTE
  
  JSON::PP had been inculded in JSON distribution (CPAN module).
  It was a perl core module in Perl 5.14.
  
  =head1 DESCRIPTION
  
  This module is L<JSON::XS> compatible pure Perl module.
  (Perl 5.8 or later is recommended)
  
  JSON::XS is the fastest and most proper JSON module on CPAN.
  It is written by Marc Lehmann in C, so must be compiled and
  installed in the used environment.
  
  JSON::PP is a pure-Perl module and has compatibility to JSON::XS.
  
  
  =head2 FEATURES
  
  =over
  
  =item * correct unicode handling
  
  This module knows how to handle Unicode (depending on Perl version).
  
  See to L<JSON::XS/A FEW NOTES ON UNICODE AND PERL> and L<UNICODE HANDLING ON PERLS>.
  
  
  =item * round-trip integrity
  
  When you serialise a perl data structure using only data types supported
  by JSON and Perl, the deserialised data structure is identical on the Perl
  level. (e.g. the string "2.0" doesn't suddenly become "2" just because
  it looks like a number). There I<are> minor exceptions to this, read the
  MAPPING section below to learn about those.
  
  
  =item * strict checking of JSON correctness
  
  There is no guessing, no generating of illegal JSON texts by default,
  and only JSON is accepted as input by default (the latter is a security feature).
  But when some options are set, loose chcking features are available.
  
  =back
  
  =head1 FUNCTIONAL INTERFACE
  
  Some documents are copied and modified from L<JSON::XS/FUNCTIONAL INTERFACE>.
  
  =head2 encode_json
  
      $json_text = encode_json $perl_scalar
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string.
  
  This function call is functionally identical to:
  
      $json_text = JSON::PP->new->utf8->encode($perl_scalar)
  
  =head2 decode_json
  
      $perl_scalar = decode_json $json_text
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
  to parse that as an UTF-8 encoded JSON text, returning the resulting
  reference.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON::PP->new->utf8->decode($json_text)
  
  =head2 JSON::PP::is_bool
  
      $is_boolean = JSON::PP::is_bool($scalar)
  
  Returns true if the passed scalar represents either JSON::PP::true or
  JSON::PP::false, two constants that act like C<1> and C<0> respectively
  and are also used to represent JSON C<true> and C<false> in Perl strings.
  
  =head2 JSON::PP::true
  
  Returns JSON true value which is blessed object.
  It C<isa> JSON::PP::Boolean object.
  
  =head2 JSON::PP::false
  
  Returns JSON false value which is blessed object.
  It C<isa> JSON::PP::Boolean object.
  
  =head2 JSON::PP::null
  
  Returns C<undef>.
  
  See L<MAPPING>, below, for more information on how JSON values are mapped to
  Perl.
  
  
  =head1 HOW DO I DECODE A DATA FROM OUTER AND ENCODE TO OUTER
  
  This section supposes that your perl vresion is 5.8 or later.
  
  If you know a JSON text from an outer world - a network, a file content, and so on,
  is encoded in UTF-8, you should use C<decode_json> or C<JSON> module object
  with C<utf8> enable. And the decoded result will contain UNICODE characters.
  
    # from network
    my $json        = JSON::PP->new->utf8;
    my $json_text   = CGI->new->param( 'json_data' );
    my $perl_scalar = $json->decode( $json_text );
    
    # from file content
    local $/;
    open( my $fh, '<', 'json.data' );
    $json_text   = <$fh>;
    $perl_scalar = decode_json( $json_text );
  
  If an outer data is not encoded in UTF-8, firstly you should C<decode> it.
  
    use Encode;
    local $/;
    open( my $fh, '<', 'json.data' );
    my $encoding = 'cp932';
    my $unicode_json_text = decode( $encoding, <$fh> ); # UNICODE
    
    # or you can write the below code.
    #
    # open( my $fh, "<:encoding($encoding)", 'json.data' );
    # $unicode_json_text = <$fh>;
  
  In this case, C<$unicode_json_text> is of course UNICODE string.
  So you B<cannot> use C<decode_json> nor C<JSON> module object with C<utf8> enable.
  Instead of them, you use C<JSON> module object with C<utf8> disable.
  
    $perl_scalar = $json->utf8(0)->decode( $unicode_json_text );
  
  Or C<encode 'utf8'> and C<decode_json>:
  
    $perl_scalar = decode_json( encode( 'utf8', $unicode_json_text ) );
    # this way is not efficient.
  
  And now, you want to convert your C<$perl_scalar> into JSON data and
  send it to an outer world - a network or a file content, and so on.
  
  Your data usually contains UNICODE strings and you want the converted data to be encoded
  in UTF-8, you should use C<encode_json> or C<JSON> module object with C<utf8> enable.
  
    print encode_json( $perl_scalar ); # to a network? file? or display?
    # or
    print $json->utf8->encode( $perl_scalar );
  
  If C<$perl_scalar> does not contain UNICODE but C<$encoding>-encoded strings
  for some reason, then its characters are regarded as B<latin1> for perl
  (because it does not concern with your $encoding).
  You B<cannot> use C<encode_json> nor C<JSON> module object with C<utf8> enable.
  Instead of them, you use C<JSON> module object with C<utf8> disable.
  Note that the resulted text is a UNICODE string but no problem to print it.
  
    # $perl_scalar contains $encoding encoded string values
    $unicode_json_text = $json->utf8(0)->encode( $perl_scalar );
    # $unicode_json_text consists of characters less than 0x100
    print $unicode_json_text;
  
  Or C<decode $encoding> all string values and C<encode_json>:
  
    $perl_scalar->{ foo } = decode( $encoding, $perl_scalar->{ foo } );
    # ... do it to each string values, then encode_json
    $json_text = encode_json( $perl_scalar );
  
  This method is a proper way but probably not efficient.
  
  See to L<Encode>, L<perluniintro>.
  
  
  =head1 METHODS
  
  Basically, check to L<JSON> or L<JSON::XS>.
  
  =head2 new
  
      $json = JSON::PP->new
  
  Rturns a new JSON::PP object that can be used to de/encode JSON
  strings.
  
  All boolean flags described below are by default I<disabled>.
  
  The mutators for flags all return the JSON object again and thus calls can
  be chained:
  
     my $json = JSON::PP->new->utf8->space_after->encode({a => [1,2]})
     => {"a": [1, 2]}
  
  =head2 ascii
  
      $json = $json->ascii([$enable])
      
      $enabled = $json->get_ascii
  
  If $enable is true (or missing), then the encode method will not generate characters outside
  the code range 0..127. Any Unicode characters outside that range will be escaped using either
  a single \uXXXX or a double \uHHHH\uLLLLL escape sequence, as per RFC4627.
  (See to L<JSON::XS/OBJECT-ORIENTED INTERFACE>).
  
  In Perl 5.005, there is no character having high value (more than 255).
  See to L<UNICODE HANDLING ON PERLS>.
  
  If $enable is false, then the encode method will not escape Unicode characters unless
  required by the JSON syntax or other flags. This results in a faster and more compact format.
  
    JSON::PP->new->ascii(1)->encode([chr 0x10401])
    => ["\ud801\udc01"]
  
  =head2 latin1
  
      $json = $json->latin1([$enable])
      
      $enabled = $json->get_latin1
  
  If $enable is true (or missing), then the encode method will encode the resulting JSON
  text as latin1 (or iso-8859-1), escaping any characters outside the code range 0..255.
  
  If $enable is false, then the encode method will not escape Unicode characters
  unless required by the JSON syntax or other flags.
  
    JSON::XS->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  See to L<UNICODE HANDLING ON PERLS>.
  
  =head2 utf8
  
      $json = $json->utf8([$enable])
      
      $enabled = $json->get_utf8
  
  If $enable is true (or missing), then the encode method will encode the JSON result
  into UTF-8, as required by many protocols, while the decode method expects to be handled
  an UTF-8-encoded string. Please note that UTF-8-encoded strings do not contain any
  characters outside the range 0..255, they are thus useful for bytewise/binary I/O.
  
  (In Perl 5.005, any character outside the range 0..255 does not exist.
  See to L<UNICODE HANDLING ON PERLS>.)
  
  In future versions, enabling this option might enable autodetection of the UTF-16 and UTF-32
  encoding families, as described in RFC4627.
  
  If $enable is false, then the encode method will return the JSON string as a (non-encoded)
  Unicode string, while decode expects thus a Unicode string. Any decoding or encoding
  (e.g. to UTF-8 or UTF-16) needs to be done yourself, e.g. using the Encode module.
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", JSON::PP->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = JSON::PP->new->decode (decode "UTF-32LE", $jsontext);
  
  
  =head2 pretty
  
      $json = $json->pretty([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> flags in one call to generate the most readable
  (or most compact) form possible.
  
  Equivalent to:
  
     $json->indent->space_before->space_after
  
  =head2 indent
  
      $json = $json->indent([$enable])
      
      $enabled = $json->get_indent
  
  The default indent space length is three.
  You can use C<indent_length> to change the length.
  
  =head2 space_before
  
      $json = $json->space_before([$enable])
      
      $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  =head2 space_after
  
      $json = $json->space_after([$enable])
      
      $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space after the C<:> separating keys from values in JSON objects
  and extra whitespace after the C<,> separating key-value pairs and array
  members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  =head2 relaxed
  
      $json = $json->relaxed([$enable])
      
      $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in anyway. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =back
  
  =head2 canonical
  
      $json = $json->canonical([$enable])
      
      $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
  by sorting their keys. This is adding a comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  If you want your own sorting routine, you can give a code referece
  or a subroutine name to C<sort_by>. See to C<JSON::PP OWN METHODS>.
  
  =head2 allow_nonref
  
      $json = $json->allow_nonref([$enable])
      
      $enabled = $json->get_allow_nonref
  
  If C<$enable> is true (or missing), then the C<encode> method can convert a
  non-reference into its corresponding string, number or null JSON value,
  which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
  values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
     JSON::PP->new->allow_nonref->encode ("Hello, World!")
     => "Hello, World!"
  
  =head2 allow_unknown
  
      $json = $json->allow_unknown ([$enable])
      
      $enabled = $json->get_allow_unknown
  
  If $enable is true (or missing), then "encode" will *not* throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON "null" value.
  Note that blessed objects are not included here and are handled
  separately by c<allow_nonref>.
  
  If $enable is false (the default), then "encode" will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect "decode" in any way, and it is
  recommended to leave it off unless you know your communications
  partner.
  
  =head2 allow_blessed
  
      $json = $json->allow_blessed([$enable])
      
      $enabled = $json->get_allow_blessed
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference. Instead, the value of the
  B<convert_blessed> option will decide whether C<null> (C<convert_blessed>
  disabled or no C<TO_JSON> method found) or a representation of the
  object (C<convert_blessed> enabled and C<TO_JSON> method found) is being
  encoded. Has no effect on C<decode>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object.
  
  =head2 convert_blessed
  
      $json = $json->convert_blessed([$enable])
      
      $enabled = $json->get_convert_blessed
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context
  and the resulting scalar will be encoded instead of the object. If no
  C<TO_JSON> method is found, the value of C<allow_blessed> will decide what
  to do.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with the C<to_json>
  function or method.
  
  This setting does not yet influence C<decode> in any way.
  
  If C<$enable> is false, then the C<allow_blessed> setting will decide what
  to do when a blessed object is found.
  
  =head2 filter_json_object
  
      $json = $json->filter_json_object([$coderef])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument passed to the coderef
  is a reference to the newly-created hash. If the code references returns
  a single scalar (which need not be a reference), this value
  (i.e. a copy of that scalar to avoid aliasing) is inserted into the
  deserialised data structure. If it returns an empty list
  (NOTE: I<not> C<undef>, which is a valid scalar), the original deserialised
  hash will be inserted. This setting can slow down decoding considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialised hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = JSON::PP->new->filter_json_object (sub { 5 });
     # returns [5]
     $js->decode ('[{}]'); # the given subroutine takes a hash reference.
     # throw an exception because allow_nonref is not enabled
     # so a lone 5 is not allowed.
     $js->decode ('{"a":1, "b":2}');
  
  =head2 filter_json_single_key_object
  
      $json = $json->filter_json_single_key_object($key [=> $coderef])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialise Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialised Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     JSON::PP
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialisation to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  =head2 shrink
  
      $json = $json->shrink([$enable])
      
      $enabled = $json->get_shrink
  
  In JSON::XS, this flag resizes strings generated by either
  C<encode> or C<decode> to their minimum size possible.
  It will also try to downgrade any strings to octet-form if possible.
  
  In JSON::PP, it is noop about resizing strings but tries
  C<utf8::downgrade> to the returned string by C<encode>.
  See to L<utf8>.
  
  See to L<JSON::XS/OBJECT-ORIENTED INTERFACE>
  
  =head2 max_depth
  
      $json = $json->max_depth([$maximum_nesting_depth])
      
      $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  See L<JSON::XS/SSECURITY CONSIDERATIONS> for more info on why this is useful.
  
  When a large value (100 or more) was set and it de/encodes a deep nested object/text,
  it may raise a warning 'Deep recursion on subroutin' at the perl runtime phase.
  
  =head2 max_size
  
      $json = $json->max_size([$maximum_string_size])
      
      $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  See L<JSON::XS/SSECURITY CONSIDERATIONS> for more info on why this is useful.
  
  =head2 encode
  
      $json_text = $json->encode($perl_scalar)
  
  Converts the given Perl data structure (a simple scalar or a reference
  to a hash or array) to its JSON representation. Simple scalars will be
  converted into JSON string or number sequences, while references to arrays
  become JSON arrays and references to hashes become JSON objects. Undefined
  Perl values (e.g. C<undef>) become JSON C<null> values.
  References to the integers C<0> and C<1> are converted into C<true> and C<false>.
  
  =head2 decode
  
      $perl_scalar = $json->decode($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  JSON numbers and strings become simple Perl scalars. JSON arrays become
  Perl arrayrefs and JSON objects become Perl hashrefs. C<true> becomes
  C<1> (C<JSON::true>), C<false> becomes C<0> (C<JSON::false>) and
  C<null> becomes C<undef>.
  
  =head2 decode_prefix
  
      ($perl_scalar, $characters) = $json->decode_prefix($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
     JSON->new->decode_prefix ("[1] the tail")
     => ([], 3)
  
  =head1 INCREMENTAL PARSING
  
  Most of this section are copied and modified from L<JSON::XS/INCREMENTAL PARSING>.
  
  In some cases, there is the need for incremental parsing of JSON texts.
  This module does allow you to parse a JSON stream incrementally.
  It does so by accumulating text until it has a full JSON object, which
  it then can decode. This process is similar to using C<decode_prefix>
  to see if a full JSON object is available, but is much more efficient
  (and can be implemented with a minimum of method calls).
  
  This module will only attempt to parse the JSON text once it is sure it
  has enough text to get a decisive result, using a very simple but
  truly incremental parser. This means that it sometimes won't stop as
  early as the full parser, for example, it doesn't detect parenthese
  mismatches. The only thing it guarantees is that it starts decoding as
  soon as a syntactically valid JSON text has been seen. This means you need
  to set resource limits (e.g. C<max_size>) to ensure the parser will stop
  parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =head2 incr_parse
  
      $json->incr_parse( [$string] ) # void context
      
      $obj_or_undef = $json->incr_parse( [$string] ) # scalar context
      
      @obj_or_empty = $json->incr_parse( [$string] ) # list context
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the errornous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators between the JSON
  objects or arrays, instead they must be concatenated back-to-back. If
  an error occurs, an exception will be raised as in the scalar context
  case. Note that in this case, any previously-parsed JSON texts will be
  lost.
  
  Example: Parse some JSON arrays/objects in a given string and return them.
  
      my @objs = JSON->new->incr_parse ("[5][7][1,2]");
  
  =head2 incr_text
  
      $lvalue_string = $json->incr_text
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object. Under
  all other circumstances you must not call this function (I mean it.
  although in simple tests it might actually work, it I<will> fail under
  real world conditions). As a special exception, you can also call this
  method before having parsed anything.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
      $json->incr_text =~ s/\s*,\s*//;
  
  In Perl 5.005, C<lvalue> attribute is not available.
  You must write codes like the below:
  
      $string = $json->incr_text;
      $string =~ s/\s*,\s*//;
      $json->incr_text( $string );
  
  =head2 incr_skip
  
      $json->incr_skip
  
  This will reset the state of the incremental parser and will remove the
  parsed text from the input buffer. This is useful after C<incr_parse>
  died, in which case the input buffer and incremental parser state is left
  unchanged, to skip the text parsed so far and to reset the parse state.
  
  =head2 incr_reset
  
      $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want ot repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  See to L<JSON::XS/INCREMENTAL PARSING> for examples.
  
  
  =head1 JSON::PP OWN METHODS
  
  =head2 allow_singlequote
  
      $json = $json->allow_singlequote([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  JSON strings quoted by single quotations that are invalid JSON
  format.
  
      $json->allow_singlequote->decode({"foo":'bar'});
      $json->allow_singlequote->decode({'foo':"bar"});
      $json->allow_singlequote->decode({'foo':'bar'});
  
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
  
  =head2 allow_barekey
  
      $json = $json->allow_barekey([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  bare keys of JSON object that are invalid JSON format.
  
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
      $json->allow_barekey->decode('{foo:"bar"}');
  
  =head2 allow_bignum
  
      $json = $json->allow_bignum([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will convert
  the big integer Perl cannot handle as integer into a L<Math::BigInt>
  object and convert a floating number (any) into a L<Math::BigFloat>.
  
  On the contary, C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
  objects into JSON numbers with C<allow_blessed> enable.
  
     $json->allow_nonref->allow_blessed->allow_bignum;
     $bigfloat = $json->decode('2.000000000000000000000000001');
     print $json->encode($bigfloat);
     # => 2.000000000000000000000000001
  
  See to L<JSON::XS/MAPPING> aboout the normal conversion of JSON number.
  
  =head2 loose
  
      $json = $json->loose([$enable])
  
  The unescaped [\x00-\x1f\x22\x2f\x5c] strings are invalid in JSON strings
  and the module doesn't allow to C<decode> to these (except for \x2f).
  If C<$enable> is true (or missing), then C<decode>  will accept these
  unescaped strings.
  
      $json->loose->decode(qq|["abc
                                     def"]|);
  
  See L<JSON::XS/SSECURITY CONSIDERATIONS>.
  
  =head2 escape_slash
  
      $json = $json->escape_slash([$enable])
  
  According to JSON Grammar, I<slash> (U+002F) is escaped. But default
  JSON::PP (as same as JSON::XS) encodes strings without escaping slash.
  
  If C<$enable> is true (or missing), then C<encode> will escape slashes.
  
  =head2 indent_length
  
      $json = $json->indent_length($length)
  
  JSON::XS indent space length is 3 and cannot be changed.
  JSON::PP set the indent space length with the given $length.
  The default is 3. The acceptable range is 0 to 15.
  
  =head2 sort_by
  
      $json = $json->sort_by($function_name)
      $json = $json->sort_by($subroutine_ref)
  
  If $function_name or $subroutine_ref are set, its sort routine are used
  in encoding JSON objects.
  
     $js = $pc->sort_by(sub { $JSON::PP::a cmp $JSON::PP::b })->encode($obj);
     # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
  
     $js = $pc->sort_by('own_sort')->encode($obj);
     # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
  
     sub JSON::PP::own_sort { $JSON::PP::a cmp $JSON::PP::b }
  
  As the sorting routine runs in the JSON::PP scope, the given
  subroutine name and the special variables C<$a>, C<$b> will begin
  'JSON::PP::'.
  
  If $integer is set, then the effect is same as C<canonical> on.
  
  =head1 INTERNAL
  
  For developers.
  
  =over
  
  =item PP_encode_box
  
  Returns
  
          {
              depth        => $depth,
              indent_count => $indent_count,
          }
  
  
  =item PP_decode_box
  
  Returns
  
          {
              text    => $text,
              at      => $at,
              ch      => $ch,
              len     => $len,
              depth   => $depth,
              encoding      => $encoding,
              is_valid_utf8 => $is_valid_utf8,
          };
  
  =back
  
  =head1 MAPPING
  
  This section is copied from JSON::XS and modified to C<JSON::PP>.
  JSON::XS and JSON::PP mapping mechanisms are almost equivalent.
  
  See to L<JSON::XS/MAPPING>.
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserver object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, C<JSON> will try to represent
  it as an integer value. If that fails, it will try to represent it as
  a numeric (floating point) value if that is possible without loss of
  precision. Otherwise it will preserve the number as a string value (in
  which case you lose roundtripping ability, as the JSON number will be
  re-encoded toa JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values cannot
  represent most decimal fractions exactly, and when converting from and to
  floating point, C<JSON> only guarantees precision up to but not including
  the leats significant bit.
  
  When C<allow_bignum> is enable, the big integers 
  and the numeric can be optionally converted into L<Math::BigInt> and
  L<Math::BigFloat> objects.
  
  =item true, false
  
  These JSON atoms become C<JSON::PP::true> and C<JSON::PP::false>,
  respectively. They are overloaded to act almost exactly like the numbers
  C<1> and C<0>. You can check wether a scalar is a JSON boolean by using
  the C<JSON::is_bool> function.
  
     print JSON::PP::true . "\n";
      => true
     print JSON::PP::true + 1;
      => 1
  
     ok(JSON::true eq  '1');
     ok(JSON::true == 1);
  
  C<JSON> will install these missing overloading features to the backend modules.
  
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  C<JSON::PP::null> returns C<unddef>.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent ordering
  in hash keys (or JSON objects), they will usually be encoded in a
  pseudo-random order that can change between runs of the same program but
  stays generally the same within a single run of a program. C<JSON>
  optionally sort the hash keys (determined by the I<canonical> flag), so
  the same datastructure will serialise to the same JSON text (given same
  settings and version of JSON::XS), but this incurs a runtime overhead
  and is only rarely useful, e.g. when you want to compare some JSON text
  against another for equality.
  
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON. You can
  also use C<JSON::false> and C<JSON::true> to improve readability.
  
     to_json [\0,JSON::PP::true]      # yields [false,true]
  
  =item JSON::PP::true, JSON::PP::false, JSON::PP::null
  
  These special values become JSON true and JSON false values,
  respectively. You can also use C<\1> and C<\0> directly if you want.
  
  JSON::PP::null returns C<undef>.
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON. See the
  C<allow_blessed> and C<convert_blessed> methods on various options on
  how to deal with this: basically, you can choose between throwing an
  exception, encoding the reference as if it weren't blessed, or provide
  your own serialiser method.
  
  See to L<convert_blessed>.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: JSON::XS and JSON::PP will encode undefined scalars as
  JSON C<null> values, scalars that have last been used in a string context
  before encoding as JSON strings, and anything else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, so dump as string
     print $value;
     encode_json [$value]                 # yields ["5"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
  You can force the type to be a string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
  
  You can force the type to be a number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choise is yours.
  
  You can not currently force the type in other, less obscure, ways.
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and it is an
  error to pass those in.
  
  =item Big Number
  
  When C<allow_bignum> is enable, 
  C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
  objects into JSON numbers.
  
  
  =back
  
  =head1 UNICODE HANDLING ON PERLS
  
  If you do not know about Unicode on Perl well,
  please check L<JSON::XS/A FEW NOTES ON UNICODE AND PERL>.
  
  =head2 Perl 5.8 and later
  
  Perl can handle Unicode and the JSON::PP de/encode methods also work properly.
  
      $json->allow_nonref->encode(chr hex 3042);
      $json->allow_nonref->encode(chr hex 12345);
  
  Reuturns C<"\u3042"> and C<"\ud808\udf45"> respectively.
  
      $json->allow_nonref->decode('"\u3042"');
      $json->allow_nonref->decode('"\ud808\udf45"');
  
  Returns UTF-8 encoded strings with UTF8 flag, regarded as C<U+3042> and C<U+12345>.
  
  Note that the versions from Perl 5.8.0 to 5.8.2, Perl built-in C<join> was broken,
  so JSON::PP wraps the C<join> with a subroutine. Thus JSON::PP works slow in the versions.
  
  
  =head2 Perl 5.6
  
  Perl can handle Unicode and the JSON::PP de/encode methods also work.
  
  =head2 Perl 5.005
  
  Perl 5.005 is a byte sementics world -- all strings are sequences of bytes.
  That means the unicode handling is not available.
  
  In encoding,
  
      $json->allow_nonref->encode(chr hex 3042);  # hex 3042 is 12354.
      $json->allow_nonref->encode(chr hex 12345); # hex 12345 is 74565.
  
  Returns C<B> and C<E>, as C<chr> takes a value more than 255, it treats
  as C<$value % 256>, so the above codes are equivalent to :
  
      $json->allow_nonref->encode(chr 66);
      $json->allow_nonref->encode(chr 69);
  
  In decoding,
  
      $json->decode('"\u00e3\u0081\u0082"');
  
  The returned is a byte sequence C<0xE3 0x81 0x82> for UTF-8 encoded
  japanese character (C<HIRAGANA LETTER A>).
  And if it is represented in Unicode code point, C<U+3042>.
  
  Next, 
  
      $json->decode('"\u3042"');
  
  We ordinary expect the returned value is a Unicode character C<U+3042>.
  But here is 5.005 world. This is C<0xE3 0x81 0x82>.
  
      $json->decode('"\ud808\udf45"');
  
  This is not a character C<U+12345> but bytes - C<0xf0 0x92 0x8d 0x85>.
  
  
  =head1 TODO
  
  =over
  
  =item speed
  
  =item memory saving
  
  =back
  
  
  =head1 SEE ALSO
  
  Most of the document are copied and modified from JSON::XS doc.
  
  L<JSON::XS>
  
  RFC4627 (L<http://www.ietf.org/rfc/rfc4627.txt>)
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2013 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
JSON_PP

$fatpacked{"JSON/PP/Boolean.pm"} = <<'JSON_PP_BOOLEAN';
  =head1 NAME
  
  JSON::PP::Boolean - dummy module providing JSON::PP::Boolean
  
  =head1 SYNOPSIS
  
   # do not "use" yourself
  
  =head1 DESCRIPTION
  
  This module exists only to provide overload resolution for Storable and similar modules. See
  L<JSON::PP> for more info about this class.
  
  =cut
  
  use JSON::PP ();
  use strict;
  
  1;
  
  =head1 AUTHOR
  
  This idea is from L<JSON::XS::Boolean> written by Marc Lehmann <schmorp[at]schmorp.de>
  
  =cut
  
JSON_PP_BOOLEAN

$fatpacked{"LWP.pm"} = <<'LWP';
  package LWP;
  
  $VERSION = "6.05";
  sub Version { $VERSION; }
  
  require 5.008;
  require LWP::UserAgent;  # this should load everything you need
  
  1;
  
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  LWP - The World-Wide Web library for Perl
  
  =head1 SYNOPSIS
  
    use LWP;
    print "This is libwww-perl-$LWP::VERSION\n";
  
  
  =head1 DESCRIPTION
  
  The libwww-perl collection is a set of Perl modules which provides a
  simple and consistent application programming interface (API) to the
  World-Wide Web.  The main focus of the library is to provide classes
  and functions that allow you to write WWW clients. The library also
  contain modules that are of more general use and even classes that
  help you implement simple HTTP servers.
  
  Most modules in this library provide an object oriented API.  The user
  agent, requests sent and responses received from the WWW server are
  all represented by objects.  This makes a simple and powerful
  interface to these services.  The interface is easy to extend
  and customize for your own needs.
  
  The main features of the library are:
  
  =over 3
  
  =item *
  
  Contains various reusable components (modules) that can be
  used separately or together.
  
  =item *
  
  Provides an object oriented model of HTTP-style communication.  Within
  this framework we currently support access to http, https, gopher, ftp, news,
  file, and mailto resources.
  
  =item *
  
  Provides a full object oriented interface or
  a very simple procedural interface.
  
  =item *
  
  Supports the basic and digest authorization schemes.
  
  =item *
  
  Supports transparent redirect handling.
  
  =item *
  
  Supports access through proxy servers.
  
  =item *
  
  Provides parser for F<robots.txt> files and a framework for constructing robots.
  
  =item *
  
  Supports parsing of HTML forms.
  
  =item *
  
  Implements HTTP content negotiation algorithm that can
  be used both in protocol modules and in server scripts (like CGI
  scripts).
  
  =item *
  
  Supports HTTP cookies.
  
  =item *
  
  Some simple command line clients, for instance C<lwp-request> and C<lwp-download>.
  
  =back
  
  
  =head1 HTTP STYLE COMMUNICATION
  
  
  The libwww-perl library is based on HTTP style communication. This
  section tries to describe what that means.
  
  Let us start with this quote from the HTTP specification document
  <URL:http://www.w3.org/Protocols/>:
  
  =over 3
  
  =item
  
  The HTTP protocol is based on a request/response paradigm. A client
  establishes a connection with a server and sends a request to the
  server in the form of a request method, URI, and protocol version,
  followed by a MIME-like message containing request modifiers, client
  information, and possible body content. The server responds with a
  status line, including the message's protocol version and a success or
  error code, followed by a MIME-like message containing server
  information, entity meta-information, and possible body content.
  
  =back
  
  What this means to libwww-perl is that communication always take place
  through these steps: First a I<request> object is created and
  configured. This object is then passed to a server and we get a
  I<response> object in return that we can examine. A request is always
  independent of any previous requests, i.e. the service is stateless.
  The same simple model is used for any kind of service we want to
  access.
  
  For example, if we want to fetch a document from a remote file server,
  then we send it a request that contains a name for that document and
  the response will contain the document itself.  If we access a search
  engine, then the content of the request will contain the query
  parameters and the response will contain the query result.  If we want
  to send a mail message to somebody then we send a request object which
  contains our message to the mail server and the response object will
  contain an acknowledgment that tells us that the message has been
  accepted and will be forwarded to the recipient(s).
  
  It is as simple as that!
  
  
  =head2 The Request Object
  
  The libwww-perl request object has the class name C<HTTP::Request>.
  The fact that the class name uses C<HTTP::> as a
  prefix only implies that we use the HTTP model of communication.  It
  does not limit the kind of services we can try to pass this I<request>
  to.  For instance, we will send C<HTTP::Request>s both to ftp and
  gopher servers, as well as to the local file system.
  
  The main attributes of the request objects are:
  
  =over 3
  
  =item *
  
  B<method> is a short string that tells what kind of
  request this is.  The most common methods are B<GET>, B<PUT>,
  B<POST> and B<HEAD>.
  
  =item *
  
  B<uri> is a string denoting the protocol, server and
  the name of the "document" we want to access.  The B<uri> might
  also encode various other parameters.
  
  =item *
  
  B<headers> contains additional information about the
  request and can also used to describe the content.  The headers
  are a set of keyword/value pairs.
  
  =item *
  
  B<content> is an arbitrary amount of data.
  
  =back
  
  =head2 The Response Object
  
  The libwww-perl response object has the class name C<HTTP::Response>.
  The main attributes of objects of this class are:
  
  =over 3
  
  =item *
  
  B<code> is a numerical value that indicates the overall
  outcome of the request.
  
  =item *
  
  B<message> is a short, human readable string that
  corresponds to the I<code>.
  
  =item *
  
  B<headers> contains additional information about the
  response and describe the content.
  
  =item *
  
  B<content> is an arbitrary amount of data.
  
  =back
  
  Since we don't want to handle all possible I<code> values directly in
  our programs, a libwww-perl response object has methods that can be
  used to query what kind of response this is.  The most commonly used
  response classification methods are:
  
  =over 3
  
  =item is_success()
  
  The request was successfully received, understood or accepted.
  
  =item is_error()
  
  The request failed.  The server or the resource might not be
  available, access to the resource might be denied or other things might
  have failed for some reason.
  
  =back
  
  =head2 The User Agent
  
  Let us assume that we have created a I<request> object. What do we
  actually do with it in order to receive a I<response>?
  
  The answer is that you pass it to a I<user agent> object and this
  object takes care of all the things that need to be done
  (like low-level communication and error handling) and returns
  a I<response> object. The user agent represents your
  application on the network and provides you with an interface that
  can accept I<requests> and return I<responses>.
  
  The user agent is an interface layer between
  your application code and the network.  Through this interface you are
  able to access the various servers on the network.
  
  The class name for the user agent is C<LWP::UserAgent>.  Every
  libwww-perl application that wants to communicate should create at
  least one object of this class. The main method provided by this
  object is request(). This method takes an C<HTTP::Request> object as
  argument and (eventually) returns a C<HTTP::Response> object.
  
  The user agent has many other attributes that let you
  configure how it will interact with the network and with your
  application.
  
  =over 3
  
  =item *
  
  B<timeout> specifies how much time we give remote servers to
  respond before the library disconnects and creates an
  internal I<timeout> response.
  
  =item *
  
  B<agent> specifies the name that your application uses when it
  presents itself on the network.
  
  =item *
  
  B<from> can be set to the e-mail address of the person
  responsible for running the application.  If this is set, then the
  address will be sent to the servers with every request.
  
  =item *
  
  B<parse_head> specifies whether we should initialize response
  headers from the E<lt>head> section of HTML documents.
  
  =item *
  
  B<proxy> and B<no_proxy> specify if and when to go through
  a proxy server. <URL:http://www.w3.org/History/1994/WWW/Proxies/>
  
  =item *
  
  B<credentials> provides a way to set up user names and
  passwords needed to access certain services.
  
  =back
  
  Many applications want even more control over how they interact
  with the network and they get this by sub-classing
  C<LWP::UserAgent>.  The library includes a
  sub-class, C<LWP::RobotUA>, for robot applications.
  
  =head2 An Example
  
  This example shows how the user agent, a request and a response are
  represented in actual perl code:
  
    # Create a user agent object
    use LWP::UserAgent;
    my $ua = LWP::UserAgent->new;
    $ua->agent("MyApp/0.1 ");
  
    # Create a request
    my $req = HTTP::Request->new(POST => 'http://search.cpan.org/search');
    $req->content_type('application/x-www-form-urlencoded');
    $req->content('query=libwww-perl&mode=dist');
  
    # Pass request to the user agent and get a response back
    my $res = $ua->request($req);
  
    # Check the outcome of the response
    if ($res->is_success) {
        print $res->content;
    }
    else {
        print $res->status_line, "\n";
    }
  
  The $ua is created once when the application starts up.  New request
  objects should normally created for each request sent.
  
  
  =head1 NETWORK SUPPORT
  
  This section discusses the various protocol schemes and
  the HTTP style methods that headers may be used for each.
  
  For all requests, a "User-Agent" header is added and initialized from
  the $ua->agent attribute before the request is handed to the network
  layer.  In the same way, a "From" header is initialized from the
  $ua->from attribute.
  
  For all responses, the library adds a header called "Client-Date".
  This header holds the time when the response was received by
  your application.  The format and semantics of the header are the
  same as the server created "Date" header.  You may also encounter other
  "Client-XXX" headers.  They are all generated by the library
  internally and are not received from the servers.
  
  =head2 HTTP Requests
  
  HTTP requests are just handed off to an HTTP server and it
  decides what happens.  Few servers implement methods beside the usual
  "GET", "HEAD", "POST" and "PUT", but CGI-scripts may implement
  any method they like.
  
  If the server is not available then the library will generate an
  internal error response.
  
  The library automatically adds a "Host" and a "Content-Length" header
  to the HTTP request before it is sent over the network.
  
  For a GET request you might want to add a "If-Modified-Since" or
  "If-None-Match" header to make the request conditional.
  
  For a POST request you should add the "Content-Type" header.  When you
  try to emulate HTML E<lt>FORM> handling you should usually let the value
  of the "Content-Type" header be "application/x-www-form-urlencoded".
  See L<lwpcook> for examples of this.
  
  The libwww-perl HTTP implementation currently support the HTTP/1.1
  and HTTP/1.0 protocol.
  
  The library allows you to access proxy server through HTTP.  This
  means that you can set up the library to forward all types of request
  through the HTTP protocol module.  See L<LWP::UserAgent> for
  documentation of this.
  
  
  =head2 HTTPS Requests
  
  HTTPS requests are HTTP requests over an encrypted network connection
  using the SSL protocol developed by Netscape.  Everything about HTTP
  requests above also apply to HTTPS requests.  In addition the library
  will add the headers "Client-SSL-Cipher", "Client-SSL-Cert-Subject" and
  "Client-SSL-Cert-Issuer" to the response.  These headers denote the
  encryption method used and the name of the server owner.
  
  The request can contain the header "If-SSL-Cert-Subject" in order to
  make the request conditional on the content of the server certificate.
  If the certificate subject does not match, no request is sent to the
  server and an internally generated error response is returned.  The
  value of the "If-SSL-Cert-Subject" header is interpreted as a Perl
  regular expression.
  
  
  =head2 FTP Requests
  
  The library currently supports GET, HEAD and PUT requests.  GET
  retrieves a file or a directory listing from an FTP server.  PUT
  stores a file on a ftp server.
  
  You can specify a ftp account for servers that want this in addition
  to user name and password.  This is specified by including an "Account"
  header in the request.
  
  User name/password can be specified using basic authorization or be
  encoded in the URL.  Failed logins return an UNAUTHORIZED response with
  "WWW-Authenticate: Basic" and can be treated like basic authorization
  for HTTP.
  
  The library supports ftp ASCII transfer mode by specifying the "type=a"
  parameter in the URL. It also supports transfer of ranges for FTP transfers
  using the "Range" header.
  
  Directory listings are by default returned unprocessed (as returned
  from the ftp server) with the content media type reported to be
  "text/ftp-dir-listing". The C<File::Listing> module provides methods
  for parsing of these directory listing.
  
  The ftp module is also able to convert directory listings to HTML and
  this can be requested via the standard HTTP content negotiation
  mechanisms (add an "Accept: text/html" header in the request if you
  want this).
  
  For normal file retrievals, the "Content-Type" is guessed based on the
  file name suffix. See L<LWP::MediaTypes>.
  
  The "If-Modified-Since" request header works for servers that implement
  the MDTM command.  It will probably not work for directory listings though.
  
  Example:
  
    $req = HTTP::Request->new(GET => 'ftp://me:passwd@ftp.some.where.com/');
    $req->header(Accept => "text/html, */*;q=0.1");
  
  =head2 News Requests
  
  Access to the USENET News system is implemented through the NNTP
  protocol.  The name of the news server is obtained from the
  NNTP_SERVER environment variable and defaults to "news".  It is not
  possible to specify the hostname of the NNTP server in news: URLs.
  
  The library supports GET and HEAD to retrieve news articles through the
  NNTP protocol.  You can also post articles to newsgroups by using
  (surprise!) the POST method.
  
  GET on newsgroups is not implemented yet.
  
  Examples:
  
    $req = HTTP::Request->new(GET => 'news:abc1234@a.sn.no');
  
    $req = HTTP::Request->new(POST => 'news:comp.lang.perl.test');
    $req->header(Subject => 'This is a test',
                 From    => 'me@some.where.org');
    $req->content(<<EOT);
    This is the content of the message that we are sending to
    the world.
    EOT
  
  
  =head2 Gopher Request
  
  The library supports the GET and HEAD methods for gopher requests.  All
  request header values are ignored.  HEAD cheats and returns a
  response without even talking to server.
  
  Gopher menus are always converted to HTML.
  
  The response "Content-Type" is generated from the document type
  encoded (as the first letter) in the request URL path itself.
  
  Example:
  
    $req = HTTP::Request->new(GET => 'gopher://gopher.sn.no/');
  
  
  
  =head2 File Request
  
  The library supports GET and HEAD methods for file requests.  The
  "If-Modified-Since" header is supported.  All other headers are
  ignored.  The I<host> component of the file URL must be empty or set
  to "localhost".  Any other I<host> value will be treated as an error.
  
  Directories are always converted to an HTML document.  For normal
  files, the "Content-Type" and "Content-Encoding" in the response are
  guessed based on the file suffix.
  
  Example:
  
    $req = HTTP::Request->new(GET => 'file:/etc/passwd');
  
  
  =head2 Mailto Request
  
  You can send (aka "POST") mail messages using the library.  All
  headers specified for the request are passed on to the mail system.
  The "To" header is initialized from the mail address in the URL.
  
  Example:
  
    $req = HTTP::Request->new(POST => 'mailto:libwww@perl.org');
    $req->header(Subject => "subscribe");
    $req->content("Please subscribe me to the libwww-perl mailing list!\n");
  
  =head2 CPAN Requests
  
  URLs with scheme C<cpan:> are redirected to the a suitable CPAN
  mirror.  If you have your own local mirror of CPAN you might tell LWP
  to use it for C<cpan:> URLs by an assignment like this:
  
    $LWP::Protocol::cpan::CPAN = "file:/local/CPAN/";
  
  Suitable CPAN mirrors are also picked up from the configuration for
  the CPAN.pm, so if you have used that module a suitable mirror should
  be picked automatically.  If neither of these apply, then a redirect
  to the generic CPAN http location is issued.
  
  Example request to download the newest perl:
  
    $req = HTTP::Request->new(GET => "cpan:src/latest.tar.gz");
  
  
  =head1 OVERVIEW OF CLASSES AND PACKAGES
  
  This table should give you a quick overview of the classes provided by the
  library. Indentation shows class inheritance.
  
   LWP::MemberMixin   -- Access to member variables of Perl5 classes
     LWP::UserAgent   -- WWW user agent class
       LWP::RobotUA   -- When developing a robot applications
     LWP::Protocol          -- Interface to various protocol schemes
       LWP::Protocol::http  -- http:// access
       LWP::Protocol::file  -- file:// access
       LWP::Protocol::ftp   -- ftp:// access
       ...
  
   LWP::Authen::Basic -- Handle 401 and 407 responses
   LWP::Authen::Digest
  
   HTTP::Headers      -- MIME/RFC822 style header (used by HTTP::Message)
   HTTP::Message      -- HTTP style message
     HTTP::Request    -- HTTP request
     HTTP::Response   -- HTTP response
   HTTP::Daemon       -- A HTTP server class
  
   WWW::RobotRules    -- Parse robots.txt files
     WWW::RobotRules::AnyDBM_File -- Persistent RobotRules
  
   Net::HTTP          -- Low level HTTP client
  
  The following modules provide various functions and definitions.
  
   LWP                -- This file.  Library version number and documentation.
   LWP::MediaTypes    -- MIME types configuration (text/html etc.)
   LWP::Simple        -- Simplified procedural interface for common functions
   HTTP::Status       -- HTTP status code (200 OK etc)
   HTTP::Date         -- Date parsing module for HTTP date formats
   HTTP::Negotiate    -- HTTP content negotiation calculation
   File::Listing      -- Parse directory listings
   HTML::Form         -- Processing for <form>s in HTML documents
  
  
  =head1 MORE DOCUMENTATION
  
  All modules contain detailed information on the interfaces they
  provide.  The L<lwpcook> manpage is the libwww-perl cookbook that contain
  examples of typical usage of the library.  You might want to take a
  look at how the scripts L<lwp-request>, L<lwp-download>, L<lwp-dump>
  and L<lwp-mirror> are implemented.
  
  =head1 ENVIRONMENT
  
  The following environment variables are used by LWP:
  
  =over
  
  =item HOME
  
  The C<LWP::MediaTypes> functions will look for the F<.media.types> and
  F<.mime.types> files relative to you home directory.
  
  =item http_proxy
  
  =item ftp_proxy
  
  =item xxx_proxy
  
  =item no_proxy
  
  These environment variables can be set to enable communication through
  a proxy server.  See the description of the C<env_proxy> method in
  L<LWP::UserAgent>.
  
  =item PERL_LWP_ENV_PROXY
  
  If set to a TRUE value, then the C<LWP::UserAgent> will by default call
  C<env_proxy> during initialization.  This makes LWP honor the proxy variables
  described above.
  
  =item PERL_LWP_SSL_VERIFY_HOSTNAME
  
  The default C<verify_hostname> setting for C<LWP::UserAgent>.  If
  not set the default will be 1.  Set it as 0 to disable hostname
  verification (the default prior to libwww-perl 5.840.
  
  =item PERL_LWP_SSL_CA_FILE
  
  =item PERL_LWP_SSL_CA_PATH
  
  The file and/or directory
  where the trusted Certificate Authority certificates
  is located.  See L<LWP::UserAgent> for details.
  
  =item PERL_HTTP_URI_CLASS
  
  Used to decide what URI objects to instantiate.  The default is C<URI>.
  You might want to set it to C<URI::URL> for compatibility with old times.
  
  =back
  
  =head1 AUTHORS
  
  LWP was made possible by contributions from Adam Newby, Albert
  Dvornik, Alexandre Duret-Lutz, Andreas Gustafsson, Andreas Knig,
  Andrew Pimlott, Andy Lester, Ben Coleman, Benjamin Low, Ben Low, Ben
  Tilly, Blair Zajac, Bob Dalgleish, BooK, Brad Hughes, Brian
  J. Murrell, Brian McCauley, Charles C. Fu, Charles Lane, Chris Nandor,
  Christian Gilmore, Chris W. Unger, Craig Macdonald, Dale Couch, Dan
  Kubb, Dave Dunkin, Dave W. Smith, David Coppit, David Dick, David
  D. Kilzer, Doug MacEachern, Edward Avis, erik, Gary Shea, Gisle Aas,
  Graham Barr, Gurusamy Sarathy, Hans de Graaff, Harald Joerg, Harry
  Bochner, Hugo, Ilya Zakharevich, INOUE Yoshinari, Ivan Panchenko, Jack
  Shirazi, James Tillman, Jan Dubois, Jared Rhine, Jim Stern, Joao
  Lopes, John Klar, Johnny Lee, Josh Kronengold, Josh Rai, Joshua
  Chamas, Joshua Hoblitt, Kartik Subbarao, Keiichiro Nagano, Ken
  Williams, KONISHI Katsuhiro, Lee T Lindley, Liam Quinn, Marc Hedlund,
  Marc Langheinrich, Mark D. Anderson, Marko Asplund, Mark Stosberg,
  Markus B Krger, Markus Laker, Martijn Koster, Martin Thurn, Matthew
  Eldridge, Matthew.van.Eerde, Matt Sergeant, Michael A. Chase, Michael
  Quaranta, Michael Thompson, Mike Schilli, Moshe Kaminsky, Nathan
  Torkington, Nicolai Langfeldt, Norton Allen, Olly Betts, Paul
  J. Schinder, peterm, Philip GuentherDaniel Buenzli, Pon Hwa Lin,
  Radoslaw Zielinski, Radu Greab, Randal L. Schwartz, Richard Chen,
  Robin Barker, Roy Fielding, Sander van Zoest, Sean M. Burke,
  shildreth, Slaven Rezic, Steve A Fink, Steve Hay, Steven Butler,
  Steve_Kilbane, Takanori Ugai, Thomas Lotterer, Tim Bunce, Tom Hughes,
  Tony Finch, Ville Skytt, Ward Vandewege, William York, Yale Huang,
  and Yitzchak Scott-Thoennes.
  
  LWP owes a lot in motivation, design, and code, to the libwww-perl
  library for Perl4 by Roy Fielding, which included work from Alberto
  Accomazzi, James Casey, Brooks Cutter, Martijn Koster, Oscar
  Nierstrasz, Mel Melchner, Gertjan van Oosten, Jared Rhine, Jack
  Shirazi, Gene Spafford, Marc VanHeyningen, Steven E. Brenner, Marion
  Hakanson, Waldemar Kebsch, Tony Sanders, and Larry Wall; see the
  libwww-perl-0.40 library for details.
  
  =head1 COPYRIGHT
  
    Copyright 1995-2009, Gisle Aas
    Copyright 1995, Martijn Koster
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =head1 AVAILABILITY
  
  The latest version of this library is likely to be available from CPAN
  as well as:
  
    http://github.com/libwww-perl/libwww-perl
  
  The best place to discuss this code is on the <libwww@perl.org>
  mailing list.
  
  =cut
LWP

$fatpacked{"LWP/Authen/Basic.pm"} = <<'LWP_AUTHEN_BASIC';
  package LWP::Authen::Basic;
  use strict;
  
  require MIME::Base64;
  
  sub auth_header {
      my($class, $user, $pass) = @_;
      return "Basic " . MIME::Base64::encode("$user:$pass", "");
  }
  
  sub authenticate
  {
      my($class, $ua, $proxy, $auth_param, $response,
         $request, $arg, $size) = @_;
  
      my $realm = $auth_param->{realm} || "";
      my $url = $proxy ? $request->{proxy} : $request->uri_canonical;
      return $response unless $url;
      my $host_port = $url->host_port;
      my $auth_header = $proxy ? "Proxy-Authorization" : "Authorization";
  
      my @m = $proxy ? (m_proxy => $url) : (m_host_port => $host_port);
      push(@m, realm => $realm);
  
      my $h = $ua->get_my_handler("request_prepare", @m, sub {
          $_[0]{callback} = sub {
              my($req, $ua, $h) = @_;
              my($user, $pass) = $ua->credentials($host_port, $h->{realm});
  	    if (defined $user) {
  		my $auth_value = $class->auth_header($user, $pass, $req, $ua, $h);
  		$req->header($auth_header => $auth_value);
  	    }
          };
      });
      $h->{auth_param} = $auth_param;
  
      if (!$proxy && !$request->header($auth_header) && $ua->credentials($host_port, $realm)) {
  	# we can make sure this handler applies and retry
          add_path($h, $url->path);
          return $ua->request($request->clone, $arg, $size, $response);
      }
  
      my($user, $pass) = $ua->get_basic_credentials($realm, $url, $proxy);
      unless (defined $user and defined $pass) {
  	$ua->set_my_handler("request_prepare", undef, @m);  # delete handler
  	return $response;
      }
  
      # check that the password has changed
      my ($olduser, $oldpass) = $ua->credentials($host_port, $realm);
      return $response if (defined $olduser and defined $oldpass and
                           $user eq $olduser and $pass eq $oldpass);
  
      $ua->credentials($host_port, $realm, $user, $pass);
      add_path($h, $url->path) unless $proxy;
      return $ua->request($request->clone, $arg, $size, $response);
  }
  
  sub add_path {
      my($h, $path) = @_;
      $path =~ s,[^/]+\z,,;
      push(@{$h->{m_path_prefix}}, $path);
  }
  
  1;
LWP_AUTHEN_BASIC

$fatpacked{"LWP/Authen/Digest.pm"} = <<'LWP_AUTHEN_DIGEST';
  package LWP::Authen::Digest;
  
  use strict;
  use base 'LWP::Authen::Basic';
  
  require Digest::MD5;
  
  sub auth_header {
      my($class, $user, $pass, $request, $ua, $h) = @_;
  
      my $auth_param = $h->{auth_param};
  
      my $nc = sprintf "%08X", ++$ua->{authen_md5_nonce_count}{$auth_param->{nonce}};
      my $cnonce = sprintf "%8x", time;
  
      my $uri = $request->uri->path_query;
      $uri = "/" unless length $uri;
  
      my $md5 = Digest::MD5->new;
  
      my(@digest);
      $md5->add(join(":", $user, $auth_param->{realm}, $pass));
      push(@digest, $md5->hexdigest);
      $md5->reset;
  
      push(@digest, $auth_param->{nonce});
  
      if ($auth_param->{qop}) {
  	push(@digest, $nc, $cnonce, ($auth_param->{qop} =~ m|^auth[,;]auth-int$|) ? 'auth' : $auth_param->{qop});
      }
  
      $md5->add(join(":", $request->method, $uri));
      push(@digest, $md5->hexdigest);
      $md5->reset;
  
      $md5->add(join(":", @digest));
      my($digest) = $md5->hexdigest;
      $md5->reset;
  
      my %resp = map { $_ => $auth_param->{$_} } qw(realm nonce opaque);
      @resp{qw(username uri response algorithm)} = ($user, $uri, $digest, "MD5");
  
      if (($auth_param->{qop} || "") =~ m|^auth([,;]auth-int)?$|) {
  	@resp{qw(qop cnonce nc)} = ("auth", $cnonce, $nc);
      }
  
      my(@order) = qw(username realm qop algorithm uri nonce nc cnonce response);
      if($request->method =~ /^(?:POST|PUT)$/) {
  	$md5->add($request->content);
  	my $content = $md5->hexdigest;
  	$md5->reset;
  	$md5->add(join(":", @digest[0..1], $content));
  	$md5->reset;
  	$resp{"message-digest"} = $md5->hexdigest;
  	push(@order, "message-digest");
      }
      push(@order, "opaque");
      my @pairs;
      for (@order) {
  	next unless defined $resp{$_};
  	push(@pairs, "$_=" . qq("$resp{$_}"));
      }
  
      my $auth_value  = "Digest " . join(", ", @pairs);
      return $auth_value;
  }
  
  1;
LWP_AUTHEN_DIGEST

$fatpacked{"LWP/Authen/Ntlm.pm"} = <<'LWP_AUTHEN_NTLM';
  package LWP::Authen::Ntlm;
  
  use strict;
  use vars qw/$VERSION/;
  
  $VERSION = "6.00";
  
  use Authen::NTLM "1.02";
  use MIME::Base64 "2.12";
  
  sub authenticate {
      my($class, $ua, $proxy, $auth_param, $response,
         $request, $arg, $size) = @_;
  
      my($user, $pass) = $ua->get_basic_credentials($auth_param->{realm},
                                                    $request->uri, $proxy);
  
      unless(defined $user and defined $pass) {
  		return $response;
  	}
  
  	if (!$ua->conn_cache()) {
  		warn "The keep_alive option must be enabled for NTLM authentication to work.  NTLM authentication aborted.\n";
  		return $response;
  	}
  
  	my($domain, $username) = split(/\\/, $user);
  
  	ntlm_domain($domain);
  	ntlm_user($username);
  	ntlm_password($pass);
  
      my $auth_header = $proxy ? "Proxy-Authorization" : "Authorization";
  
  	# my ($challenge) = $response->header('WWW-Authenticate'); 
  	my $challenge;
  	foreach ($response->header('WWW-Authenticate')) { 
  		last if /^NTLM/ && ($challenge=$_);
  	}
  
  	if ($challenge eq 'NTLM') {
  		# First phase, send handshake
  	    my $auth_value = "NTLM " . ntlm();
  		ntlm_reset();
  
  	    # Need to check this isn't a repeated fail!
  	    my $r = $response;
  		my $retry_count = 0;
  	    while ($r) {
  			my $auth = $r->request->header($auth_header);
  			++$retry_count if ($auth && $auth eq $auth_value);
  			if ($retry_count > 2) {
  				    # here we know this failed before
  				    $response->header("Client-Warning" =>
  						      "Credentials for '$user' failed before");
  				    return $response;
  			}
  			$r = $r->previous;
  	    }
  
  	    my $referral = $request->clone;
  	    $referral->header($auth_header => $auth_value);
  	    return $ua->request($referral, $arg, $size, $response);
  	}
  	
  	else {
  		# Second phase, use the response challenge (unless non-401 code
  		#  was returned, in which case, we just send back the response
  		#  object, as is
  		my $auth_value;
  		if ($response->code ne '401') {
  			return $response;
  		}
  		else {
  			my $challenge;
  			foreach ($response->header('WWW-Authenticate')) { 
  				last if /^NTLM/ && ($challenge=$_);
  			}
  			$challenge =~ s/^NTLM //;
  			ntlm();
  			$auth_value = "NTLM " . ntlm($challenge);
  			ntlm_reset();
  		}
  
  	    my $referral = $request->clone;
  	    $referral->header($auth_header => $auth_value);
  	    my $response2 = $ua->request($referral, $arg, $size, $response);
  		return $response2;
  	}
  }
  
  1;
  
  
  =head1 NAME
  
  LWP::Authen::Ntlm - Library for enabling NTLM authentication (Microsoft) in LWP
  
  =head1 SYNOPSIS
  
   use LWP::UserAgent;
   use HTTP::Request::Common;
   my $url = 'http://www.company.com/protected_page.html';
  
   # Set up the ntlm client and then the base64 encoded ntlm handshake message
   my $ua = LWP::UserAgent->new(keep_alive=>1);
   $ua->credentials('www.company.com:80', '', "MyDomain\\MyUserCode", 'MyPassword');
  
   $request = GET $url;
   print "--Performing request now...-----------\n";
   $response = $ua->request($request);
   print "--Done with request-------------------\n";
  
   if ($response->is_success) {print "It worked!->" . $response->code . "\n"}
   else {print "It didn't work!->" . $response->code . "\n"}
  
  =head1 DESCRIPTION
  
  C<LWP::Authen::Ntlm> allows LWP to authenticate against servers that are using the 
  NTLM authentication scheme popularized by Microsoft.  This type of authentication is 
  common on intranets of Microsoft-centric organizations.
  
  The module takes advantage of the Authen::NTLM module by Mark Bush.  Since there 
  is also another Authen::NTLM module available from CPAN by Yee Man Chan with an 
  entirely different interface, it is necessary to ensure that you have the correct 
  NTLM module.
  
  In addition, there have been problems with incompatibilities between different 
  versions of Mime::Base64, which Bush's Authen::NTLM makes use of.  Therefore, it is 
  necessary to ensure that your Mime::Base64 module supports exporting of the 
  encode_base64 and decode_base64 functions.
  
  =head1 USAGE
  
  The module is used indirectly through LWP, rather than including it directly in your 
  code.  The LWP system will invoke the NTLM authentication when it encounters the 
  authentication scheme while attempting to retrieve a URL from a server.  In order 
  for the NTLM authentication to work, you must have a few things set up in your 
  code prior to attempting to retrieve the URL:
  
  =over 4
  
  =item *
  
  Enable persistent HTTP connections
  
  To do this, pass the "keep_alive=>1" option to the LWP::UserAgent when creating it, like this:
  
      my $ua = LWP::UserAgent->new(keep_alive=>1);
  
  =item *
  
  Set the credentials on the UserAgent object
  
  The credentials must be set like this:
  
     $ua->credentials('www.company.com:80', '', "MyDomain\\MyUserCode", 'MyPassword');
  
  Note that you cannot use the HTTP::Request object's authorization_basic() method to set 
  the credentials.  Note, too, that the 'www.company.com:80' portion only sets credentials 
  on the specified port AND it is case-sensitive (this is due to the way LWP is coded, and 
  has nothing to do with LWP::Authen::Ntlm)
  
  =back
  
  =head1 AVAILABILITY
  
  General queries regarding LWP should be made to the LWP Mailing List.
  
  Questions specific to LWP::Authen::Ntlm can be forwarded to jtillman@bigfoot.com
  
  =head1 COPYRIGHT
  
  Copyright (c) 2002 James Tillman. All rights reserved. This
  program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<LWP>, L<LWP::UserAgent>, L<lwpcook>.
LWP_AUTHEN_NTLM

$fatpacked{"LWP/ConnCache.pm"} = <<'LWP_CONNCACHE';
  package LWP::ConnCache;
  
  use strict;
  use vars qw($VERSION $DEBUG);
  
  $VERSION = "6.02";
  
  
  sub new {
      my($class, %cnf) = @_;
  
      my $total_capacity = 1;
      if (exists $cnf{total_capacity}) {
          $total_capacity = delete $cnf{total_capacity};
      }
      if (%cnf && $^W) {
  	require Carp;
  	Carp::carp("Unrecognised options: @{[sort keys %cnf]}")
      }
      my $self = bless { cc_conns => [] }, $class;
      $self->total_capacity($total_capacity);
      $self;
  }
  
  
  sub deposit {
      my($self, $type, $key, $conn) = @_;
      push(@{$self->{cc_conns}}, [$conn, $type, $key, time]);
      $self->enforce_limits($type);
      return;
  }
  
  
  sub withdraw {
      my($self, $type, $key) = @_;
      my $conns = $self->{cc_conns};
      for my $i (0 .. @$conns - 1) {
  	my $c = $conns->[$i];
  	next unless $c->[1] eq $type && $c->[2] eq $key;
  	splice(@$conns, $i, 1);  # remove it
  	return $c->[0];
      }
      return undef;
  }
  
  
  sub total_capacity {
      my $self = shift;
      my $old = $self->{cc_limit_total};
      if (@_) {
  	$self->{cc_limit_total} = shift;
  	$self->enforce_limits;
      }
      $old;
  }
  
  
  sub capacity {
      my $self = shift;
      my $type = shift;
      my $old = $self->{cc_limit}{$type};
      if (@_) {
  	$self->{cc_limit}{$type} = shift;
  	$self->enforce_limits($type);
      }
      $old;
  }
  
  
  sub enforce_limits {
      my($self, $type) = @_;
      my $conns = $self->{cc_conns};
  
      my @types = $type ? ($type) : ($self->get_types);
      for $type (@types) {
  	next unless $self->{cc_limit};
  	my $limit = $self->{cc_limit}{$type};
  	next unless defined $limit;
  	for my $i (reverse 0 .. @$conns - 1) {
  	    next unless $conns->[$i][1] eq $type;
  	    if (--$limit < 0) {
  		$self->dropping(splice(@$conns, $i, 1), "$type capacity exceeded");
  	    }
  	}
      }
  
      if (defined(my $total = $self->{cc_limit_total})) {
  	while (@$conns > $total) {
  	    $self->dropping(shift(@$conns), "Total capacity exceeded");
  	}
      }
  }
  
  
  sub dropping {
      my($self, $c, $reason) = @_;
      print "DROPPING @$c [$reason]\n" if $DEBUG;
  }
  
  
  sub drop {
      my($self, $checker, $reason) = @_;
      if (ref($checker) ne "CODE") {
  	# make it so
  	if (!defined $checker) {
  	    $checker = sub { 1 };  # drop all of them
  	}
  	elsif (_looks_like_number($checker)) {
  	    my $age_limit = $checker;
  	    my $time_limit = time - $age_limit;
  	    $reason ||= "older than $age_limit";
  	    $checker = sub { $_[3] < $time_limit };
  	}
  	else {
  	    my $type = $checker;
  	    $reason ||= "drop $type";
  	    $checker = sub { $_[1] eq $type };  # match on type
  	}
      }
      $reason ||= "drop";
  
      local $SIG{__DIE__};  # don't interfere with eval below
      local $@;
      my @c;
      for (@{$self->{cc_conns}}) {
  	my $drop;
  	eval {
  	    if (&$checker(@$_)) {
  		$self->dropping($_, $reason);
  		$drop++;
  	    }
  	};
  	push(@c, $_) unless $drop;
      }
      @{$self->{cc_conns}} = @c;
  }
  
  
  sub prune {
      my $self = shift;
      $self->drop(sub { !shift->ping }, "ping");
  }
  
  
  sub get_types {
      my $self = shift;
      my %t;
      $t{$_->[1]}++ for @{$self->{cc_conns}};
      return keys %t;
  }
  
  
  sub get_connections {
      my($self, $type) = @_;
      my @c;
      for (@{$self->{cc_conns}}) {
  	push(@c, $_->[0]) if !$type || ($type && $type eq $_->[1]);
      }
      @c;
  }
  
  
  sub _looks_like_number {
      $_[0] =~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/;
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  LWP::ConnCache - Connection cache manager
  
  =head1 NOTE
  
  This module is experimental.  Details of its interface is likely to
  change in the future.
  
  =head1 SYNOPSIS
  
   use LWP::ConnCache;
   my $cache = LWP::ConnCache->new;
   $cache->deposit($type, $key, $sock);
   $sock = $cache->withdraw($type, $key);
  
  =head1 DESCRIPTION
  
  The C<LWP::ConnCache> class is the standard connection cache manager
  for LWP::UserAgent.
  
  The following basic methods are provided:
  
  =over
  
  =item $cache = LWP::ConnCache->new( %options )
  
  This method constructs a new C<LWP::ConnCache> object.  The only
  option currently accepted is 'total_capacity'.  If specified it
  initialize the total_capacity option.  It defaults to the value 1.
  
  =item $cache->total_capacity( [$num_connections] )
  
  Get/sets the number of connection that will be cached.  Connections
  will start to be dropped when this limit is reached.  If set to C<0>,
  then all connections are immediately dropped.  If set to C<undef>,
  then there is no limit.
  
  =item $cache->capacity($type, [$num_connections] )
  
  Get/set a limit for the number of connections of the specified type
  that can be cached.  The $type will typically be a short string like
  "http" or "ftp".
  
  =item $cache->drop( [$checker, [$reason]] )
  
  Drop connections by some criteria.  The $checker argument is a
  subroutine that is called for each connection.  If the routine returns
  a TRUE value then the connection is dropped.  The routine is called
  with ($conn, $type, $key, $deposit_time) as arguments.
  
  Shortcuts: If the $checker argument is absent (or C<undef>) all cached
  connections are dropped.  If the $checker is a number then all
  connections untouched that the given number of seconds or more are
  dropped.  If $checker is a string then all connections of the given
  type are dropped.
  
  The $reason argument is passed on to the dropped() method.
  
  =item $cache->prune
  
  Calling this method will drop all connections that are dead.  This is
  tested by calling the ping() method on the connections.  If the ping()
  method exists and returns a FALSE value, then the connection is
  dropped.
  
  =item $cache->get_types
  
  This returns all the 'type' fields used for the currently cached
  connections.
  
  =item $cache->get_connections( [$type] )
  
  This returns all connection objects of the specified type.  If no type
  is specified then all connections are returned.  In scalar context the
  number of cached connections of the specified type is returned.
  
  =back
  
  
  The following methods are called by low-level protocol modules to
  try to save away connections and to get them back.
  
  =over
  
  =item $cache->deposit($type, $key, $conn)
  
  This method adds a new connection to the cache.  As a result other
  already cached connections might be dropped.  Multiple connections with
  the same $type/$key might added.
  
  =item $conn = $cache->withdraw($type, $key)
  
  This method tries to fetch back a connection that was previously
  deposited.  If no cached connection with the specified $type/$key is
  found, then C<undef> is returned.  There is not guarantee that a
  deposited connection can be withdrawn, as the cache manger is free to
  drop connections at any time.
  
  =back
  
  The following methods are called internally.  Subclasses might want to
  override them.
  
  =over
  
  =item $conn->enforce_limits([$type])
  
  This method is called with after a new connection is added (deposited)
  in the cache or capacity limits are adjusted.  The default
  implementation drops connections until the specified capacity limits
  are not exceeded.
  
  =item $conn->dropping($conn_record, $reason)
  
  This method is called when a connection is dropped.  The record
  belonging to the dropped connection is passed as the first argument
  and a string describing the reason for the drop is passed as the
  second argument.  The default implementation makes some noise if the
  $LWP::ConnCache::DEBUG variable is set and nothing more.
  
  =back
  
  =head1 SUBCLASSING
  
  For specialized cache policy it makes sense to subclass
  C<LWP::ConnCache> and perhaps override the deposit(), enforce_limits()
  and dropping() methods.
  
  The object itself is a hash.  Keys prefixed with C<cc_> are reserved
  for the base class.
  
  =head1 SEE ALSO
  
  L<LWP::UserAgent>
  
  =head1 COPYRIGHT
  
  Copyright 2001 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
LWP_CONNCACHE

$fatpacked{"LWP/Debug.pm"} = <<'LWP_DEBUG';
  package LWP::Debug;  # legacy
  
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT_OK = qw(level trace debug conns);
  
  use Carp ();
  
  my @levels = qw(trace debug conns);
  %current_level = ();
  
  
  sub import
  {
      my $pack = shift;
      my $callpkg = caller(0);
      my @symbols = ();
      my @levels = ();
      for (@_) {
  	if (/^[-+]/) {
  	    push(@levels, $_);
  	}
  	else {
  	    push(@symbols, $_);
  	}
      }
      Exporter::export($pack, $callpkg, @symbols);
      level(@levels);
  }
  
  
  sub level
  {
      for (@_) {
  	if ($_ eq '+') {              # all on
  	    # switch on all levels
  	    %current_level = map { $_ => 1 } @levels;
  	}
  	elsif ($_ eq '-') {           # all off
  	    %current_level = ();
  	}
  	elsif (/^([-+])(\w+)$/) {
  	    $current_level{$2} = $1 eq '+';
  	}
  	else {
  	    Carp::croak("Illegal level format $_");
  	}
      }
  }
  
  
  sub trace  { _log(@_) if $current_level{'trace'}; }
  sub debug  { _log(@_) if $current_level{'debug'}; }
  sub conns  { _log(@_) if $current_level{'conns'}; }
  
  
  sub _log
  {
      my $msg = shift;
      $msg .= "\n" unless $msg =~ /\n$/;  # ensure trailing "\n"
  
      my($package,$filename,$line,$sub) = caller(2);
      print STDERR "$sub: $msg";
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  LWP::Debug - deprecated
  
  =head1 DESCRIPTION
  
  LWP::Debug used to provide tracing facilities, but these are not used
  by LWP any more.  The code in this module is kept around
  (undocumented) so that 3rd party code that happen to use the old
  interfaces continue to run.
  
  One useful feature that LWP::Debug provided (in an imprecise and
  troublesome way) was network traffic monitoring.  The following
  section provide some hints about recommened replacements.
  
  =head2 Network traffic monitoring
  
  The best way to monitor the network traffic that LWP generates is to
  use an external TCP monitoring program.  The Wireshark program
  (L<http://www.wireshark.org/>) is higly recommended for this.
  
  Another approach it to use a debugging HTTP proxy server and make
  LWP direct all its traffic via this one.  Call C<< $ua->proxy >> to
  set it up and then just use LWP as before.
  
  For less precise monitoring needs just setting up a few simple
  handlers might do.  The following example sets up handlers to dump the
  request and response objects that pass through LWP:
  
    use LWP::UserAgent;
    $ua = LWP::UserAgent->new;
    $ua->default_header('Accept-Encoding' => scalar HTTP::Message::decodable());
  
    $ua->add_handler("request_send",  sub { shift->dump; return });
    $ua->add_handler("response_done", sub { shift->dump; return });
  
    $ua->get("http://www.example.com");
  
  =head1 SEE ALSO
  
  L<LWP::UserAgent>
LWP_DEBUG

$fatpacked{"LWP/DebugFile.pm"} = <<'LWP_DEBUGFILE';
  package LWP::DebugFile;
  
  # legacy stub
  
  1;
LWP_DEBUGFILE

$fatpacked{"LWP/MediaTypes.pm"} = <<'LWP_MEDIATYPES';
  package LWP::MediaTypes;
  
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(guess_media_type media_suffix);
  @EXPORT_OK = qw(add_type add_encoding read_media_types);
  $VERSION = "6.02";
  
  use strict;
  
  # note: These hashes will also be filled with the entries found in
  # the 'media.types' file.
  
  my %suffixType = (
      'txt'   => 'text/plain',
      'html'  => 'text/html',
      'gif'   => 'image/gif',
      'jpg'   => 'image/jpeg',
      'xml'   => 'text/xml',
  );
  
  my %suffixExt = (
      'text/plain' => 'txt',
      'text/html'  => 'html',
      'image/gif'  => 'gif',
      'image/jpeg' => 'jpg',
      'text/xml'   => 'xml',
  );
  
  #XXX: there should be some way to define this in the media.types files.
  my %suffixEncoding = (
      'Z'   => 'compress',
      'gz'  => 'gzip',
      'hqx' => 'x-hqx',
      'uu'  => 'x-uuencode',
      'z'   => 'x-pack',
      'bz2' => 'x-bzip2',
  );
  
  read_media_types();
  
  
  
  sub guess_media_type
  {
      my($file, $header) = @_;
      return undef unless defined $file;
  
      my $fullname;
      if (ref($file)) {
  	# assume URI object
  	$file = $file->path;
  	#XXX should handle non http:, file: or ftp: URIs differently
      }
      else {
  	$fullname = $file;  # enable peek at actual file
      }
  
      my @encoding = ();
      my $ct = undef;
      for (file_exts($file)) {
  	# first check this dot part as encoding spec
  	if (exists $suffixEncoding{$_}) {
  	    unshift(@encoding, $suffixEncoding{$_});
  	    next;
  	}
  	if (exists $suffixEncoding{lc $_}) {
  	    unshift(@encoding, $suffixEncoding{lc $_});
  	    next;
  	}
  
  	# check content-type
  	if (exists $suffixType{$_}) {
  	    $ct = $suffixType{$_};
  	    last;
  	}
  	if (exists $suffixType{lc $_}) {
  	    $ct = $suffixType{lc $_};
  	    last;
  	}
  
  	# don't know nothing about this dot part, bail out
  	last;
      }
      unless (defined $ct) {
  	# Take a look at the file
  	if (defined $fullname) {
  	    $ct = (-T $fullname) ? "text/plain" : "application/octet-stream";
  	}
  	else {
  	    $ct = "application/octet-stream";
  	}
      }
  
      if ($header) {
  	$header->header('Content-Type' => $ct);
  	$header->header('Content-Encoding' => \@encoding) if @encoding;
      }
  
      wantarray ? ($ct, @encoding) : $ct;
  }
  
  
  sub media_suffix {
      if (!wantarray && @_ == 1 && $_[0] !~ /\*/) {
  	return $suffixExt{lc $_[0]};
      }
      my(@type) = @_;
      my(@suffix, $ext, $type);
      foreach (@type) {
  	if (s/\*/.*/) {
  	    while(($ext,$type) = each(%suffixType)) {
  		push(@suffix, $ext) if $type =~ /^$_$/i;
  	    }
  	}
  	else {
  	    my $ltype = lc $_;
  	    while(($ext,$type) = each(%suffixType)) {
  		push(@suffix, $ext) if lc $type eq $ltype;
  	    }
  	}
      }
      wantarray ? @suffix : $suffix[0];
  }
  
  
  sub file_exts 
  {
      require File::Basename;
      my @parts = reverse split(/\./, File::Basename::basename($_[0]));
      pop(@parts);        # never consider first part
      @parts;
  }
  
  
  sub add_type 
  {
      my($type, @exts) = @_;
      for my $ext (@exts) {
  	$ext =~ s/^\.//;
  	$suffixType{$ext} = $type;
      }
      $suffixExt{lc $type} = $exts[0] if @exts;
  }
  
  
  sub add_encoding
  {
      my($type, @exts) = @_;
      for my $ext (@exts) {
  	$ext =~ s/^\.//;
  	$suffixEncoding{$ext} = $type;
      }
  }
  
  
  sub read_media_types 
  {
      my(@files) = @_;
  
      local($/, $_) = ("\n", undef);  # ensure correct $INPUT_RECORD_SEPARATOR
  
      my @priv_files = ();
      push(@priv_files, "$ENV{HOME}/.media.types", "$ENV{HOME}/.mime.types")
  	if defined $ENV{HOME};  # Some doesn't have a home (for instance Win32)
  
      # Try to locate "media.types" file, and initialize %suffixType from it
      my $typefile;
      unless (@files) {
  	@files = map {"$_/LWP/media.types"} @INC;
  	push @files, @priv_files;
      }
      for $typefile (@files) {
  	local(*TYPE);
  	open(TYPE, $typefile) || next;
  	while (<TYPE>) {
  	    next if /^\s*#/; # comment line
  	    next if /^\s*$/; # blank line
  	    s/#.*//;         # remove end-of-line comments
  	    my($type, @exts) = split(' ', $_);
  	    add_type($type, @exts);
  	}
  	close(TYPE);
      }
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  LWP::MediaTypes - guess media type for a file or a URL
  
  =head1 SYNOPSIS
  
   use LWP::MediaTypes qw(guess_media_type);
   $type = guess_media_type("/tmp/foo.gif");
  
  =head1 DESCRIPTION
  
  This module provides functions for handling media (also known as
  MIME) types and encodings.  The mapping from file extensions to media
  types is defined by the F<media.types> file.  If the F<~/.media.types>
  file exists it is used instead.
  For backwards compatibility we will also look for F<~/.mime.types>.
  
  The following functions are exported by default:
  
  =over 4
  
  =item guess_media_type( $filename )
  
  =item guess_media_type( $uri )
  
  =item guess_media_type( $filename_or_uri, $header_to_modify )
  
  This function tries to guess media type and encoding for a file or a URI.
  It returns the content type, which is a string like C<"text/html">.
  In array context it also returns any content encodings applied (in the
  order used to encode the file).  You can pass a URI object
  reference, instead of the file name.
  
  If the type can not be deduced from looking at the file name,
  then guess_media_type() will let the C<-T> Perl operator take a look.
  If this works (and C<-T> returns a TRUE value) then we return
  I<text/plain> as the type, otherwise we return
  I<application/octet-stream> as the type.
  
  The optional second argument should be a reference to a HTTP::Headers
  object or any object that implements the $obj->header method in a
  similar way.  When it is present the values of the
  'Content-Type' and 'Content-Encoding' will be set for this header.
  
  =item media_suffix( $type, ... )
  
  This function will return all suffixes that can be used to denote the
  specified media type(s).  Wildcard types can be used.  In a scalar
  context it will return the first suffix found. Examples:
  
    @suffixes = media_suffix('image/*', 'audio/basic');
    $suffix = media_suffix('text/html');
  
  =back
  
  The following functions are only exported by explicit request:
  
  =over 4
  
  =item add_type( $type, @exts )
  
  Associate a list of file extensions with the given media type.
  Example:
  
      add_type("x-world/x-vrml" => qw(wrl vrml));
  
  =item add_encoding( $type, @ext )
  
  Associate a list of file extensions with an encoding type.
  Example:
  
   add_encoding("x-gzip" => "gz");
  
  =item read_media_types( @files )
  
  Parse media types files and add the type mappings found there.
  Example:
  
      read_media_types("conf/mime.types");
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 1995-1999 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
LWP_MEDIATYPES

$fatpacked{"LWP/MemberMixin.pm"} = <<'LWP_MEMBERMIXIN';
  package LWP::MemberMixin;
  
  sub _elem
  {
      my $self = shift;
      my $elem = shift;
      my $old = $self->{$elem};
      $self->{$elem} = shift if @_;
      return $old;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  LWP::MemberMixin - Member access mixin class
  
  =head1 SYNOPSIS
  
   package Foo;
   require LWP::MemberMixin;
   @ISA=qw(LWP::MemberMixin);
  
  =head1 DESCRIPTION
  
  A mixin class to get methods that provide easy access to member
  variables in the %$self.
  Ideally there should be better Perl language support for this.
  
  There is only one method provided:
  
  =over 4
  
  =item _elem($elem [, $val])
  
  Internal method to get/set the value of member variable
  C<$elem>. If C<$val> is present it is used as the new value
  for the member variable.  If it is not present the current
  value is not touched. In both cases the previous value of
  the member variable is returned.
  
  =back
LWP_MEMBERMIXIN

$fatpacked{"LWP/Protocol.pm"} = <<'LWP_PROTOCOL';
  package LWP::Protocol;
  
  require LWP::MemberMixin;
  @ISA = qw(LWP::MemberMixin);
  $VERSION = "6.00";
  
  use strict;
  use Carp ();
  use HTTP::Status ();
  use HTTP::Response;
  
  my %ImplementedBy = (); # scheme => classname
  
  
  
  sub new
  {
      my($class, $scheme, $ua) = @_;
  
      my $self = bless {
  	scheme => $scheme,
  	ua => $ua,
  
  	# historical/redundant
          max_size => $ua->{max_size},
      }, $class;
  
      $self;
  }
  
  
  sub create
  {
      my($scheme, $ua) = @_;
      my $impclass = LWP::Protocol::implementor($scheme) or
  	Carp::croak("Protocol scheme '$scheme' is not supported");
  
      # hand-off to scheme specific implementation sub-class
      my $protocol = $impclass->new($scheme, $ua);
  
      return $protocol;
  }
  
  
  sub implementor
  {
      my($scheme, $impclass) = @_;
  
      if ($impclass) {
  	$ImplementedBy{$scheme} = $impclass;
      }
      my $ic = $ImplementedBy{$scheme};
      return $ic if $ic;
  
      return '' unless $scheme =~ /^([.+\-\w]+)$/;  # check valid URL schemes
      $scheme = $1; # untaint
      $scheme =~ s/[.+\-]/_/g;  # make it a legal module name
  
      # scheme not yet known, look for a 'use'd implementation
      $ic = "LWP::Protocol::$scheme";  # default location
      $ic = "LWP::Protocol::nntp" if $scheme eq 'news'; #XXX ugly hack
      no strict 'refs';
      # check we actually have one for the scheme:
      unless (@{"${ic}::ISA"}) {
  	# try to autoload it
  	eval "require $ic";
  	if ($@) {
  	    if ($@ =~ /Can't locate/) { #' #emacs get confused by '
  		$ic = '';
  	    }
  	    else {
  		die "$@\n";
  	    }
  	}
      }
      $ImplementedBy{$scheme} = $ic if $ic;
      $ic;
  }
  
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
      Carp::croak('LWP::Protocol::request() needs to be overridden in subclasses');
  }
  
  
  # legacy
  sub timeout    { shift->_elem('timeout',    @_); }
  sub max_size   { shift->_elem('max_size',   @_); }
  
  
  sub collect
  {
      my ($self, $arg, $response, $collector) = @_;
      my $content;
      my($ua, $max_size) = @{$self}{qw(ua max_size)};
  
      eval {
  	local $\; # protect the print below from surprises
          if (!defined($arg) || !$response->is_success) {
              $response->{default_add_content} = 1;
          }
          elsif (!ref($arg) && length($arg)) {
              open(my $fh, ">", $arg) or die "Can't write to '$arg': $!";
  	    binmode($fh);
              push(@{$response->{handlers}{response_data}}, {
                  callback => sub {
                      print $fh $_[3] or die "Can't write to '$arg': $!";
                      1;
                  },
              });
              push(@{$response->{handlers}{response_done}}, {
                  callback => sub {
  		    close($fh) or die "Can't write to '$arg': $!";
  		    undef($fh);
  		},
  	    });
          }
          elsif (ref($arg) eq 'CODE') {
              push(@{$response->{handlers}{response_data}}, {
                  callback => sub {
  		    &$arg($_[3], $_[0], $self);
  		    1;
                  },
              });
          }
          else {
              die "Unexpected collect argument '$arg'";
          }
  
          $ua->run_handlers("response_header", $response);
  
          if (delete $response->{default_add_content}) {
              push(@{$response->{handlers}{response_data}}, {
  		callback => sub {
  		    $_[0]->add_content($_[3]);
  		    1;
  		},
  	    });
          }
  
  
          my $content_size = 0;
          my $length = $response->content_length;
          my %skip_h;
  
          while ($content = &$collector, length $$content) {
              for my $h ($ua->handlers("response_data", $response)) {
                  next if $skip_h{$h};
                  unless ($h->{callback}->($response, $ua, $h, $$content)) {
                      # XXX remove from $response->{handlers}{response_data} if present
                      $skip_h{$h}++;
                  }
              }
              $content_size += length($$content);
              $ua->progress(($length ? ($content_size / $length) : "tick"), $response);
              if (defined($max_size) && $content_size > $max_size) {
                  $response->push_header("Client-Aborted", "max_size");
                  last;
              }
          }
      };
      my $err = $@;
      delete $response->{handlers}{response_data};
      delete $response->{handlers} unless %{$response->{handlers}};
      if ($err) {
          chomp($err);
          $response->push_header('X-Died' => $err);
          $response->push_header("Client-Aborted", "die");
          return $response;
      }
  
      return $response;
  }
  
  
  sub collect_once
  {
      my($self, $arg, $response) = @_;
      my $content = \ $_[3];
      my $first = 1;
      $self->collect($arg, $response, sub {
  	return $content if $first--;
  	return \ "";
      });
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  LWP::Protocol - Base class for LWP protocols
  
  =head1 SYNOPSIS
  
   package LWP::Protocol::foo;
   require LWP::Protocol;
   @ISA=qw(LWP::Protocol);
  
  =head1 DESCRIPTION
  
  This class is used a the base class for all protocol implementations
  supported by the LWP library.
  
  When creating an instance of this class using
  C<LWP::Protocol::create($url)>, and you get an initialised subclass
  appropriate for that access method. In other words, the
  LWP::Protocol::create() function calls the constructor for one of its
  subclasses.
  
  All derived LWP::Protocol classes need to override the request()
  method which is used to service a request. The overridden method can
  make use of the collect() function to collect together chunks of data
  as it is received.
  
  The following methods and functions are provided:
  
  =over 4
  
  =item $prot = LWP::Protocol->new()
  
  The LWP::Protocol constructor is inherited by subclasses. As this is a
  virtual base class this method should B<not> be called directly.
  
  =item $prot = LWP::Protocol::create($scheme)
  
  Create an object of the class implementing the protocol to handle the
  given scheme. This is a function, not a method. It is more an object
  factory than a constructor. This is the function user agents should
  use to access protocols.
  
  =item $class = LWP::Protocol::implementor($scheme, [$class])
  
  Get and/or set implementor class for a scheme.  Returns '' if the
  specified scheme is not supported.
  
  =item $prot->request(...)
  
   $response = $protocol->request($request, $proxy, undef);
   $response = $protocol->request($request, $proxy, '/tmp/sss');
   $response = $protocol->request($request, $proxy, \&callback, 1024);
  
  Dispatches a request over the protocol, and returns a response
  object. This method needs to be overridden in subclasses.  Refer to
  L<LWP::UserAgent> for description of the arguments.
  
  =item $prot->collect($arg, $response, $collector)
  
  Called to collect the content of a request, and process it
  appropriately into a scalar, file, or by calling a callback.  If $arg
  is undefined, then the content is stored within the $response.  If
  $arg is a simple scalar, then $arg is interpreted as a file name and
  the content is written to this file.  If $arg is a reference to a
  routine, then content is passed to this routine.
  
  The $collector is a routine that will be called and which is
  responsible for returning pieces (as ref to scalar) of the content to
  process.  The $collector signals EOF by returning a reference to an
  empty sting.
  
  The return value from collect() is the $response object reference.
  
  B<Note:> We will only use the callback or file argument if
  $response->is_success().  This avoids sending content data for
  redirects and authentication responses to the callback which would be
  confusing.
  
  =item $prot->collect_once($arg, $response, $content)
  
  Can be called when the whole response content is available as
  $content.  This will invoke collect() with a collector callback that
  returns a reference to $content the first time and an empty string the
  next.
  
  =back
  
  =head1 SEE ALSO
  
  Inspect the F<LWP/Protocol/file.pm> and F<LWP/Protocol/http.pm> files
  for examples of usage.
  
  =head1 COPYRIGHT
  
  Copyright 1995-2001 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
LWP_PROTOCOL

$fatpacked{"LWP/Protocol/GHTTP.pm"} = <<'LWP_PROTOCOL_GHTTP';
  package LWP::Protocol::GHTTP;
  
  # You can tell LWP to use this module for 'http' requests by running
  # code like this before you make requests:
  #
  #    require LWP::Protocol::GHTTP;
  #    LWP::Protocol::implementor('http', 'LWP::Protocol::GHTTP');
  #
  
  use strict;
  use vars qw(@ISA);
  
  require LWP::Protocol;
  @ISA=qw(LWP::Protocol);
  
  require HTTP::Response;
  require HTTP::Status;
  
  use HTTP::GHTTP qw(METHOD_GET METHOD_HEAD METHOD_POST);
  
  my %METHOD =
  (
   GET  => METHOD_GET,
   HEAD => METHOD_HEAD,
   POST => METHOD_POST,
  );
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      my $method = $request->method;
      unless (exists $METHOD{$method}) {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   "Bad method '$method'");
      }
  
      my $r = HTTP::GHTTP->new($request->uri);
  
      # XXX what headers for repeated headers here?
      $request->headers->scan(sub { $r->set_header(@_)});
  
      $r->set_type($METHOD{$method});
  
      # XXX should also deal with subroutine content.
      my $cref = $request->content_ref;
      $r->set_body($$cref) if length($$cref);
  
      # XXX is this right
      $r->set_proxy($proxy->as_string) if $proxy;
  
      $r->process_request;
  
      my $response = HTTP::Response->new($r->get_status);
  
      # XXX How can get the headers out of $r??  This way is too stupid.
      my @headers;
      eval {
  	# Wrapped in eval because this method is not always available
  	@headers = $r->get_headers;
      };
      @headers = qw(Date Connection Server Content-type
                    Accept-Ranges Server
                    Content-Length Last-Modified ETag) if $@;
      for (@headers) {
  	my $v = $r->get_header($_);
  	$response->header($_ => $v) if defined $v;
      }
  
      return $self->collect_once($arg, $response, $r->get_body);
  }
  
  1;
LWP_PROTOCOL_GHTTP

$fatpacked{"LWP/Protocol/connect.pm"} = <<'LWP_PROTOCOL_CONNECT';
  package LWP::Protocol::connect;
  
  use warnings;
  use strict;
  
  our $VERSION = '6.09'; # VERSION
  
  require LWP::Protocol;
  our @ISA = qw(LWP::Protocol);
  
  our @supported_schemes = ( 'https', 'http' );
  
  sub request {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
      my $url = $request->uri;
      my $scheme = $url->scheme;
  
      if(!defined $proxy) {
  	    return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  		    'HTTP/CONNECT method protocol schema can only be used with a proxy!');
      }
  
      if( ! grep { $scheme eq $_ } @supported_schemes ) {
  	    return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  		    $scheme.' protocol scheme is not supported by '. __PACKAGE__ );
      }
  
      my $connect_scheme = $scheme."::connect";
      my $socket_scheme = $connect_scheme."::Socket";
  
      for my $scheme ( $connect_scheme, $socket_scheme ) {
          eval 'require LWP::Protocol::'.$scheme; ## no critic
  	if( $@ ) {
  	    return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  		    'could not load '.$connect_scheme.' protocol support: '.$@);
  	}
      }
  
      my $protocol = LWP::Protocol::create($connect_scheme, $self->{ua});
      $protocol->{proxy_connect_opts} = [
      	ProxyAddr => $proxy->host,
  	ProxyPort => $proxy->port,
  	ProxyUserinfo => $proxy->userinfo,
  	Agent => $self->{ua},
      ];
  
      $protocol->request($request, undef, $arg, $size, $timeout);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  LWP::Protocol::connect - Provides HTTP/CONNECT proxy support for LWP::UserAgent
  
  =head1 SYNOPSIS
  
    use LWP::UserAgent;
  
    $ua = LWP::UserAgent->new(); 
    $ua->proxy('https', 'connect://proxyhost.domain:3128/');
  
    $ua->get('https://www.somesslsite.com');
  
  =head1 Proxy Authentication
  
  If you pass the authentication within the userinfo string of the proxy url
  a Basic authentication header will always be generated and sent to the proxy.
  
    $ua->proxy('https', 'connect://user:pw@proxyhost.domain:3128');
  
  The more general way is to add the credentials of the proxy to the $ua object.
  
    $ua->credentials("localhost:3128", "Squid proxy-caching web server", "user", "pw");
  
  In this case the first request to the proxy will fail with a "407 Proxy Auth. Required".
  This will cause LWP::UserAgent to choose the right LWP::Authen::<method> module to
  add the authentication and retry.
  
  =head1 DESCRIPTION
  
  The LWP::Protocol::connect module provides support for using https over
  a proxy via the HTTP/CONNECT method.
  
  =head1 SEE ALSO
  
  L<IO::Socket::SSL>, L<LWP::Protocol::https>
  
  =head1 COPYRIGHT
  
  Copyright 2013 Markus Benning <me@w3r3wolf.de>
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
LWP_PROTOCOL_CONNECT

$fatpacked{"LWP/Protocol/connect/Socket/Base.pm"} = <<'LWP_PROTOCOL_CONNECT_SOCKET_BASE';
  package LWP::Protocol::connect::Socket::Base;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.09'; # VERSION
  
  use LWP::UserAgent;
  use HTTP::Request;
  
  sub new {
      my $class = shift;
      my %args = @_;
      my $conn = $class->_proxy_connect( \%args );
      bless $conn, $class;
      
      $conn->http_configure( \%args );
      return $conn;
  }
  
  sub _proxy_connect {
      my ( $class, $args ) = @_;
      my $agent = $args->{Agent};
      my ($user, $pass);
      if( defined $args->{ProxyUserinfo} ) {
           ($user, $pass) = split(':', URI::Escape::uri_unescape( $args->{ProxyUserinfo} ), 2);
      }
      my $proxy_host_port =  $args->{'ProxyAddr'}.':'.$args->{'ProxyPort'};
      my $cur_http_proxy = $agent->proxy('http');
      $agent->proxy( http => 'http://'.
          ( defined $user ? $user.':'.$pass.'@' : '' ).
          $proxy_host_port.'/' );
  
      my $host_port = $args->{PeerAddr}.":".$args->{PeerPort};
      my $host = 'http://'.$host_port;
      my $request = HTTP::Request->new( CONNECT => $host );
      my $response = $agent->request( $request );
      $agent->proxy( http => $cur_http_proxy );
      
      if( $response->is_error ) {
          die('error while CONNECT thru proxy: '.$response->status_line );
      }
      my $conn = $response->{client_socket};
  
      delete $args->{ProxyAddr};
      delete $args->{ProxyPort};
      delete $args->{ProxyUserinfo};
      delete $args->{Agent};
  
      return( $conn );
  }
  
  sub http_connect {
      return 1;
  }
  
  1;
LWP_PROTOCOL_CONNECT_SOCKET_BASE

$fatpacked{"LWP/Protocol/cpan.pm"} = <<'LWP_PROTOCOL_CPAN';
  package LWP::Protocol::cpan;
  
  use strict;
  use vars qw(@ISA);
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  require URI;
  require HTTP::Status;
  require HTTP::Response;
  
  our $CPAN;
  
  unless ($CPAN) {
      # Try to find local CPAN mirror via $CPAN::Config
      eval {
  	require CPAN::Config;
  	if($CPAN::Config) {
  	    my $urls = $CPAN::Config->{urllist};
  	    if (ref($urls) eq "ARRAY") {
  		my $file;
  		for (@$urls) {
  		    if (/^file:/) {
  			$file = $_;
  			last;
  		    }
  		}
  
  		if ($file) {
  		    $CPAN = $file;
  		}
  		else {
  		    $CPAN = $urls->[0];
  		}
  	    }
  	}
      };
  
      $CPAN ||= "http://cpan.org/";  # last resort
  }
  
  # ensure that we don't chop of last part
  $CPAN .= "/" unless $CPAN =~ m,/$,;
  
  
  sub request {
      my($self, $request, $proxy, $arg, $size) = @_;
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'You can not proxy with cpan');
      }
  
      # check method
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD') {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'Library does not allow method ' .
  				   "$method for 'cpan:' URLs");
      }
  
      my $path = $request->uri->path;
      $path =~ s,^/,,;
  
      my $response = HTTP::Response->new(&HTTP::Status::RC_FOUND);
      $response->header("Location" => URI->new_abs($path, $CPAN));
      $response;
  }
  
  1;
LWP_PROTOCOL_CPAN

$fatpacked{"LWP/Protocol/data.pm"} = <<'LWP_PROTOCOL_DATA';
  package LWP::Protocol::data;
  
  # Implements access to data:-URLs as specified in RFC 2397
  
  use strict;
  use vars qw(@ISA);
  
  require HTTP::Response;
  require HTTP::Status;
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  use HTTP::Date qw(time2str);
  require LWP;  # needs version number
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size) = @_;
  
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'You can not proxy with data');
      }
  
      # check method
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD') {
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'Library does not allow method ' .
  				  "$method for 'data:' URLs");
      }
  
      my $url = $request->uri;
      my $response = HTTP::Response->new( &HTTP::Status::RC_OK, "Document follows");
  
      my $media_type = $url->media_type;
  
      my $data = $url->data;
      $response->header('Content-Type'   => $media_type,
  		      'Content-Length' => length($data),
  		      'Date'           => time2str(time),
  		      'Server'         => "libwww-perl-internal/$LWP::VERSION"
  		     );
  
      $data = "" if $method eq "HEAD";
      return $self->collect_once($arg, $response, $data);
  }
  
  1;
LWP_PROTOCOL_DATA

$fatpacked{"LWP/Protocol/file.pm"} = <<'LWP_PROTOCOL_FILE';
  package LWP::Protocol::file;
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  use strict;
  
  require LWP::MediaTypes;
  require HTTP::Request;
  require HTTP::Response;
  require HTTP::Status;
  require HTTP::Date;
  
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size) = @_;
  
      $size = 4096 unless defined $size and $size > 0;
  
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'You can not proxy through the filesystem');
      }
  
      # check method
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD') {
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'Library does not allow method ' .
  				  "$method for 'file:' URLs");
      }
  
      # check url
      my $url = $request->uri;
  
      my $scheme = $url->scheme;
      if ($scheme ne 'file') {
  	return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  			   "LWP::Protocol::file::request called for '$scheme'");
      }
  
      # URL OK, look at file
      my $path  = $url->file;
  
      # test file exists and is readable
      unless (-e $path) {
  	return HTTP::Response->new( &HTTP::Status::RC_NOT_FOUND,
  				  "File `$path' does not exist");
      }
      unless (-r _) {
  	return HTTP::Response->new( &HTTP::Status::RC_FORBIDDEN,
  				  'User does not have read permission');
      }
  
      # looks like file exists
      my($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$filesize,
         $atime,$mtime,$ctime,$blksize,$blocks)
  	    = stat(_);
  
      # XXX should check Accept headers?
  
      # check if-modified-since
      my $ims = $request->header('If-Modified-Since');
      if (defined $ims) {
  	my $time = HTTP::Date::str2time($ims);
  	if (defined $time and $time >= $mtime) {
  	    return HTTP::Response->new( &HTTP::Status::RC_NOT_MODIFIED,
  				      "$method $path");
  	}
      }
  
      # Ok, should be an OK response by now...
      my $response = HTTP::Response->new( &HTTP::Status::RC_OK );
  
      # fill in response headers
      $response->header('Last-Modified', HTTP::Date::time2str($mtime));
  
      if (-d _) {         # If the path is a directory, process it
  	# generate the HTML for directory
  	opendir(D, $path) or
  	   return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				     "Cannot read directory '$path': $!");
  	my(@files) = sort readdir(D);
  	closedir(D);
  
  	# Make directory listing
  	require URI::Escape;
  	require HTML::Entities;
          my $pathe = $path . ( $^O eq 'MacOS' ? ':' : '/');
  	for (@files) {
  	    my $furl = URI::Escape::uri_escape($_);
              if ( -d "$pathe$_" ) {
                  $furl .= '/';
                  $_ .= '/';
              }
  	    my $desc = HTML::Entities::encode($_);
  	    $_ = qq{<LI><A HREF="$furl">$desc</A>};
  	}
  	# Ensure that the base URL is "/" terminated
  	my $base = $url->clone;
  	unless ($base->path =~ m|/$|) {
  	    $base->path($base->path . "/");
  	}
  	my $html = join("\n",
  			"<HTML>\n<HEAD>",
  			"<TITLE>Directory $path</TITLE>",
  			"<BASE HREF=\"$base\">",
  			"</HEAD>\n<BODY>",
  			"<H1>Directory listing of $path</H1>",
  			"<UL>", @files, "</UL>",
  			"</BODY>\n</HTML>\n");
  
  	$response->header('Content-Type',   'text/html');
  	$response->header('Content-Length', length $html);
  	$html = "" if $method eq "HEAD";
  
  	return $self->collect_once($arg, $response, $html);
  
      }
  
      # path is a regular file
      $response->header('Content-Length', $filesize);
      LWP::MediaTypes::guess_media_type($path, $response);
  
      # read the file
      if ($method ne "HEAD") {
  	open(F, $path) or return new
  	    HTTP::Response(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  			   "Cannot read file '$path': $!");
  	binmode(F);
  	$response =  $self->collect($arg, $response, sub {
  	    my $content = "";
  	    my $bytes = sysread(F, $content, $size);
  	    return \$content if $bytes > 0;
  	    return \ "";
  	});
  	close(F);
      }
  
      $response;
  }
  
  1;
LWP_PROTOCOL_FILE

$fatpacked{"LWP/Protocol/ftp.pm"} = <<'LWP_PROTOCOL_FTP';
  package LWP::Protocol::ftp;
  
  # Implementation of the ftp protocol (RFC 959). We let the Net::FTP
  # package do all the dirty work.
  
  use Carp ();
  
  use HTTP::Status ();
  use HTTP::Negotiate ();
  use HTTP::Response ();
  use LWP::MediaTypes ();
  use File::Listing ();
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  use strict;
  eval {
      package LWP::Protocol::MyFTP;
  
      require Net::FTP;
      Net::FTP->require_version(2.00);
  
      use vars qw(@ISA);
      @ISA=qw(Net::FTP);
  
      sub new {
  	my $class = shift;
  
  	my $self = $class->SUPER::new(@_) || return undef;
  
  	my $mess = $self->message;  # welcome message
  	$mess =~ s|\n.*||s; # only first line left
  	$mess =~ s|\s*ready\.?$||;
  	# Make the version number more HTTP like
  	$mess =~ s|\s*\(Version\s*|/| and $mess =~ s|\)$||;
  	${*$self}{myftp_server} = $mess;
  	#$response->header("Server", $mess);
  
  	$self;
      }
  
      sub http_server {
  	my $self = shift;
  	${*$self}{myftp_server};
      }
  
      sub home {
  	my $self = shift;
  	my $old = ${*$self}{myftp_home};
  	if (@_) {
  	    ${*$self}{myftp_home} = shift;
  	}
  	$old;
      }
  
      sub go_home {
  	my $self = shift;
  	$self->cwd(${*$self}{myftp_home});
      }
  
      sub request_count {
  	my $self = shift;
  	++${*$self}{myftp_reqcount};
      }
  
      sub ping {
  	my $self = shift;
  	return $self->go_home;
      }
  
  };
  my $init_failed = $@;
  
  
  sub _connect {
      my($self, $host, $port, $user, $account, $password, $timeout) = @_;
  
      my $key;
      my $conn_cache = $self->{ua}{conn_cache};
      if ($conn_cache) {
  	$key = "$host:$port:$user";
  	$key .= ":$account" if defined($account);
  	if (my $ftp = $conn_cache->withdraw("ftp", $key)) {
  	    if ($ftp->ping) {
  		# save it again
  		$conn_cache->deposit("ftp", $key, $ftp);
  		return $ftp;
  	    }
  	}
      }
  
      # try to make a connection
      my $ftp = LWP::Protocol::MyFTP->new($host,
  					Port => $port,
  					Timeout => $timeout,
  					LocalAddr => $self->{ua}{local_address},
  				       );
      # XXX Should be some what to pass on 'Passive' (header??)
      unless ($ftp) {
  	$@ =~ s/^Net::FTP: //;
  	return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR, $@);
      }
  
      unless ($ftp->login($user, $password, $account)) {
  	# Unauthorized.  Let's fake a RC_UNAUTHORIZED response
  	my $mess = scalar($ftp->message);
  	$mess =~ s/\n$//;
  	my $res =  HTTP::Response->new(&HTTP::Status::RC_UNAUTHORIZED, $mess);
  	$res->header("Server", $ftp->http_server);
  	$res->header("WWW-Authenticate", qq(Basic Realm="FTP login"));
  	return $res;
      }
  
      my $home = $ftp->pwd;
      $ftp->home($home);
  
      $conn_cache->deposit("ftp", $key, $ftp) if $conn_cache;
  
      return $ftp;
  }
  
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      $size = 4096 unless $size;
  
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'You can not proxy through the ftp');
      }
  
      my $url = $request->uri;
      if ($url->scheme ne 'ftp') {
  	my $scheme = $url->scheme;
  	return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  		       "LWP::Protocol::ftp::request called for '$scheme'");
      }
  
      # check method
      my $method = $request->method;
  
      unless ($method eq 'GET' || $method eq 'HEAD' || $method eq 'PUT') {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'Library does not allow method ' .
  				   "$method for 'ftp:' URLs");
      }
  
      if ($init_failed) {
  	return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				   $init_failed);
      }
  
      my $host     = $url->host;
      my $port     = $url->port;
      my $user     = $url->user;
      my $password = $url->password;
  
      # If a basic autorization header is present than we prefer these over
      # the username/password specified in the URL.
      {
  	my($u,$p) = $request->authorization_basic;
  	if (defined $u) {
  	    $user = $u;
  	    $password = $p;
  	}
      }
  
      # We allow the account to be specified in the "Account" header
      my $account = $request->header('Account');
  
      my $ftp = $self->_connect($host, $port, $user, $account, $password, $timeout);
      return $ftp if ref($ftp) eq "HTTP::Response"; # ugh!
  
      # Create an initial response object
      my $response = HTTP::Response->new(&HTTP::Status::RC_OK, "OK");
      $response->header(Server => $ftp->http_server);
      $response->header('Client-Request-Num' => $ftp->request_count);
      $response->request($request);
  
      # Get & fix the path
      my @path =  grep { length } $url->path_segments;
      my $remote_file = pop(@path);
      $remote_file = '' unless defined $remote_file;
  
      my $type;
      if (ref $remote_file) {
  	my @params;
  	($remote_file, @params) = @$remote_file;
  	for (@params) {
  	    $type = $_ if s/^type=//;
  	}
      }
  
      if ($type && $type eq 'a') {
  	$ftp->ascii;
      }
      else {
  	$ftp->binary;
      }
  
      for (@path) {
  	unless ($ftp->cwd($_)) {
  	    return HTTP::Response->new(&HTTP::Status::RC_NOT_FOUND,
  				       "Can't chdir to $_");
  	}
      }
  
      if ($method eq 'GET' || $method eq 'HEAD') {
  	if (my $mod_time = $ftp->mdtm($remote_file)) {
  	    $response->last_modified($mod_time);
  	    if (my $ims = $request->if_modified_since) {
  		if ($mod_time <= $ims) {
  		    $response->code(&HTTP::Status::RC_NOT_MODIFIED);
  		    $response->message("Not modified");
  		    return $response;
  		}
  	    }
  	}
  
  	# We'll use this later to abort the transfer if necessary. 
  	# if $max_size is defined, we need to abort early. Otherwise, it's
        # a normal transfer
  	my $max_size = undef;
  
  	# Set resume location, if the client requested it
  	if ($request->header('Range') && $ftp->supported('REST'))
  	{
  		my $range_info = $request->header('Range');
  
  		# Change bytes=2772992-6781209 to just 2772992
  		my ($start_byte,$end_byte) = $range_info =~ /.*=\s*(\d+)-(\d+)?/;
  		if ( defined $start_byte && !defined $end_byte ) {
  
  		  # open range -- only the start is specified
  
  		  $ftp->restart( $start_byte );
  		  # don't define $max_size, we don't want to abort early
  		}
  		elsif ( defined $start_byte && defined $end_byte &&
  			$start_byte >= 0 && $end_byte >= $start_byte ) {
  
  		  $ftp->restart( $start_byte );
  		  $max_size = $end_byte - $start_byte;
  		}
  		else {
  
  		  return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  		     'Incorrect syntax for Range request');
  		}
  	}
  	elsif ($request->header('Range') && !$ftp->supported('REST'))
  	{
  		return HTTP::Response->new(&HTTP::Status::RC_NOT_IMPLEMENTED,
  	         "Server does not support resume.");
  	}
  
  	my $data;  # the data handle
  	if (length($remote_file) and $data = $ftp->retr($remote_file)) {
  	    my($type, @enc) = LWP::MediaTypes::guess_media_type($remote_file);
  	    $response->header('Content-Type',   $type) if $type;
  	    for (@enc) {
  		$response->push_header('Content-Encoding', $_);
  	    }
  	    my $mess = $ftp->message;
  	    if ($mess =~ /\((\d+)\s+bytes\)/) {
  		$response->header('Content-Length', "$1");
  	    }
  
  	    if ($method ne 'HEAD') {
  		# Read data from server
  		$response = $self->collect($arg, $response, sub {
  		    my $content = '';
  		    my $result = $data->read($content, $size);
  
                      # Stop early if we need to.
                      if (defined $max_size)
                      {
                        # We need an interface to Net::FTP::dataconn for getting
                        # the number of bytes already read
                        my $bytes_received = $data->bytes_read();
  
                        # We were already over the limit. (Should only happen
                        # once at the end.)
                        if ($bytes_received - length($content) > $max_size)
                        {
                          $content = '';
                        }
                        # We just went over the limit
                        elsif ($bytes_received  > $max_size)
                        {
                          # Trim content
                          $content = substr($content, 0,
                            $max_size - ($bytes_received - length($content)) );
                        }
                        # We're under the limit
                        else
                        {
                        }
                      }
  
  		    return \$content;
  		} );
  	    }
  	    # abort is needed for HEAD, it's == close if the transfer has
  	    # already completed.
  	    unless ($data->abort) {
  		# Something did not work too well.  Note that we treat
  		# responses to abort() with code 0 in case of HEAD as ok
  		# (at least wu-ftpd 2.6.1(1) does that).
  		if ($method ne 'HEAD' || $ftp->code != 0) {
  		    $response->code(&HTTP::Status::RC_INTERNAL_SERVER_ERROR);
  		    $response->message("FTP close response: " . $ftp->code .
  				       " " . $ftp->message);
  		}
  	    }
  	}
  	elsif (!length($remote_file) || ( $ftp->code >= 400 && $ftp->code < 600 )) {
  	    # not a plain file, try to list instead
  	    if (length($remote_file) && !$ftp->cwd($remote_file)) {
  		return HTTP::Response->new(&HTTP::Status::RC_NOT_FOUND,
  					   "File '$remote_file' not found");
  	    }
  
  	    # It should now be safe to try to list the directory
  	    my @lsl = $ftp->dir;
  
  	    # Try to figure out if the user want us to convert the
  	    # directory listing to HTML.
  	    my @variants =
  	      (
  	       ['html',  0.60, 'text/html'            ],
  	       ['dir',   1.00, 'text/ftp-dir-listing' ]
  	      );
  	    #$HTTP::Negotiate::DEBUG=1;
  	    my $prefer = HTTP::Negotiate::choose(\@variants, $request);
  
  	    my $content = '';
  
  	    if (!defined($prefer)) {
  		return HTTP::Response->new(&HTTP::Status::RC_NOT_ACCEPTABLE,
  			       "Neither HTML nor directory listing wanted");
  	    }
  	    elsif ($prefer eq 'html') {
  		$response->header('Content-Type' => 'text/html');
  		$content = "<HEAD><TITLE>File Listing</TITLE>\n";
  		my $base = $request->uri->clone;
  		my $path = $base->path;
  		$base->path("$path/") unless $path =~ m|/$|;
  		$content .= qq(<BASE HREF="$base">\n</HEAD>\n);
  		$content .= "<BODY>\n<UL>\n";
  		for (File::Listing::parse_dir(\@lsl, 'GMT')) {
  		    my($name, $type, $size, $mtime, $mode) = @$_;
  		    $content .= qq(  <LI> <a href="$name">$name</a>);
  		    $content .= " $size bytes" if $type eq 'f';
  		    $content .= "\n";
  		}
  		$content .= "</UL></body>\n";
  	    }
  	    else {
  		$response->header('Content-Type', 'text/ftp-dir-listing');
  		$content = join("\n", @lsl, '');
  	    }
  
  	    $response->header('Content-Length', length($content));
  
  	    if ($method ne 'HEAD') {
  		$response = $self->collect_once($arg, $response, $content);
  	    }
  	}
  	else {
  	    my $res = HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  			  "FTP return code " . $ftp->code);
  	    $res->content_type("text/plain");
  	    $res->content($ftp->message);
  	    return $res;
  	}
      }
      elsif ($method eq 'PUT') {
  	# method must be PUT
  	unless (length($remote_file)) {
  	    return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				       "Must have a file name to PUT to");
  	}
  	my $data;
  	if ($data = $ftp->stor($remote_file)) {
  	    my $content = $request->content;
  	    my $bytes = 0;
  	    if (defined $content) {
  		if (ref($content) eq 'SCALAR') {
  		    $bytes = $data->write($$content, length($$content));
  		}
  		elsif (ref($content) eq 'CODE') {
  		    my($buf, $n);
  		    while (length($buf = &$content)) {
  			$n = $data->write($buf, length($buf));
  			last unless $n;
  			$bytes += $n;
  		    }
  		}
  		elsif (!ref($content)) {
  		    if (defined $content && length($content)) {
  			$bytes = $data->write($content, length($content));
  		    }
  		}
  		else {
  		    die "Bad content";
  		}
  	    }
  	    $data->close;
  
  	    $response->code(&HTTP::Status::RC_CREATED);
  	    $response->header('Content-Type', 'text/plain');
  	    $response->content("$bytes bytes stored as $remote_file on $host\n")
  
  	}
  	else {
  	    my $res = HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  					  "FTP return code " . $ftp->code);
  	    $res->content_type("text/plain");
  	    $res->content($ftp->message);
  	    return $res;
  	}
      }
      else {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   "Illegal method $method");
      }
  
      $response;
  }
  
  1;
  
  __END__
  
  # This is what RFC 1738 has to say about FTP access:
  # --------------------------------------------------
  #
  # 3.2. FTP
  #
  #    The FTP URL scheme is used to designate files and directories on
  #    Internet hosts accessible using the FTP protocol (RFC959).
  #
  #    A FTP URL follow the syntax described in Section 3.1.  If :<port> is
  #    omitted, the port defaults to 21.
  #
  # 3.2.1. FTP Name and Password
  #
  #    A user name and password may be supplied; they are used in the ftp
  #    "USER" and "PASS" commands after first making the connection to the
  #    FTP server.  If no user name or password is supplied and one is
  #    requested by the FTP server, the conventions for "anonymous" FTP are
  #    to be used, as follows:
  #
  #         The user name "anonymous" is supplied.
  #
  #         The password is supplied as the Internet e-mail address
  #         of the end user accessing the resource.
  #
  #    If the URL supplies a user name but no password, and the remote
  #    server requests a password, the program interpreting the FTP URL
  #    should request one from the user.
  #
  # 3.2.2. FTP url-path
  #
  #    The url-path of a FTP URL has the following syntax:
  #
  #         <cwd1>/<cwd2>/.../<cwdN>/<name>;type=<typecode>
  #
  #    Where <cwd1> through <cwdN> and <name> are (possibly encoded) strings
  #    and <typecode> is one of the characters "a", "i", or "d".  The part
  #    ";type=<typecode>" may be omitted. The <cwdx> and <name> parts may be
  #    empty. The whole url-path may be omitted, including the "/"
  #    delimiting it from the prefix containing user, password, host, and
  #    port.
  #
  #    The url-path is interpreted as a series of FTP commands as follows:
  #
  #       Each of the <cwd> elements is to be supplied, sequentially, as the
  #       argument to a CWD (change working directory) command.
  #
  #       If the typecode is "d", perform a NLST (name list) command with
  #       <name> as the argument, and interpret the results as a file
  #       directory listing.
  #
  #       Otherwise, perform a TYPE command with <typecode> as the argument,
  #       and then access the file whose name is <name> (for example, using
  #       the RETR command.)
  #
  #    Within a name or CWD component, the characters "/" and ";" are
  #    reserved and must be encoded. The components are decoded prior to
  #    their use in the FTP protocol.  In particular, if the appropriate FTP
  #    sequence to access a particular file requires supplying a string
  #    containing a "/" as an argument to a CWD or RETR command, it is
  #    necessary to encode each "/".
  #
  #    For example, the URL <URL:ftp://myname@host.dom/%2Fetc/motd> is
  #    interpreted by FTP-ing to "host.dom", logging in as "myname"
  #    (prompting for a password if it is asked for), and then executing
  #    "CWD /etc" and then "RETR motd". This has a different meaning from
  #    <URL:ftp://myname@host.dom/etc/motd> which would "CWD etc" and then
  #    "RETR motd"; the initial "CWD" might be executed relative to the
  #    default directory for "myname". On the other hand,
  #    <URL:ftp://myname@host.dom//etc/motd>, would "CWD " with a null
  #    argument, then "CWD etc", and then "RETR motd".
  #
  #    FTP URLs may also be used for other operations; for example, it is
  #    possible to update a file on a remote file server, or infer
  #    information about it from the directory listings. The mechanism for
  #    doing so is not spelled out here.
  #
  # 3.2.3. FTP Typecode is Optional
  #
  #    The entire ;type=<typecode> part of a FTP URL is optional. If it is
  #    omitted, the client program interpreting the URL must guess the
  #    appropriate mode to use. In general, the data content type of a file
  #    can only be guessed from the name, e.g., from the suffix of the name;
  #    the appropriate type code to be used for transfer of the file can
  #    then be deduced from the data content of the file.
  #
  # 3.2.4 Hierarchy
  #
  #    For some file systems, the "/" used to denote the hierarchical
  #    structure of the URL corresponds to the delimiter used to construct a
  #    file name hierarchy, and thus, the filename will look similar to the
  #    URL path. This does NOT mean that the URL is a Unix filename.
  #
  # 3.2.5. Optimization
  #
  #    Clients accessing resources via FTP may employ additional heuristics
  #    to optimize the interaction. For some FTP servers, for example, it
  #    may be reasonable to keep the control connection open while accessing
  #    multiple URLs from the same server. However, there is no common
  #    hierarchical model to the FTP protocol, so if a directory change
  #    command has been given, it is impossible in general to deduce what
  #    sequence should be given to navigate to another directory for a
  #    second retrieval, if the paths are different.  The only reliable
  #    algorithm is to disconnect and reestablish the control connection.
LWP_PROTOCOL_FTP

$fatpacked{"LWP/Protocol/gopher.pm"} = <<'LWP_PROTOCOL_GOPHER';
  package LWP::Protocol::gopher;
  
  # Implementation of the gopher protocol (RFC 1436)
  #
  # This code is based on 'wwwgopher.pl,v 0.10 1994/10/17 18:12:34 shelden'
  # which in turn is a vastly modified version of Oscar's http'get()
  # dated 28/3/94 in <ftp://cui.unige.ch/PUBLIC/oscar/scripts/http.pl>
  # including contributions from Marc van Heyningen and Martijn Koster.
  
  use strict;
  use vars qw(@ISA);
  
  require HTTP::Response;
  require HTTP::Status;
  require IO::Socket;
  require IO::Select;
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  
  my %gopher2mimetype = (
      '0' => 'text/plain',                # 0 file
      '1' => 'text/html',                 # 1 menu
  					# 2 CSO phone-book server
  					# 3 Error
      '4' => 'application/mac-binhex40',  # 4 BinHexed Macintosh file
      '5' => 'application/zip',           # 5 DOS binary archive of some sort
      '6' => 'application/octet-stream',  # 6 UNIX uuencoded file.
      '7' => 'text/html',                 # 7 Index-Search server
  					# 8 telnet session
      '9' => 'application/octet-stream',  # 9 binary file
      'h' => 'text/html',                 # html
      'g' => 'image/gif',                 # gif
      'I' => 'image/*',                   # some kind of image
  );
  
  my %gopher2encoding = (
      '6' => 'x_uuencode',                # 6 UNIX uuencoded file.
  );
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      $size = 4096 unless $size;
  
      # check proxy
      if (defined $proxy) {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'You can not proxy through the gopher');
      }
  
      my $url = $request->uri;
      die "bad scheme" if $url->scheme ne 'gopher';
  
  
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD') {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'Library does not allow method ' .
  				   "$method for 'gopher:' URLs");
      }
  
      my $gophertype = $url->gopher_type;
      unless (exists $gopher2mimetype{$gophertype}) {
  	return HTTP::Response->new(&HTTP::Status::RC_NOT_IMPLEMENTED,
  				   'Library does not support gophertype ' .
  				   $gophertype);
      }
  
      my $response = HTTP::Response->new(&HTTP::Status::RC_OK, "OK");
      $response->header('Content-type' => $gopher2mimetype{$gophertype}
  					|| 'text/plain');
      $response->header('Content-Encoding' => $gopher2encoding{$gophertype})
  	if exists $gopher2encoding{$gophertype};
  
      if ($method eq 'HEAD') {
  	# XXX: don't even try it so we set this header
  	$response->header('Client-Warning' => 'Client answer only');
  	return $response;
      }
      
      if ($gophertype eq '7' && ! $url->search) {
        # the url is the prompt for a gopher search; supply boiler-plate
        return $self->collect_once($arg, $response, <<"EOT");
  <HEAD>
  <TITLE>Gopher Index</TITLE>
  <ISINDEX>
  </HEAD>
  <BODY>
  <H1>$url<BR>Gopher Search</H1>
  This is a searchable Gopher index.
  Use the search function of your browser to enter search terms.
  </BODY>
  EOT
      }
  
      my $host = $url->host;
      my $port = $url->port;
  
      my $requestLine = "";
  
      my $selector = $url->selector;
      if (defined $selector) {
  	$requestLine .= $selector;
  	my $search = $url->search;
  	if (defined $search) {
  	    $requestLine .= "\t$search";
  	    my $string = $url->string;
  	    if (defined $string) {
  		$requestLine .= "\t$string";
  	    }
  	}
      }
      $requestLine .= "\015\012";
  
      # potential request headers are just ignored
  
      # Ok, lets make the request
      my $socket = IO::Socket::INET->new(PeerAddr => $host,
  				       PeerPort => $port,
  				       LocalAddr => $self->{ua}{local_address},
  				       Proto    => 'tcp',
  				       Timeout  => $timeout);
      die "Can't connect to $host:$port" unless $socket;
      my $sel = IO::Select->new($socket);
  
      {
  	die "write timeout" if $timeout && !$sel->can_write($timeout);
  	my $n = syswrite($socket, $requestLine, length($requestLine));
  	die $! unless defined($n);
  	die "short write" if $n != length($requestLine);
      }
  
      my $user_arg = $arg;
  
      # must handle menus in a special way since they are to be
      # converted to HTML.  Undefing $arg ensures that the user does
      # not see the data before we get a change to convert it.
      $arg = undef if $gophertype eq '1' || $gophertype eq '7';
  
      # collect response
      my $buf = '';
      $response = $self->collect($arg, $response, sub {
  	die "read timeout" if $timeout && !$sel->can_read($timeout);
          my $n = sysread($socket, $buf, $size);
  	die $! unless defined($n);
  	return \$buf;
        } );
  
      # Convert menu to HTML and return data to user.
      if ($gophertype eq '1' || $gophertype eq '7') {
  	my $content = menu2html($response->content);
  	if (defined $user_arg) {
  	    $response = $self->collect_once($user_arg, $response, $content);
  	}
  	else {
  	    $response->content($content);
  	}
      }
  
      $response;
  }
  
  
  sub gopher2url
  {
      my($gophertype, $path, $host, $port) = @_;
  
      my $url;
  
      if ($gophertype eq '8' || $gophertype eq 'T') {
  	# telnet session
  	$url = $HTTP::URI_CLASS->new($gophertype eq '8' ? 'telnet:':'tn3270:');
  	$url->user($path) if defined $path;
      }
      else {
  	$path = URI::Escape::uri_escape($path);
  	$url = $HTTP::URI_CLASS->new("gopher:/$gophertype$path");
      }
      $url->host($host);
      $url->port($port);
      $url;
  }
  
  sub menu2html {
      my($menu) = @_;
  
      $menu =~ s/\015//g;  # remove carriage return
      my $tmp = <<"EOT";
  <HTML>
  <HEAD>
     <TITLE>Gopher menu</TITLE>
  </HEAD>
  <BODY>
  <H1>Gopher menu</H1>
  EOT
      for (split("\n", $menu)) {
  	last if /^\./;
  	my($pretty, $path, $host, $port) = split("\t");
  
  	$pretty =~ s/^(.)//;
  	my $type = $1;
  
  	my $url = gopher2url($type, $path, $host, $port)->as_string;
  	$tmp .= qq{<A HREF="$url">$pretty</A><BR>\n};
      }
      $tmp .= "</BODY>\n</HTML>\n";
      $tmp;
  }
  
  1;
LWP_PROTOCOL_GOPHER

$fatpacked{"LWP/Protocol/http.pm"} = <<'LWP_PROTOCOL_HTTP';
  package LWP::Protocol::http;
  
  use strict;
  
  require HTTP::Response;
  require HTTP::Status;
  require Net::HTTP;
  
  use vars qw(@ISA @EXTRA_SOCK_OPTS);
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  my $CRLF = "\015\012";
  
  sub _new_socket
  {
      my($self, $host, $port, $timeout) = @_;
      my $conn_cache = $self->{ua}{conn_cache};
      if ($conn_cache) {
  	if (my $sock = $conn_cache->withdraw($self->socket_type, "$host:$port")) {
  	    return $sock if $sock && !$sock->can_read(0);
  	    # if the socket is readable, then either the peer has closed the
  	    # connection or there are some garbage bytes on it.  In either
  	    # case we abandon it.
  	    $sock->close;
  	}
      }
  
      local($^W) = 0;  # IO::Socket::INET can be noisy
      my $sock = $self->socket_class->new(PeerAddr => $host,
  					PeerPort => $port,
  					LocalAddr => $self->{ua}{local_address},
  					Proto    => 'tcp',
  					Timeout  => $timeout,
  					KeepAlive => !!$conn_cache,
  					SendTE    => 1,
  					$self->_extra_sock_opts($host, $port),
  				       );
  
      unless ($sock) {
  	# IO::Socket::INET leaves additional error messages in $@
  	my $status = "Can't connect to $host:$port";
  	if ($@ =~ /\bconnect: (.*)/ ||
  	    $@ =~ /\b(Bad hostname)\b/ ||
  	    $@ =~ /\b(certificate verify failed)\b/ ||
  	    $@ =~ /\b(Crypt-SSLeay can't verify hostnames)\b/
  	) {
  	    $status .= " ($1)";
  	}
  	die "$status\n\n$@";
      }
  
      # perl 5.005's IO::Socket does not have the blocking method.
      eval { $sock->blocking(0); };
  
      $sock;
  }
  
  sub socket_type
  {
      return "http";
  }
  
  sub socket_class
  {
      my $self = shift;
      (ref($self) || $self) . "::Socket";
  }
  
  sub _extra_sock_opts  # to be overridden by subclass
  {
      return @EXTRA_SOCK_OPTS;
  }
  
  sub _check_sock
  {
      #my($self, $req, $sock) = @_;
  }
  
  sub _get_sock_info
  {
      my($self, $res, $sock) = @_;
      if (defined(my $peerhost = $sock->peerhost)) {
          $res->header("Client-Peer" => "$peerhost:" . $sock->peerport);
      }
  }
  
  sub _fixup_header
  {
      my($self, $h, $url, $proxy) = @_;
  
      # Extract 'Host' header
      my $hhost = $url->authority;
      if ($hhost =~ s/^([^\@]*)\@//) {  # get rid of potential "user:pass@"
  	# add authorization header if we need them.  HTTP URLs do
  	# not really support specification of user and password, but
  	# we allow it.
  	if (defined($1) && not $h->header('Authorization')) {
  	    require URI::Escape;
  	    $h->authorization_basic(map URI::Escape::uri_unescape($_),
  				    split(":", $1, 2));
  	}
      }
      $h->init_header('Host' => $hhost);
  
      if ($proxy) {
  	# Check the proxy URI's userinfo() for proxy credentials
  	# export http_proxy="http://proxyuser:proxypass@proxyhost:port"
  	my $p_auth = $proxy->userinfo();
  	if(defined $p_auth) {
  	    require URI::Escape;
  	    $h->proxy_authorization_basic(map URI::Escape::uri_unescape($_),
  					  split(":", $p_auth, 2))
  	}
      }
  }
  
  sub hlist_remove {
      my($hlist, $k) = @_;
      $k = lc $k;
      for (my $i = @$hlist - 2; $i >= 0; $i -= 2) {
  	next unless lc($hlist->[$i]) eq $k;
  	splice(@$hlist, $i, 2);
      }
  }
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      $size ||= 4096;
  
      # check method
      my $method = $request->method;
      unless ($method =~ /^[A-Za-z0-9_!\#\$%&\'*+\-.^\`|~]+$/) {  # HTTP token
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'Library does not allow method ' .
  				  "$method for 'http:' URLs");
      }
  
      my $url = $request->uri;
      my($host, $port, $fullpath);
  
      # Check if we're proxy'ing
      if (defined $proxy) {
  	# $proxy is an URL to an HTTP server which will proxy this request
  	$host = $proxy->host;
  	$port = $proxy->port;
  	$fullpath = $method eq "CONNECT" ?
                         ($url->host . ":" . $url->port) :
                         $url->as_string;
      }
      else {
  	$host = $url->host;
  	$port = $url->port;
  	$fullpath = $url->path_query;
  	$fullpath = "/$fullpath" unless $fullpath =~ m,^/,;
      }
  
      # connect to remote site
      my $socket = $self->_new_socket($host, $port, $timeout);
  
      my $http_version = "";
      if (my $proto = $request->protocol) {
  	if ($proto =~ /^(?:HTTP\/)?(1.\d+)$/) {
  	    $http_version = $1;
  	    $socket->http_version($http_version);
  	    $socket->send_te(0) if $http_version eq "1.0";
  	}
      }
  
      $self->_check_sock($request, $socket);
  
      my @h;
      my $request_headers = $request->headers->clone;
      $self->_fixup_header($request_headers, $url, $proxy);
  
      $request_headers->scan(sub {
  			       my($k, $v) = @_;
  			       $k =~ s/^://;
  			       $v =~ s/\n/ /g;
  			       push(@h, $k, $v);
  			   });
  
      my $content_ref = $request->content_ref;
      $content_ref = $$content_ref if ref($$content_ref);
      my $chunked;
      my $has_content;
  
      if (ref($content_ref) eq 'CODE') {
  	my $clen = $request_headers->header('Content-Length');
  	$has_content++ if $clen;
  	unless (defined $clen) {
  	    push(@h, "Transfer-Encoding" => "chunked");
  	    $has_content++;
  	    $chunked++;
  	}
      }
      else {
  	# Set (or override) Content-Length header
  	my $clen = $request_headers->header('Content-Length');
  	if (defined($$content_ref) && length($$content_ref)) {
  	    $has_content = length($$content_ref);
  	    if (!defined($clen) || $clen ne $has_content) {
  		if (defined $clen) {
  		    warn "Content-Length header value was wrong, fixed";
  		    hlist_remove(\@h, 'Content-Length');
  		}
  		push(@h, 'Content-Length' => $has_content);
  	    }
  	}
  	elsif ($clen) {
  	    warn "Content-Length set when there is no content, fixed";
  	    hlist_remove(\@h, 'Content-Length');
  	}
      }
  
      my $write_wait = 0;
      $write_wait = 2
  	if ($request_headers->header("Expect") || "") =~ /100-continue/;
  
      my $req_buf = $socket->format_request($method, $fullpath, @h);
      #print "------\n$req_buf\n------\n";
  
      if (!$has_content || $write_wait || $has_content > 8*1024) {
        WRITE:
          {
              # Since this just writes out the header block it should almost
              # always succeed to send the whole buffer in a single write call.
              my $n = $socket->syswrite($req_buf, length($req_buf));
              unless (defined $n) {
                  redo WRITE if $!{EINTR};
                  if ($!{EAGAIN}) {
                      select(undef, undef, undef, 0.1);
                      redo WRITE;
                  }
                  die "write failed: $!";
              }
              if ($n) {
                  substr($req_buf, 0, $n, "");
              }
              else {
                  select(undef, undef, undef, 0.5);
              }
              redo WRITE if length $req_buf;
          }
      }
  
      my($code, $mess, @junk);
      my $drop_connection;
  
      if ($has_content) {
  	my $eof;
  	my $wbuf;
  	my $woffset = 0;
        INITIAL_READ:
  	if ($write_wait) {
  	    # skip filling $wbuf when waiting for 100-continue
  	    # because if the response is a redirect or auth required
  	    # the request will be cloned and there is no way
  	    # to reset the input stream
  	    # return here via the label after the 100-continue is read
  	}
  	elsif (ref($content_ref) eq 'CODE') {
  	    my $buf = &$content_ref();
  	    $buf = "" unless defined($buf);
  	    $buf = sprintf "%x%s%s%s", length($buf), $CRLF, $buf, $CRLF
  		if $chunked;
  	    substr($buf, 0, 0) = $req_buf if $req_buf;
  	    $wbuf = \$buf;
  	}
  	else {
  	    if ($req_buf) {
  		my $buf = $req_buf . $$content_ref;
  		$wbuf = \$buf;
  	    }
  	    else {
  		$wbuf = $content_ref;
  	    }
  	    $eof = 1;
  	}
  
  	my $fbits = '';
  	vec($fbits, fileno($socket), 1) = 1;
  
        WRITE:
  	while ($write_wait || $woffset < length($$wbuf)) {
  
  	    my $sel_timeout = $timeout;
  	    if ($write_wait) {
  		$sel_timeout = $write_wait if $write_wait < $sel_timeout;
  	    }
  	    my $time_before;
              $time_before = time if $sel_timeout;
  
  	    my $rbits = $fbits;
  	    my $wbits = $write_wait ? undef : $fbits;
              my $sel_timeout_before = $sel_timeout;
            SELECT:
              {
                  my $nfound = select($rbits, $wbits, undef, $sel_timeout);
                  if ($nfound < 0) {
                      if ($!{EINTR} || $!{EAGAIN}) {
                          if ($time_before) {
                              $sel_timeout = $sel_timeout_before - (time - $time_before);
                              $sel_timeout = 0 if $sel_timeout < 0;
                          }
                          redo SELECT;
                      }
                      die "select failed: $!";
                  }
  	    }
  
  	    if ($write_wait) {
  		$write_wait -= time - $time_before;
  		$write_wait = 0 if $write_wait < 0;
  	    }
  
  	    if (defined($rbits) && $rbits =~ /[^\0]/) {
  		# readable
  		my $buf = $socket->_rbuf;
  		my $n = $socket->sysread($buf, 1024, length($buf));
                  unless (defined $n) {
                      die "read failed: $!" unless  $!{EINTR} || $!{EAGAIN};
                      # if we get here the rest of the block will do nothing
                      # and we will retry the read on the next round
                  }
  		elsif ($n == 0) {
                      # the server closed the connection before we finished
                      # writing all the request content.  No need to write any more.
                      $drop_connection++;
                      last WRITE;
  		}
  		$socket->_rbuf($buf);
  		if (!$code && $buf =~ /\015?\012\015?\012/) {
  		    # a whole response header is present, so we can read it without blocking
  		    ($code, $mess, @h) = $socket->read_response_headers(laxed => 1,
  									junk_out => \@junk,
  								       );
  		    if ($code eq "100") {
  			$write_wait = 0;
  			undef($code);
  			goto INITIAL_READ;
  		    }
  		    else {
  			$drop_connection++;
  			last WRITE;
  			# XXX should perhaps try to abort write in a nice way too
  		    }
  		}
  	    }
  	    if (defined($wbits) && $wbits =~ /[^\0]/) {
  		my $n = $socket->syswrite($$wbuf, length($$wbuf), $woffset);
                  unless (defined $n) {
                      die "write failed: $!" unless $!{EINTR} || $!{EAGAIN};
                      $n = 0;  # will retry write on the next round
                  }
                  elsif ($n == 0) {
  		    die "write failed: no bytes written";
  		}
  		$woffset += $n;
  
  		if (!$eof && $woffset >= length($$wbuf)) {
  		    # need to refill buffer from $content_ref code
  		    my $buf = &$content_ref();
  		    $buf = "" unless defined($buf);
  		    $eof++ unless length($buf);
  		    $buf = sprintf "%x%s%s%s", length($buf), $CRLF, $buf, $CRLF
  			if $chunked;
  		    $wbuf = \$buf;
  		    $woffset = 0;
  		}
  	    }
  	} # WRITE
      }
  
      ($code, $mess, @h) = $socket->read_response_headers(laxed => 1, junk_out => \@junk)
  	unless $code;
      ($code, $mess, @h) = $socket->read_response_headers(laxed => 1, junk_out => \@junk)
  	if $code eq "100";
  
      my $response = HTTP::Response->new($code, $mess);
      my $peer_http_version = $socket->peer_http_version;
      $response->protocol("HTTP/$peer_http_version");
      {
  	local $HTTP::Headers::TRANSLATE_UNDERSCORE;
  	$response->push_header(@h);
      }
      $response->push_header("Client-Junk" => \@junk) if @junk;
  
      $response->request($request);
      $self->_get_sock_info($response, $socket);
  
      if ($method eq "CONNECT") {
  	$response->{client_socket} = $socket;  # so it can be picked up
  	return $response;
      }
  
      if (my @te = $response->remove_header('Transfer-Encoding')) {
  	$response->push_header('Client-Transfer-Encoding', \@te);
      }
      $response->push_header('Client-Response-Num', scalar $socket->increment_response_count);
  
      my $complete;
      $response = $self->collect($arg, $response, sub {
  	my $buf = ""; #prevent use of uninitialized value in SSLeay.xs
  	my $n;
        READ:
  	{
  	    $n = $socket->read_entity_body($buf, $size);
              unless (defined $n) {
                  redo READ if $!{EINTR} || $!{EAGAIN};
                  die "read failed: $!";
              }
  	    redo READ if $n == -1;
  	}
  	$complete++ if !$n;
          return \$buf;
      } );
      $drop_connection++ unless $complete;
  
      @h = $socket->get_trailers;
      if (@h) {
  	local $HTTP::Headers::TRANSLATE_UNDERSCORE;
  	$response->push_header(@h);
      }
  
      # keep-alive support
      unless ($drop_connection) {
  	if (my $conn_cache = $self->{ua}{conn_cache}) {
  	    my %connection = map { (lc($_) => 1) }
  		             split(/\s*,\s*/, ($response->header("Connection") || ""));
  	    if (($peer_http_version eq "1.1" && !$connection{close}) ||
  		$connection{"keep-alive"})
  	    {
  		$conn_cache->deposit($self->socket_type, "$host:$port", $socket);
  	    }
  	}
      }
  
      $response;
  }
  
  
  #-----------------------------------------------------------
  package LWP::Protocol::http::SocketMethods;
  
  sub ping {
      my $self = shift;
      !$self->can_read(0);
  }
  
  sub increment_response_count {
      my $self = shift;
      return ++${*$self}{'myhttp_response_count'};
  }
  
  #-----------------------------------------------------------
  package LWP::Protocol::http::Socket;
  use vars qw(@ISA);
  @ISA = qw(LWP::Protocol::http::SocketMethods Net::HTTP);
  
  1;
LWP_PROTOCOL_HTTP

$fatpacked{"LWP/Protocol/http/connect.pm"} = <<'LWP_PROTOCOL_HTTP_CONNECT';
  package LWP::Protocol::http::connect;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.09'; # VERSION
  
  require LWP::Protocol::http;
  our @ISA = qw(LWP::Protocol::http);
  LWP::Protocol::implementor('http::connect' => 'LWP::Protocol::http::connect');
  
  sub new {
      my $self = shift->SUPER::new(@_);
      $self->{scheme} =~ s/::connect$//;
      $self;
  }
  
  sub _extra_sock_opts {
      my $self = shift;
      my($host, $port) = @_;
      my @extra_sock_opts = $self->SUPER::_extra_sock_opts(@_);
      return (@extra_sock_opts, @{$self->{proxy_connect_opts}});
  }
  
  1;
  
LWP_PROTOCOL_HTTP_CONNECT

$fatpacked{"LWP/Protocol/http/connect/Socket.pm"} = <<'LWP_PROTOCOL_HTTP_CONNECT_SOCKET';
  package LWP::Protocol::http::connect::Socket;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.09'; # VERSION
  
  require LWP::Protocol::http;
  use LWP::Protocol::connect::Socket::Base;
  our @ISA = qw(LWP::Protocol::connect::Socket::Base LWP::Protocol::http::Socket);
  
  1;
  
LWP_PROTOCOL_HTTP_CONNECT_SOCKET

$fatpacked{"LWP/Protocol/https.pm"} = <<'LWP_PROTOCOL_HTTPS';
  package LWP::Protocol::https;
  
  use strict;
  our $VERSION = "6.04";
  
  require LWP::Protocol::http;
  our @ISA = qw(LWP::Protocol::http);
  
  sub socket_type
  {
      return "https";
  }
  
  sub _extra_sock_opts
  {
      my $self = shift;
      my %ssl_opts = %{$self->{ua}{ssl_opts} || {}};
      if (delete $ssl_opts{verify_hostname}) {
  	$ssl_opts{SSL_verify_mode} ||= 1;
  	$ssl_opts{SSL_verifycn_scheme} = 'www';
      }
      else {
  	$ssl_opts{SSL_verify_mode} = 0;
      }
      if ($ssl_opts{SSL_verify_mode}) {
  	unless (exists $ssl_opts{SSL_ca_file} || exists $ssl_opts{SSL_ca_path}) {
  	    eval {
  		require Mozilla::CA;
  	    };
  	    if ($@) {
  		if ($@ =! /^Can't locate Mozilla\/CA\.pm/) {
  		    $@ = <<'EOT';
  Can't verify SSL peers without knowing which Certificate Authorities to trust
  
  This problem can be fixed by either setting the PERL_LWP_SSL_CA_FILE
  envirionment variable or by installing the Mozilla::CA module.
  
  To disable verification of SSL peers set the PERL_LWP_SSL_VERIFY_HOSTNAME
  envirionment variable to 0.  If you do this you can't be sure that you
  communicate with the expected peer.
  EOT
  		}
  		die $@;
  	    }
  	    $ssl_opts{SSL_ca_file} = Mozilla::CA::SSL_ca_file();
  	}
      }
      $self->{ssl_opts} = \%ssl_opts;
      return (%ssl_opts, $self->SUPER::_extra_sock_opts);
  }
  
  sub _check_sock
  {
      my($self, $req, $sock) = @_;
      my $check = $req->header("If-SSL-Cert-Subject");
      if (defined $check) {
  	my $cert = $sock->get_peer_certificate ||
  	    die "Missing SSL certificate";
  	my $subject = $cert->subject_name;
  	die "Bad SSL certificate subject: '$subject' !~ /$check/"
  	    unless $subject =~ /$check/;
  	$req->remove_header("If-SSL-Cert-Subject");  # don't pass it on
      }
  }
  
  sub _get_sock_info
  {
      my $self = shift;
      $self->SUPER::_get_sock_info(@_);
      my($res, $sock) = @_;
      $res->header("Client-SSL-Cipher" => $sock->get_cipher);
      my $cert = $sock->get_peer_certificate;
      if ($cert) {
  	$res->header("Client-SSL-Cert-Subject" => $cert->subject_name);
  	$res->header("Client-SSL-Cert-Issuer" => $cert->issuer_name);
      }
      if (!$self->{ssl_opts}{SSL_verify_mode}) {
  	$res->push_header("Client-SSL-Warning" => "Peer certificate not verified");
      }
      elsif (!$self->{ssl_opts}{SSL_verifycn_scheme}) {
  	$res->push_header("Client-SSL-Warning" => "Peer hostname match with certificate not verified");
      }
      $res->header("Client-SSL-Socket-Class" => $Net::HTTPS::SSL_SOCKET_CLASS);
  }
  
  #-----------------------------------------------------------
  package LWP::Protocol::https::Socket;
  
  require Net::HTTPS;
  our @ISA = qw(Net::HTTPS LWP::Protocol::http::SocketMethods);
  
  1;
  
  __END__
  
  =head1 NAME
  
  LWP::Protocol::https - Provide https support for LWP::UserAgent
  
  =head1 SYNOPSIS
  
    use LWP::UserAgent;
  
    $ua = LWP::UserAgent->new(ssl_opts => { verify_hostname => 1 });
    $res = $ua->get("https://www.example.com");
  
  =head1 DESCRIPTION
  
  The LWP::Protocol::https module provides support for using https schemed
  URLs with LWP.  This module is a plug-in to the LWP protocol handling, so
  you don't use it directly.  Once the module is installed LWP is able
  to access sites using HTTP over SSL/TLS.
  
  If hostname verification is requested by LWP::UserAgent's C<ssl_opts>, and
  neither C<SSL_ca_file> nor C<SSL_ca_path> is set, then C<SSL_ca_file> is
  implied to be the one provided by Mozilla::CA.  If the Mozilla::CA module
  isn't available SSL requests will fail.  Either install this module, set up an
  alternative C<SSL_ca_file> or disable hostname verification.
  
  This module used to be bundled with the libwww-perl, but it was unbundled in
  v6.02 in order to be able to declare its dependencies properly for the CPAN
  tool-chain.  Applications that need https support can just declare their
  dependency on LWP::Protocol::https and will no longer need to know what
  underlying modules to install.
  
  =head1 SEE ALSO
  
  L<IO::Socket::SSL>, L<Crypt::SSLeay>, L<Mozilla::CA>
  
  =head1 COPYRIGHT
  
  Copyright 1997-2011 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
LWP_PROTOCOL_HTTPS

$fatpacked{"LWP/Protocol/https/connect.pm"} = <<'LWP_PROTOCOL_HTTPS_CONNECT';
  package LWP::Protocol::https::connect;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.09'; # VERSION
  
  require LWP::Protocol::https;
  our @ISA = qw(LWP::Protocol::https);
  LWP::Protocol::implementor('https::connect' => 'LWP::Protocol::https::connect');
  
  sub new {
      my $self = shift->SUPER::new(@_);
      $self->{scheme} =~ s/::connect$//;
      $self;
  }
  
  sub _extra_sock_opts {
      my $self = shift;
      my($host, $port) = @_;
      my @extra_sock_opts = $self->SUPER::_extra_sock_opts(@_);
      return (@extra_sock_opts, @{$self->{proxy_connect_opts}});
  }
  
  1;
  
LWP_PROTOCOL_HTTPS_CONNECT

$fatpacked{"LWP/Protocol/https/connect/Socket.pm"} = <<'LWP_PROTOCOL_HTTPS_CONNECT_SOCKET';
  package LWP::Protocol::https::connect::Socket;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.09'; # VERSION
  
  require LWP::Protocol::https;
  use IO::Socket::SSL;
  use LWP::Protocol::connect::Socket::Base;
  our @ISA = qw(LWP::Protocol::connect::Socket::Base IO::Socket::SSL LWP::Protocol::https::Socket);
  
  sub new {
      my $class = shift;
      my %args = @_;
      my $conn = $class->_proxy_connect( \%args );
  
      unless ($class->start_SSL($conn, %args)) {
          my $status = 'error while setting up ssl connection';
          if( $@ ) {
              $status .= " (".$@.")";
          }
          die($status);
      }
      
      $conn->http_configure( \%args );
      return $conn;
  }
  
  1;
LWP_PROTOCOL_HTTPS_CONNECT_SOCKET

$fatpacked{"LWP/Protocol/loopback.pm"} = <<'LWP_PROTOCOL_LOOPBACK';
  package LWP::Protocol::loopback;
  
  use strict;
  use vars qw(@ISA);
  require HTTP::Response;
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  sub request {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      my $response = HTTP::Response->new(200, "OK");
      $response->content_type("message/http; msgtype=request");
  
      $response->header("Via", "loopback/1.0 $proxy")
  	if $proxy;
  
      $response->header("X-Arg", $arg);
      $response->header("X-Read-Size", $size);
      $response->header("X-Timeout", $timeout);
  
      return $self->collect_once($arg, $response, $request->as_string);
  }
  
  1;
LWP_PROTOCOL_LOOPBACK

$fatpacked{"LWP/Protocol/mailto.pm"} = <<'LWP_PROTOCOL_MAILTO';
  package LWP::Protocol::mailto;
  
  # This module implements the mailto protocol.  It is just a simple
  # frontend to the Unix sendmail program except on MacOS, where it uses
  # Mail::Internet.
  
  require LWP::Protocol;
  require HTTP::Request;
  require HTTP::Response;
  require HTTP::Status;
  
  use Carp;
  use strict;
  use vars qw(@ISA $SENDMAIL);
  
  @ISA = qw(LWP::Protocol);
  
  unless ($SENDMAIL = $ENV{SENDMAIL}) {
      for my $sm (qw(/usr/sbin/sendmail
  		   /usr/lib/sendmail
  		   /usr/ucblib/sendmail
  		  ))
      {
  	if (-x $sm) {
  	    $SENDMAIL = $sm;
  	    last;
  	}
      }
      die "Can't find the 'sendmail' program" unless $SENDMAIL;
  }
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size) = @_;
  
      my ($mail, $addr) if $^O eq "MacOS";
      my @text = () if $^O eq "MacOS";
  
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				  'You can not proxy with mail');
      }
  
      # check method
      my $method = $request->method;
  
      if ($method ne 'POST') {
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'Library does not allow method ' .
  				  "$method for 'mailto:' URLs");
      }
  
      # check url
      my $url = $request->uri;
  
      my $scheme = $url->scheme;
      if ($scheme ne 'mailto') {
  	return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  			 "LWP::Protocol::mailto::request called for '$scheme'");
      }
      if ($^O eq "MacOS") {
  	eval {
  	    require Mail::Internet;
  	};
  	if($@) {
  	    return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	               "You don't have MailTools installed");
  	}
  	unless ($ENV{SMTPHOSTS}) {
  	    return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	               "You don't have SMTPHOSTS defined");
  	}
      }
      else {
  	unless (-x $SENDMAIL) {
  	    return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	               "You don't have $SENDMAIL");
      }
      }
      if ($^O eq "MacOS") {
  	    $mail = Mail::Internet->new or
  	    return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	    "Can't get a Mail::Internet object");
      }
      else {
  	open(SENDMAIL, "| $SENDMAIL -oi -t") or
  	    return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	               "Can't run $SENDMAIL: $!");
      }
      if ($^O eq "MacOS") {
  	$addr = $url->encoded822addr;
      }
      else {
  	$request = $request->clone;  # we modify a copy
  	my @h = $url->headers;  # URL headers override those in the request
  	while (@h) {
  	    my $k = shift @h;
  	    my $v = shift @h;
  	    next unless defined $v;
  	    if (lc($k) eq "body") {
  		$request->content($v);
  	    }
  	    else {
  		$request->push_header($k => $v);
  	    }
  	}
      }
      if ($^O eq "MacOS") {
  	$mail->add(To => $addr);
  	$mail->add(split(/[:\n]/,$request->headers_as_string));
      }
      else {
  	print SENDMAIL $request->headers_as_string;
  	print SENDMAIL "\n";
      }
      my $content = $request->content;
      if (defined $content) {
  	my $contRef = ref($content) ? $content : \$content;
  	if (ref($contRef) eq 'SCALAR') {
  	    if ($^O eq "MacOS") {
  		@text = split("\n",$$contRef);
  		foreach (@text) {
  		    $_ .= "\n";
  		}
  	    }
  	    else {
  	    print SENDMAIL $$contRef;
  	    }
  
  	}
  	elsif (ref($contRef) eq 'CODE') {
  	    # Callback provides data
  	    my $d;
  	    if ($^O eq "MacOS") {
  		my $stuff = "";
  		while (length($d = &$contRef)) {
  		    $stuff .= $d;
  		}
  		@text = split("\n",$stuff);
  		foreach (@text) {
  		    $_ .= "\n";
  		}
  	    }
  	    else {
  		print SENDMAIL $d;
  	    }
  	}
      }
      if ($^O eq "MacOS") {
  	$mail->body(\@text);
  	unless ($mail->smtpsend) {
  	    return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				       "Mail::Internet->smtpsend unable to send message to <$addr>");
  	}
      }
      else {
  	unless (close(SENDMAIL)) {
  	    my $err = $! ? "$!" : "Exit status $?";
  	    return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				       "$SENDMAIL: $err");
  	}
      }
  
  
      my $response = HTTP::Response->new(&HTTP::Status::RC_ACCEPTED,
  				       "Mail accepted");
      $response->header('Content-Type', 'text/plain');
      if ($^O eq "MacOS") {
  	$response->header('Server' => "Mail::Internet $Mail::Internet::VERSION");
  	$response->content("Message sent to <$addr>\n");
      }
      else {
  	$response->header('Server' => $SENDMAIL);
  	my $to = $request->header("To");
  	$response->content("Message sent to <$to>\n");
      }
  
      return $response;
  }
  
  1;
LWP_PROTOCOL_MAILTO

$fatpacked{"LWP/Protocol/nntp.pm"} = <<'LWP_PROTOCOL_NNTP';
  package LWP::Protocol::nntp;
  
  # Implementation of the Network News Transfer Protocol (RFC 977)
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  require HTTP::Response;
  require HTTP::Status;
  require Net::NNTP;
  
  use strict;
  
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      $size = 4096 unless $size;
  
      # Check for proxy
      if (defined $proxy) {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'You can not proxy through NNTP');
      }
  
      # Check that the scheme is as expected
      my $url = $request->uri;
      my $scheme = $url->scheme;
      unless ($scheme eq 'news' || $scheme eq 'nntp') {
  	return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				   "LWP::Protocol::nntp::request called for '$scheme'");
      }
  
      # check for a valid method
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD' || $method eq 'POST') {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'Library does not allow method ' .
  				   "$method for '$scheme:' URLs");
      }
  
      # extract the identifier and check against posting to an article
      my $groupart = $url->_group;
      my $is_art = $groupart =~ /@/;
  
      if ($is_art && $method eq 'POST') {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   "Can't post to an article <$groupart>");
      }
  
      my $nntp = Net::NNTP->new($url->host,
  			      #Port    => 18574,
  			      Timeout => $timeout,
  			      #Debug   => 1,
  			     );
      die "Can't connect to nntp server" unless $nntp;
  
      # Check the initial welcome message from the NNTP server
      if ($nntp->status != 2) {
  	return HTTP::Response->new(&HTTP::Status::RC_SERVICE_UNAVAILABLE,
  				   $nntp->message);
      }
      my $response = HTTP::Response->new(&HTTP::Status::RC_OK, "OK");
  
      my $mess = $nntp->message;
  
      # Try to extract server name from greeting message.
      # Don't know if this works well for a large class of servers, but
      # this works for our server.
      $mess =~ s/\s+ready\b.*//;
      $mess =~ s/^\S+\s+//;
      $response->header(Server => $mess);
  
      # First we handle posting of articles
      if ($method eq 'POST') {
  	$nntp->quit; $nntp = undef;
  	$response->code(&HTTP::Status::RC_NOT_IMPLEMENTED);
  	$response->message("POST not implemented yet");
  	return $response;
      }
  
      # The method must be "GET" or "HEAD" by now
      if (!$is_art) {
  	if (!$nntp->group($groupart)) {
  	    $response->code(&HTTP::Status::RC_NOT_FOUND);
  	    $response->message($nntp->message);
  	}
  	$nntp->quit; $nntp = undef;
  	# HEAD: just check if the group exists
  	if ($method eq 'GET' && $response->is_success) {
  	    $response->code(&HTTP::Status::RC_NOT_IMPLEMENTED);
  	    $response->message("GET newsgroup not implemented yet");
  	}
  	return $response;
      }
  
      # Send command to server to retrieve an article (or just the headers)
      my $get = $method eq 'HEAD' ? "head" : "article";
      my $art = $nntp->$get("<$groupart>");
      unless ($art) {
  	$nntp->quit; $nntp = undef;
  	$response->code(&HTTP::Status::RC_NOT_FOUND);
  	$response->message($nntp->message);
  	return $response;
      }
  
      # Parse headers
      my($key, $val);
      local $_;
      while ($_ = shift @$art) {
  	if (/^\s+$/) {
  	    last;  # end of headers
  	}
  	elsif (/^(\S+):\s*(.*)/) {
  	    $response->push_header($key, $val) if $key;
  	    ($key, $val) = ($1, $2);
  	}
  	elsif (/^\s+(.*)/) {
  	    next unless $key;
  	    $val .= $1;
  	}
  	else {
  	    unshift(@$art, $_);
  	    last;
  	}
      }
      $response->push_header($key, $val) if $key;
  
      # Ensure that there is a Content-Type header
      $response->header("Content-Type", "text/plain")
  	unless $response->header("Content-Type");
  
      # Collect the body
      $response = $self->collect_once($arg, $response, join("", @$art))
        if @$art;
  
      # Say goodbye to the server
      $nntp->quit;
      $nntp = undef;
  
      $response;
  }
  
  1;
LWP_PROTOCOL_NNTP

$fatpacked{"LWP/Protocol/nogo.pm"} = <<'LWP_PROTOCOL_NOGO';
  package LWP::Protocol::nogo;
  # If you want to disable access to a particular scheme, use this
  # class and then call
  #   LWP::Protocol::implementor(that_scheme, 'LWP::Protocol::nogo');
  # For then on, attempts to access URLs with that scheme will generate
  # a 500 error.
  
  use strict;
  use vars qw(@ISA);
  require HTTP::Response;
  require HTTP::Status;
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  sub request {
      my($self, $request) = @_;
      my $scheme = $request->uri->scheme;
      
      return HTTP::Response->new(
        &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
        "Access to \'$scheme\' URIs has been disabled"
      );
  }
  1;
LWP_PROTOCOL_NOGO

$fatpacked{"LWP/RobotUA.pm"} = <<'LWP_ROBOTUA';
  package LWP::RobotUA;
  
  require LWP::UserAgent;
  @ISA = qw(LWP::UserAgent);
  $VERSION = "6.03";
  
  require WWW::RobotRules;
  require HTTP::Request;
  require HTTP::Response;
  
  use Carp ();
  use HTTP::Status ();
  use HTTP::Date qw(time2str);
  use strict;
  
  
  #
  # Additional attributes in addition to those found in LWP::UserAgent:
  #
  # $self->{'delay'}    Required delay between request to the same
  #                     server in minutes.
  #
  # $self->{'rules'}     A WWW::RobotRules object
  #
  
  sub new
  {
      my $class = shift;
      my %cnf;
      if (@_ < 4) {
  	# legacy args
  	@cnf{qw(agent from rules)} = @_;
      }
      else {
  	%cnf = @_;
      }
  
      Carp::croak('LWP::RobotUA agent required') unless $cnf{agent};
      Carp::croak('LWP::RobotUA from address required')
  	unless $cnf{from} && $cnf{from} =~ m/\@/;
  
      my $delay = delete $cnf{delay} || 1;
      my $use_sleep = delete $cnf{use_sleep};
      $use_sleep = 1 unless defined($use_sleep);
      my $rules = delete $cnf{rules};
  
      my $self = LWP::UserAgent->new(%cnf);
      $self = bless $self, $class;
  
      $self->{'delay'} = $delay;   # minutes
      $self->{'use_sleep'} = $use_sleep;
  
      if ($rules) {
  	$rules->agent($cnf{agent});
  	$self->{'rules'} = $rules;
      }
      else {
  	$self->{'rules'} = WWW::RobotRules->new($cnf{agent});
      }
  
      $self;
  }
  
  
  sub delay     { shift->_elem('delay',     @_); }
  sub use_sleep { shift->_elem('use_sleep', @_); }
  
  
  sub agent
  {
      my $self = shift;
      my $old = $self->SUPER::agent(@_);
      if (@_) {
  	# Changing our name means to start fresh
  	$self->{'rules'}->agent($self->{'agent'}); 
      }
      $old;
  }
  
  
  sub rules {
      my $self = shift;
      my $old = $self->_elem('rules', @_);
      $self->{'rules'}->agent($self->{'agent'}) if @_;
      $old;
  }
  
  
  sub no_visits
  {
      my($self, $netloc) = @_;
      $self->{'rules'}->no_visits($netloc) || 0;
  }
  
  *host_count = \&no_visits;  # backwards compatibility with LWP-5.02
  
  
  sub host_wait
  {
      my($self, $netloc) = @_;
      return undef unless defined $netloc;
      my $last = $self->{'rules'}->last_visit($netloc);
      if ($last) {
  	my $wait = int($self->{'delay'} * 60 - (time - $last));
  	$wait = 0 if $wait < 0;
  	return $wait;
      }
      return 0;
  }
  
  
  sub simple_request
  {
      my($self, $request, $arg, $size) = @_;
  
      # Do we try to access a new server?
      my $allowed = $self->{'rules'}->allowed($request->uri);
  
      if ($allowed < 0) {
  	# Host is not visited before, or robots.txt expired; fetch "robots.txt"
  	my $robot_url = $request->uri->clone;
  	$robot_url->path("robots.txt");
  	$robot_url->query(undef);
  
  	# make access to robot.txt legal since this will be a recursive call
  	$self->{'rules'}->parse($robot_url, ""); 
  
  	my $robot_req = HTTP::Request->new('GET', $robot_url);
  	my $parse_head = $self->parse_head(0);
  	my $robot_res = $self->request($robot_req);
  	$self->parse_head($parse_head);
  	my $fresh_until = $robot_res->fresh_until;
  	my $content = "";
  	if ($robot_res->is_success && $robot_res->content_is_text) {
  	    $content = $robot_res->decoded_content;
  	    $content = "" unless $content && $content =~ /^\s*Disallow\s*:/mi;
  	}
  	$self->{'rules'}->parse($robot_url, $content, $fresh_until);
  
  	# recalculate allowed...
  	$allowed = $self->{'rules'}->allowed($request->uri);
      }
  
      # Check rules
      unless ($allowed) {
  	my $res = HTTP::Response->new(
  	  &HTTP::Status::RC_FORBIDDEN, 'Forbidden by robots.txt');
  	$res->request( $request ); # bind it to that request
  	return $res;
      }
  
      my $netloc = eval { local $SIG{__DIE__}; $request->uri->host_port; };
      my $wait = $self->host_wait($netloc);
  
      if ($wait) {
  	if ($self->{'use_sleep'}) {
  	    sleep($wait)
  	}
  	else {
  	    my $res = HTTP::Response->new(
  	      &HTTP::Status::RC_SERVICE_UNAVAILABLE, 'Please, slow down');
  	    $res->header('Retry-After', time2str(time + $wait));
  	    $res->request( $request ); # bind it to that request
  	    return $res;
  	}
      }
  
      # Perform the request
      my $res = $self->SUPER::simple_request($request, $arg, $size);
  
      $self->{'rules'}->visit($netloc);
  
      $res;
  }
  
  
  sub as_string
  {
      my $self = shift;
      my @s;
      push(@s, "Robot: $self->{'agent'} operated by $self->{'from'}  [$self]");
      push(@s, "    Minimum delay: " . int($self->{'delay'}*60) . "s");
      push(@s, "    Will sleep if too early") if $self->{'use_sleep'};
      push(@s, "    Rules = $self->{'rules'}");
      join("\n", @s, '');
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  LWP::RobotUA - a class for well-behaved Web robots
  
  =head1 SYNOPSIS
  
    use LWP::RobotUA;
    my $ua = LWP::RobotUA->new('my-robot/0.1', 'me@foo.com');
    $ua->delay(10);  # be very nice -- max one hit every ten minutes!
    ...
  
    # Then just use it just like a normal LWP::UserAgent:
    my $response = $ua->get('http://whatever.int/...');
    ...
  
  =head1 DESCRIPTION
  
  This class implements a user agent that is suitable for robot
  applications.  Robots should be nice to the servers they visit.  They
  should consult the F</robots.txt> file to ensure that they are welcomed
  and they should not make requests too frequently.
  
  But before you consider writing a robot, take a look at
  <URL:http://www.robotstxt.org/>.
  
  When you use a I<LWP::RobotUA> object as your user agent, then you do not
  really have to think about these things yourself; C<robots.txt> files
  are automatically consulted and obeyed, the server isn't queried
  too rapidly, and so on.  Just send requests
  as you do when you are using a normal I<LWP::UserAgent>
  object (using C<< $ua->get(...) >>, C<< $ua->head(...) >>,
  C<< $ua->request(...) >>, etc.), and this
  special agent will make sure you are nice.
  
  =head1 METHODS
  
  The LWP::RobotUA is a sub-class of LWP::UserAgent and implements the
  same methods. In addition the following methods are provided:
  
  =over 4
  
  =item $ua = LWP::RobotUA->new( %options )
  
  =item $ua = LWP::RobotUA->new( $agent, $from )
  
  =item $ua = LWP::RobotUA->new( $agent, $from, $rules )
  
  The LWP::UserAgent options C<agent> and C<from> are mandatory.  The
  options C<delay>, C<use_sleep> and C<rules> initialize attributes
  private to the RobotUA.  If C<rules> are not provided, then
  C<WWW::RobotRules> is instantiated providing an internal database of
  F<robots.txt>.
  
  It is also possible to just pass the value of C<agent>, C<from> and
  optionally C<rules> as plain positional arguments.
  
  =item $ua->delay
  
  =item $ua->delay( $minutes )
  
  Get/set the minimum delay between requests to the same server, in
  I<minutes>.  The default is 1 minute.  Note that this number doesn't
  have to be an integer; for example, this sets the delay to 10 seconds:
  
      $ua->delay(10/60);
  
  =item $ua->use_sleep
  
  =item $ua->use_sleep( $boolean )
  
  Get/set a value indicating whether the UA should sleep() if requests
  arrive too fast, defined as $ua->delay minutes not passed since
  last request to the given server.  The default is TRUE.  If this value is
  FALSE then an internal SERVICE_UNAVAILABLE response will be generated.
  It will have an Retry-After header that indicates when it is OK to
  send another request to this server.
  
  =item $ua->rules
  
  =item $ua->rules( $rules )
  
  Set/get which I<WWW::RobotRules> object to use.
  
  =item $ua->no_visits( $netloc )
  
  Returns the number of documents fetched from this server host. Yeah I
  know, this method should probably have been named num_visits() or
  something like that. :-(
  
  =item $ua->host_wait( $netloc )
  
  Returns the number of I<seconds> (from now) you must wait before you can
  make a new request to this host.
  
  =item $ua->as_string
  
  Returns a string that describes the state of the UA.
  Mainly useful for debugging.
  
  =back
  
  =head1 SEE ALSO
  
  L<LWP::UserAgent>, L<WWW::RobotRules>
  
  =head1 COPYRIGHT
  
  Copyright 1996-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
LWP_ROBOTUA

$fatpacked{"LWP/Simple.pm"} = <<'LWP_SIMPLE';
  package LWP::Simple;
  
  use strict;
  use vars qw($ua %loop_check $FULL_LWP @EXPORT @EXPORT_OK $VERSION);
  
  require Exporter;
  
  @EXPORT = qw(get head getprint getstore mirror);
  @EXPORT_OK = qw($ua);
  
  # I really hate this.  I was a bad idea to do it in the first place.
  # Wonder how to get rid of it???  (It even makes LWP::Simple 7% slower
  # for trivial tests)
  use HTTP::Status;
  push(@EXPORT, @HTTP::Status::EXPORT);
  
  $VERSION = "6.00";
  
  sub import
  {
      my $pkg = shift;
      my $callpkg = caller;
      Exporter::export($pkg, $callpkg, @_);
  }
  
  use LWP::UserAgent ();
  use HTTP::Status ();
  use HTTP::Date ();
  $ua = LWP::UserAgent->new;  # we create a global UserAgent object
  $ua->agent("LWP::Simple/$VERSION ");
  $ua->env_proxy;
  
  
  sub get ($)
  {
      my $response = $ua->get(shift);
      return $response->decoded_content if $response->is_success;
      return undef;
  }
  
  
  sub head ($)
  {
      my($url) = @_;
      my $request = HTTP::Request->new(HEAD => $url);
      my $response = $ua->request($request);
  
      if ($response->is_success) {
  	return $response unless wantarray;
  	return (scalar $response->header('Content-Type'),
  		scalar $response->header('Content-Length'),
  		HTTP::Date::str2time($response->header('Last-Modified')),
  		HTTP::Date::str2time($response->header('Expires')),
  		scalar $response->header('Server'),
  	       );
      }
      return;
  }
  
  
  sub getprint ($)
  {
      my($url) = @_;
      my $request = HTTP::Request->new(GET => $url);
      local($\) = ""; # ensure standard $OUTPUT_RECORD_SEPARATOR
      my $callback = sub { print $_[0] };
      if ($^O eq "MacOS") {
  	$callback = sub { $_[0] =~ s/\015?\012/\n/g; print $_[0] }
      }
      my $response = $ua->request($request, $callback);
      unless ($response->is_success) {
  	print STDERR $response->status_line, " <URL:$url>\n";
      }
      $response->code;
  }
  
  
  sub getstore ($$)
  {
      my($url, $file) = @_;
      my $request = HTTP::Request->new(GET => $url);
      my $response = $ua->request($request, $file);
  
      $response->code;
  }
  
  
  sub mirror ($$)
  {
      my($url, $file) = @_;
      my $response = $ua->mirror($url, $file);
      $response->code;
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  LWP::Simple - simple procedural interface to LWP
  
  =head1 SYNOPSIS
  
   perl -MLWP::Simple -e 'getprint "http://www.sn.no"'
  
   use LWP::Simple;
   $content = get("http://www.sn.no/");
   die "Couldn't get it!" unless defined $content;
  
   if (mirror("http://www.sn.no/", "foo") == RC_NOT_MODIFIED) {
       ...
   }
  
   if (is_success(getprint("http://www.sn.no/"))) {
       ...
   }
  
  =head1 DESCRIPTION
  
  This module is meant for people who want a simplified view of the
  libwww-perl library.  It should also be suitable for one-liners.  If
  you need more control or access to the header fields in the requests
  sent and responses received, then you should use the full object-oriented
  interface provided by the C<LWP::UserAgent> module.
  
  The following functions are provided (and exported) by this module:
  
  =over 3
  
  =item get($url)
  
  The get() function will fetch the document identified by the given URL
  and return it.  It returns C<undef> if it fails.  The $url argument can
  be either a string or a reference to a URI object.
  
  You will not be able to examine the response code or response headers
  (like 'Content-Type') when you are accessing the web using this
  function.  If you need that information you should use the full OO
  interface (see L<LWP::UserAgent>).
  
  =item head($url)
  
  Get document headers. Returns the following 5 values if successful:
  ($content_type, $document_length, $modified_time, $expires, $server)
  
  Returns an empty list if it fails.  In scalar context returns TRUE if
  successful.
  
  =item getprint($url)
  
  Get and print a document identified by a URL. The document is printed
  to the selected default filehandle for output (normally STDOUT) as
  data is received from the network.  If the request fails, then the
  status code and message are printed on STDERR.  The return value is
  the HTTP response code.
  
  =item getstore($url, $file)
  
  Gets a document identified by a URL and stores it in the file. The
  return value is the HTTP response code.
  
  =item mirror($url, $file)
  
  Get and store a document identified by a URL, using
  I<If-modified-since>, and checking the I<Content-Length>.  Returns
  the HTTP response code.
  
  =back
  
  This module also exports the HTTP::Status constants and procedures.
  You can use them when you check the response code from getprint(),
  getstore() or mirror().  The constants are:
  
     RC_CONTINUE
     RC_SWITCHING_PROTOCOLS
     RC_OK
     RC_CREATED
     RC_ACCEPTED
     RC_NON_AUTHORITATIVE_INFORMATION
     RC_NO_CONTENT
     RC_RESET_CONTENT
     RC_PARTIAL_CONTENT
     RC_MULTIPLE_CHOICES
     RC_MOVED_PERMANENTLY
     RC_MOVED_TEMPORARILY
     RC_SEE_OTHER
     RC_NOT_MODIFIED
     RC_USE_PROXY
     RC_BAD_REQUEST
     RC_UNAUTHORIZED
     RC_PAYMENT_REQUIRED
     RC_FORBIDDEN
     RC_NOT_FOUND
     RC_METHOD_NOT_ALLOWED
     RC_NOT_ACCEPTABLE
     RC_PROXY_AUTHENTICATION_REQUIRED
     RC_REQUEST_TIMEOUT
     RC_CONFLICT
     RC_GONE
     RC_LENGTH_REQUIRED
     RC_PRECONDITION_FAILED
     RC_REQUEST_ENTITY_TOO_LARGE
     RC_REQUEST_URI_TOO_LARGE
     RC_UNSUPPORTED_MEDIA_TYPE
     RC_INTERNAL_SERVER_ERROR
     RC_NOT_IMPLEMENTED
     RC_BAD_GATEWAY
     RC_SERVICE_UNAVAILABLE
     RC_GATEWAY_TIMEOUT
     RC_HTTP_VERSION_NOT_SUPPORTED
  
  The HTTP::Status classification functions are:
  
  =over 3
  
  =item is_success($rc)
  
  True if response code indicated a successful request.
  
  =item is_error($rc)
  
  True if response code indicated that an error occurred.
  
  =back
  
  The module will also export the LWP::UserAgent object as C<$ua> if you
  ask for it explicitly.
  
  The user agent created by this module will identify itself as
  "LWP::Simple/#.##"
  and will initialize its proxy defaults from the environment (by
  calling $ua->env_proxy).
  
  =head1 CAVEAT
  
  Note that if you are using both LWP::Simple and the very popular CGI.pm
  module, you may be importing a C<head> function from each module,
  producing a warning like "Prototype mismatch: sub main::head ($) vs
  none". Get around this problem by just not importing LWP::Simple's
  C<head> function, like so:
  
          use LWP::Simple qw(!head);
          use CGI qw(:standard);  # then only CGI.pm defines a head()
  
  Then if you do need LWP::Simple's C<head> function, you can just call
  it as C<LWP::Simple::head($url)>.
  
  =head1 SEE ALSO
  
  L<LWP>, L<lwpcook>, L<LWP::UserAgent>, L<HTTP::Status>, L<lwp-request>,
  L<lwp-mirror>
LWP_SIMPLE

$fatpacked{"LWP/UserAgent.pm"} = <<'LWP_USERAGENT';
  package LWP::UserAgent;
  
  use strict;
  use vars qw(@ISA $VERSION);
  
  require LWP::MemberMixin;
  @ISA = qw(LWP::MemberMixin);
  $VERSION = "6.05";
  
  use HTTP::Request ();
  use HTTP::Response ();
  use HTTP::Date ();
  
  use LWP ();
  use LWP::Protocol ();
  
  use Carp ();
  
  
  sub new
  {
      # Check for common user mistake
      Carp::croak("Options to LWP::UserAgent should be key/value pairs, not hash reference") 
          if ref($_[1]) eq 'HASH'; 
  
      my($class, %cnf) = @_;
  
      my $agent = delete $cnf{agent};
      my $from  = delete $cnf{from};
      my $def_headers = delete $cnf{default_headers};
      my $timeout = delete $cnf{timeout};
      $timeout = 3*60 unless defined $timeout;
      my $local_address = delete $cnf{local_address};
      my $ssl_opts = delete $cnf{ssl_opts} || {};
      unless (exists $ssl_opts->{verify_hostname}) {
  	# The processing of HTTPS_CA_* below is for compatibility with Crypt::SSLeay
  	if (exists $ENV{PERL_LWP_SSL_VERIFY_HOSTNAME}) {
  	    $ssl_opts->{verify_hostname} = $ENV{PERL_LWP_SSL_VERIFY_HOSTNAME};
  	}
  	elsif ($ENV{HTTPS_CA_FILE} || $ENV{HTTPS_CA_DIR}) {
  	    # Crypt-SSLeay compatibility (verify peer certificate; but not the hostname)
  	    $ssl_opts->{verify_hostname} = 0;
  	    $ssl_opts->{SSL_verify_mode} = 1;
  	}
  	else {
  	    $ssl_opts->{verify_hostname} = 1;
  	}
      }
      unless (exists $ssl_opts->{SSL_ca_file}) {
  	if (my $ca_file = $ENV{PERL_LWP_SSL_CA_FILE} || $ENV{HTTPS_CA_FILE}) {
  	    $ssl_opts->{SSL_ca_file} = $ca_file;
  	}
      }
      unless (exists $ssl_opts->{SSL_ca_path}) {
  	if (my $ca_path = $ENV{PERL_LWP_SSL_CA_PATH} || $ENV{HTTPS_CA_DIR}) {
  	    $ssl_opts->{SSL_ca_path} = $ca_path;
  	}
      }
      my $use_eval = delete $cnf{use_eval};
      $use_eval = 1 unless defined $use_eval;
      my $parse_head = delete $cnf{parse_head};
      $parse_head = 1 unless defined $parse_head;
      my $show_progress = delete $cnf{show_progress};
      my $max_size = delete $cnf{max_size};
      my $max_redirect = delete $cnf{max_redirect};
      $max_redirect = 7 unless defined $max_redirect;
      my $env_proxy = exists $cnf{env_proxy} ? delete $cnf{env_proxy} : $ENV{PERL_LWP_ENV_PROXY};
  
      my $cookie_jar = delete $cnf{cookie_jar};
      my $conn_cache = delete $cnf{conn_cache};
      my $keep_alive = delete $cnf{keep_alive};
      
      Carp::croak("Can't mix conn_cache and keep_alive")
  	  if $conn_cache && $keep_alive;
  
      my $protocols_allowed   = delete $cnf{protocols_allowed};
      my $protocols_forbidden = delete $cnf{protocols_forbidden};
      
      my $requests_redirectable = delete $cnf{requests_redirectable};
      $requests_redirectable = ['GET', 'HEAD']
        unless defined $requests_redirectable;
  
      # Actually ""s are just as good as 0's, but for concision we'll just say:
      Carp::croak("protocols_allowed has to be an arrayref or 0, not \"$protocols_allowed\"!")
        if $protocols_allowed and ref($protocols_allowed) ne 'ARRAY';
      Carp::croak("protocols_forbidden has to be an arrayref or 0, not \"$protocols_forbidden\"!")
        if $protocols_forbidden and ref($protocols_forbidden) ne 'ARRAY';
      Carp::croak("requests_redirectable has to be an arrayref or 0, not \"$requests_redirectable\"!")
        if $requests_redirectable and ref($requests_redirectable) ne 'ARRAY';
  
  
      if (%cnf && $^W) {
  	Carp::carp("Unrecognized LWP::UserAgent options: @{[sort keys %cnf]}");
      }
  
      my $self = bless {
  		      def_headers  => $def_headers,
  		      timeout      => $timeout,
  		      local_address => $local_address,
  		      ssl_opts     => $ssl_opts,
  		      use_eval     => $use_eval,
                        show_progress=> $show_progress,
  		      max_size     => $max_size,
  		      max_redirect => $max_redirect,
                        proxy        => {},
  		      no_proxy     => [],
                        protocols_allowed     => $protocols_allowed,
                        protocols_forbidden   => $protocols_forbidden,
                        requests_redirectable => $requests_redirectable,
  		     }, $class;
  
      $self->agent(defined($agent) ? $agent : $class->_agent)
  	if defined($agent) || !$def_headers || !$def_headers->header("User-Agent");
      $self->from($from) if $from;
      $self->cookie_jar($cookie_jar) if $cookie_jar;
      $self->parse_head($parse_head);
      $self->env_proxy if $env_proxy;
  
      $self->protocols_allowed(  $protocols_allowed  ) if $protocols_allowed;
      $self->protocols_forbidden($protocols_forbidden) if $protocols_forbidden;
  
      if ($keep_alive) {
  	$conn_cache ||= { total_capacity => $keep_alive };
      }
      $self->conn_cache($conn_cache) if $conn_cache;
  
      return $self;
  }
  
  
  sub send_request
  {
      my($self, $request, $arg, $size) = @_;
      my($method, $url) = ($request->method, $request->uri);
      my $scheme = $url->scheme;
  
      local($SIG{__DIE__});  # protect against user defined die handlers
  
      $self->progress("begin", $request);
  
      my $response = $self->run_handlers("request_send", $request);
  
      unless ($response) {
          my $protocol;
  
          {
              # Honor object-specific restrictions by forcing protocol objects
              #  into class LWP::Protocol::nogo.
              my $x;
              if($x = $self->protocols_allowed) {
                  if (grep lc($_) eq $scheme, @$x) {
                  }
                  else {
                      require LWP::Protocol::nogo;
                      $protocol = LWP::Protocol::nogo->new;
                  }
              }
              elsif ($x = $self->protocols_forbidden) {
                  if(grep lc($_) eq $scheme, @$x) {
                      require LWP::Protocol::nogo;
                      $protocol = LWP::Protocol::nogo->new;
                  }
              }
              # else fall thru and create the protocol object normally
          }
  
          # Locate protocol to use
          my $proxy = $request->{proxy};
          if ($proxy) {
              $scheme = $proxy->scheme;
          }
  
          unless ($protocol) {
              $protocol = eval { LWP::Protocol::create($scheme, $self) };
              if ($@) {
                  $@ =~ s/ at .* line \d+.*//s;  # remove file/line number
                  $response =  _new_response($request, &HTTP::Status::RC_NOT_IMPLEMENTED, $@);
                  if ($scheme eq "https") {
                      $response->message($response->message . " (LWP::Protocol::https not installed)");
                      $response->content_type("text/plain");
                      $response->content(<<EOT);
  LWP will support https URLs if the LWP::Protocol::https module
  is installed.
  EOT
                  }
              }
          }
  
          if (!$response && $self->{use_eval}) {
              # we eval, and turn dies into responses below
              eval {
                  $response = $protocol->request($request, $proxy, $arg, $size, $self->{timeout}) ||
  		    die "No response returned by $protocol";
              };
              if ($@) {
                  if (UNIVERSAL::isa($@, "HTTP::Response")) {
                      $response = $@;
                      $response->request($request);
                  }
                  else {
                      my $full = $@;
                      (my $status = $@) =~ s/\n.*//s;
                      $status =~ s/ at .* line \d+.*//s;  # remove file/line number
                      my $code = ($status =~ s/^(\d\d\d)\s+//) ? $1 : &HTTP::Status::RC_INTERNAL_SERVER_ERROR;
                      $response = _new_response($request, $code, $status, $full);
                  }
              }
          }
          elsif (!$response) {
              $response = $protocol->request($request, $proxy,
                                             $arg, $size, $self->{timeout});
              # XXX: Should we die unless $response->is_success ???
          }
      }
  
      $response->request($request);  # record request for reference
      $response->header("Client-Date" => HTTP::Date::time2str(time));
  
      $self->run_handlers("response_done", $response);
  
      $self->progress("end", $response);
      return $response;
  }
  
  
  sub prepare_request
  {
      my($self, $request) = @_;
      die "Method missing" unless $request->method;
      my $url = $request->uri;
      die "URL missing" unless $url;
      die "URL must be absolute" unless $url->scheme;
  
      $self->run_handlers("request_preprepare", $request);
  
      if (my $def_headers = $self->{def_headers}) {
  	for my $h ($def_headers->header_field_names) {
  	    $request->init_header($h => [$def_headers->header($h)]);
  	}
      }
  
      $self->run_handlers("request_prepare", $request);
  
      return $request;
  }
  
  
  sub simple_request
  {
      my($self, $request, $arg, $size) = @_;
  
      # sanity check the request passed in
      if (defined $request) {
  	if (ref $request) {
  	    Carp::croak("You need a request object, not a " . ref($request) . " object")
  	      if ref($request) eq 'ARRAY' or ref($request) eq 'HASH' or
  		 !$request->can('method') or !$request->can('uri');
  	}
  	else {
  	    Carp::croak("You need a request object, not '$request'");
  	}
      }
      else {
          Carp::croak("No request object passed in");
      }
  
      eval {
  	$request = $self->prepare_request($request);
      };
      if ($@) {
  	$@ =~ s/ at .* line \d+.*//s;  # remove file/line number
  	return _new_response($request, &HTTP::Status::RC_BAD_REQUEST, $@);
      }
      return $self->send_request($request, $arg, $size);
  }
  
  
  sub request
  {
      my($self, $request, $arg, $size, $previous) = @_;
  
      my $response = $self->simple_request($request, $arg, $size);
      $response->previous($previous) if $previous;
  
      if ($response->redirects >= $self->{max_redirect}) {
          $response->header("Client-Warning" =>
                            "Redirect loop detected (max_redirect = $self->{max_redirect})");
          return $response;
      }
  
      if (my $req = $self->run_handlers("response_redirect", $response)) {
          return $self->request($req, $arg, $size, $response);
      }
  
      my $code = $response->code;
  
      if ($code == &HTTP::Status::RC_MOVED_PERMANENTLY or
  	$code == &HTTP::Status::RC_FOUND or
  	$code == &HTTP::Status::RC_SEE_OTHER or
  	$code == &HTTP::Status::RC_TEMPORARY_REDIRECT)
      {
  	my $referral = $request->clone;
  
  	# These headers should never be forwarded
  	$referral->remove_header('Host', 'Cookie');
  	
  	if ($referral->header('Referer') &&
  	    $request->uri->scheme eq 'https' &&
  	    $referral->uri->scheme eq 'http')
  	{
  	    # RFC 2616, section 15.1.3.
  	    # https -> http redirect, suppressing Referer
  	    $referral->remove_header('Referer');
  	}
  
  	if ($code == &HTTP::Status::RC_SEE_OTHER ||
  	    $code == &HTTP::Status::RC_FOUND) 
          {
  	    my $method = uc($referral->method);
  	    unless ($method eq "GET" || $method eq "HEAD") {
  		$referral->method("GET");
  		$referral->content("");
  		$referral->remove_content_headers;
  	    }
  	}
  
  	# And then we update the URL based on the Location:-header.
  	my $referral_uri = $response->header('Location');
  	{
  	    # Some servers erroneously return a relative URL for redirects,
  	    # so make it absolute if it not already is.
  	    local $URI::ABS_ALLOW_RELATIVE_SCHEME = 1;
  	    my $base = $response->base;
  	    $referral_uri = "" unless defined $referral_uri;
  	    $referral_uri = $HTTP::URI_CLASS->new($referral_uri, $base)
  		            ->abs($base);
  	}
  	$referral->uri($referral_uri);
  
  	return $response unless $self->redirect_ok($referral, $response);
  	return $self->request($referral, $arg, $size, $response);
  
      }
      elsif ($code == &HTTP::Status::RC_UNAUTHORIZED ||
  	     $code == &HTTP::Status::RC_PROXY_AUTHENTICATION_REQUIRED
  	    )
      {
  	my $proxy = ($code == &HTTP::Status::RC_PROXY_AUTHENTICATION_REQUIRED);
  	my $ch_header = $proxy ?  "Proxy-Authenticate" : "WWW-Authenticate";
  	my @challenge = $response->header($ch_header);
  	unless (@challenge) {
  	    $response->header("Client-Warning" => 
  			      "Missing Authenticate header");
  	    return $response;
  	}
  
  	require HTTP::Headers::Util;
  	CHALLENGE: for my $challenge (@challenge) {
  	    $challenge =~ tr/,/;/;  # "," is used to separate auth-params!!
  	    ($challenge) = HTTP::Headers::Util::split_header_words($challenge);
  	    my $scheme = shift(@$challenge);
  	    shift(@$challenge); # no value
  	    $challenge = { @$challenge };  # make rest into a hash
  
  	    unless ($scheme =~ /^([a-z]+(?:-[a-z]+)*)$/) {
  		$response->header("Client-Warning" => 
  				  "Bad authentication scheme '$scheme'");
  		return $response;
  	    }
  	    $scheme = $1;  # untainted now
  	    my $class = "LWP::Authen::\u$scheme";
  	    $class =~ s/-/_/g;
  
  	    no strict 'refs';
  	    unless (%{"$class\::"}) {
  		# try to load it
  		eval "require $class";
  		if ($@) {
  		    if ($@ =~ /^Can\'t locate/) {
  			$response->header("Client-Warning" =>
  					  "Unsupported authentication scheme '$scheme'");
  		    }
  		    else {
  			$response->header("Client-Warning" => $@);
  		    }
  		    next CHALLENGE;
  		}
  	    }
  	    unless ($class->can("authenticate")) {
  		$response->header("Client-Warning" =>
  				  "Unsupported authentication scheme '$scheme'");
  		next CHALLENGE;
  	    }
  	    return $class->authenticate($self, $proxy, $challenge, $response,
  					$request, $arg, $size);
  	}
  	return $response;
      }
      return $response;
  }
  
  
  #
  # Now the shortcuts...
  #
  sub get {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters,1);
      return $self->request( HTTP::Request::Common::GET( @parameters ), @suff );
  }
  
  
  sub post {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters, (ref($parameters[1]) ? 2 : 1));
      return $self->request( HTTP::Request::Common::POST( @parameters ), @suff );
  }
  
  
  sub head {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters,1);
      return $self->request( HTTP::Request::Common::HEAD( @parameters ), @suff );
  }
  
  
  sub put {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters, (ref($parameters[1]) ? 2 : 1));
      return $self->request( HTTP::Request::Common::PUT( @parameters ), @suff );
  }
  
  
  sub delete {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters,1);
      return $self->request( HTTP::Request::Common::DELETE( @parameters ), @suff );
  }
  
  
  sub _process_colonic_headers {
      # Process :content_cb / :content_file / :read_size_hint headers.
      my($self, $args, $start_index) = @_;
  
      my($arg, $size);
      for(my $i = $start_index; $i < @$args; $i += 2) {
  	next unless defined $args->[$i];
  
  	#printf "Considering %s => %s\n", $args->[$i], $args->[$i + 1];
  
  	if($args->[$i] eq ':content_cb') {
  	    # Some sanity-checking...
  	    $arg = $args->[$i + 1];
  	    Carp::croak("A :content_cb value can't be undef") unless defined $arg;
  	    Carp::croak("A :content_cb value must be a coderef")
  		unless ref $arg and UNIVERSAL::isa($arg, 'CODE');
  	    
  	}
  	elsif ($args->[$i] eq ':content_file') {
  	    $arg = $args->[$i + 1];
  
  	    # Some sanity-checking...
  	    Carp::croak("A :content_file value can't be undef")
  		unless defined $arg;
  	    Carp::croak("A :content_file value can't be a reference")
  		if ref $arg;
  	    Carp::croak("A :content_file value can't be \"\"")
  		unless length $arg;
  
  	}
  	elsif ($args->[$i] eq ':read_size_hint') {
  	    $size = $args->[$i + 1];
  	    # Bother checking it?
  
  	}
  	else {
  	    next;
  	}
  	splice @$args, $i, 2;
  	$i -= 2;
      }
  
      # And return a suitable suffix-list for request(REQ,...)
  
      return             unless defined $arg;
      return $arg, $size if     defined $size;
      return $arg;
  }
  
  
  sub is_online {
      my $self = shift;
      return 1 if $self->get("http://www.msftncsi.com/ncsi.txt")->content eq "Microsoft NCSI";
      return 1 if $self->get("http://www.apple.com")->content =~ m,<title>Apple</title>,;
      return 0;
  }
  
  
  my @ANI = qw(- \ | /);
  
  sub progress {
      my($self, $status, $m) = @_;
      return unless $self->{show_progress};
  
      local($,, $\);
      if ($status eq "begin") {
          print STDERR "** ", $m->method, " ", $m->uri, " ==> ";
          $self->{progress_start} = time;
          $self->{progress_lastp} = "";
          $self->{progress_ani} = 0;
      }
      elsif ($status eq "end") {
          delete $self->{progress_lastp};
          delete $self->{progress_ani};
          print STDERR $m->status_line;
          my $t = time - delete $self->{progress_start};
          print STDERR " (${t}s)" if $t;
          print STDERR "\n";
      }
      elsif ($status eq "tick") {
          print STDERR "$ANI[$self->{progress_ani}++]\b";
          $self->{progress_ani} %= @ANI;
      }
      else {
          my $p = sprintf "%3.0f%%", $status * 100;
          return if $p eq $self->{progress_lastp};
          print STDERR "$p\b\b\b\b";
          $self->{progress_lastp} = $p;
      }
      STDERR->flush;
  }
  
  
  #
  # This whole allow/forbid thing is based on man 1 at's way of doing things.
  #
  sub is_protocol_supported
  {
      my($self, $scheme) = @_;
      if (ref $scheme) {
  	# assume we got a reference to an URI object
  	$scheme = $scheme->scheme;
      }
      else {
  	Carp::croak("Illegal scheme '$scheme' passed to is_protocol_supported")
  	    if $scheme =~ /\W/;
  	$scheme = lc $scheme;
      }
  
      my $x;
      if(ref($self) and $x       = $self->protocols_allowed) {
        return 0 unless grep lc($_) eq $scheme, @$x;
      }
      elsif (ref($self) and $x = $self->protocols_forbidden) {
        return 0 if grep lc($_) eq $scheme, @$x;
      }
  
      local($SIG{__DIE__});  # protect against user defined die handlers
      $x = LWP::Protocol::implementor($scheme);
      return 1 if $x and $x ne 'LWP::Protocol::nogo';
      return 0;
  }
  
  
  sub protocols_allowed      { shift->_elem('protocols_allowed'    , @_) }
  sub protocols_forbidden    { shift->_elem('protocols_forbidden'  , @_) }
  sub requests_redirectable  { shift->_elem('requests_redirectable', @_) }
  
  
  sub redirect_ok
  {
      # RFC 2616, section 10.3.2 and 10.3.3 say:
      #  If the 30[12] status code is received in response to a request other
      #  than GET or HEAD, the user agent MUST NOT automatically redirect the
      #  request unless it can be confirmed by the user, since this might
      #  change the conditions under which the request was issued.
  
      # Note that this routine used to be just:
      #  return 0 if $_[1]->method eq "POST";  return 1;
  
      my($self, $new_request, $response) = @_;
      my $method = $response->request->method;
      return 0 unless grep $_ eq $method,
        @{ $self->requests_redirectable || [] };
      
      if ($new_request->uri->scheme eq 'file') {
        $response->header("Client-Warning" =>
  			"Can't redirect to a file:// URL!");
        return 0;
      }
      
      # Otherwise it's apparently okay...
      return 1;
  }
  
  
  sub credentials
  {
      my $self = shift;
      my $netloc = lc(shift);
      my $realm = shift || "";
      my $old = $self->{basic_authentication}{$netloc}{$realm};
      if (@_) {
          $self->{basic_authentication}{$netloc}{$realm} = [@_];
      }
      return unless $old;
      return @$old if wantarray;
      return join(":", @$old);
  }
  
  
  sub get_basic_credentials
  {
      my($self, $realm, $uri, $proxy) = @_;
      return if $proxy;
      return $self->credentials($uri->host_port, $realm);
  }
  
  
  sub timeout      { shift->_elem('timeout',      @_); }
  sub local_address{ shift->_elem('local_address',@_); }
  sub max_size     { shift->_elem('max_size',     @_); }
  sub max_redirect { shift->_elem('max_redirect', @_); }
  sub show_progress{ shift->_elem('show_progress', @_); }
  
  sub ssl_opts {
      my $self = shift;
      if (@_ == 1) {
  	my $k = shift;
  	return $self->{ssl_opts}{$k};
      }
      if (@_) {
  	my $old;
  	while (@_) {
  	    my($k, $v) = splice(@_, 0, 2);
  	    $old = $self->{ssl_opts}{$k} unless @_;
  	    if (defined $v) {
  		$self->{ssl_opts}{$k} = $v;
  	    }
  	    else {
  		delete $self->{ssl_opts}{$k};
  	    }
  	}
  	%{$self->{ssl_opts}} = (%{$self->{ssl_opts}}, @_);
  	return $old;
      }
  
      return keys %{$self->{ssl_opts}};
  }
  
  sub parse_head {
      my $self = shift;
      if (@_) {
          my $flag = shift;
          my $parser;
          my $old = $self->set_my_handler("response_header", $flag ? sub {
                 my($response, $ua) = @_;
                 require HTML::HeadParser;
                 $parser = HTML::HeadParser->new;
                 $parser->xml_mode(1) if $response->content_is_xhtml;
                 $parser->utf8_mode(1) if $] >= 5.008 && $HTML::Parser::VERSION >= 3.40;
  
                 push(@{$response->{handlers}{response_data}}, {
  		   callback => sub {
  		       return unless $parser;
  		       unless ($parser->parse($_[3])) {
  			   my $h = $parser->header;
  			   my $r = $_[0];
  			   for my $f ($h->header_field_names) {
  			       $r->init_header($f, [$h->header($f)]);
  			   }
  			   undef($parser);
  		       }
  		   },
  	       });
  
              } : undef,
              m_media_type => "html",
          );
          return !!$old;
      }
      else {
          return !!$self->get_my_handler("response_header");
      }
  }
  
  sub cookie_jar {
      my $self = shift;
      my $old = $self->{cookie_jar};
      if (@_) {
  	my $jar = shift;
  	if (ref($jar) eq "HASH") {
  	    require HTTP::Cookies;
  	    $jar = HTTP::Cookies->new(%$jar);
  	}
  	$self->{cookie_jar} = $jar;
          $self->set_my_handler("request_prepare",
              $jar ? sub { $jar->add_cookie_header($_[0]); } : undef,
          );
          $self->set_my_handler("response_done",
              $jar ? sub { $jar->extract_cookies($_[0]); } : undef,
          );
      }
      $old;
  }
  
  sub default_headers {
      my $self = shift;
      my $old = $self->{def_headers} ||= HTTP::Headers->new;
      if (@_) {
  	Carp::croak("default_headers not set to HTTP::Headers compatible object")
  	    unless @_ == 1 && $_[0]->can("header_field_names");
  	$self->{def_headers} = shift;
      }
      return $old;
  }
  
  sub default_header {
      my $self = shift;
      return $self->default_headers->header(@_);
  }
  
  sub _agent       { "libwww-perl/$LWP::VERSION" }
  
  sub agent {
      my $self = shift;
      if (@_) {
  	my $agent = shift;
          if ($agent) {
              $agent .= $self->_agent if $agent =~ /\s+$/;
          }
          else {
              undef($agent)
          }
          return $self->default_header("User-Agent", $agent);
      }
      return $self->default_header("User-Agent");
  }
  
  sub from {  # legacy
      my $self = shift;
      return $self->default_header("From", @_);
  }
  
  
  sub conn_cache {
      my $self = shift;
      my $old = $self->{conn_cache};
      if (@_) {
  	my $cache = shift;
  	if (ref($cache) eq "HASH") {
  	    require LWP::ConnCache;
  	    $cache = LWP::ConnCache->new(%$cache);
  	}
  	$self->{conn_cache} = $cache;
      }
      $old;
  }
  
  
  sub add_handler {
      my($self, $phase, $cb, %spec) = @_;
      $spec{line} ||= join(":", (caller)[1,2]);
      my $conf = $self->{handlers}{$phase} ||= do {
          require HTTP::Config;
          HTTP::Config->new;
      };
      $conf->add(%spec, callback => $cb);
  }
  
  sub set_my_handler {
      my($self, $phase, $cb, %spec) = @_;
      $spec{owner} = (caller(1))[3] unless exists $spec{owner};
      $self->remove_handler($phase, %spec);
      $spec{line} ||= join(":", (caller)[1,2]);
      $self->add_handler($phase, $cb, %spec) if $cb;
  }
  
  sub get_my_handler {
      my $self = shift;
      my $phase = shift;
      my $init = pop if @_ % 2;
      my %spec = @_;
      my $conf = $self->{handlers}{$phase};
      unless ($conf) {
          return unless $init;
          require HTTP::Config;
          $conf = $self->{handlers}{$phase} = HTTP::Config->new;
      }
      $spec{owner} = (caller(1))[3] unless exists $spec{owner};
      my @h = $conf->find(%spec);
      if (!@h && $init) {
          if (ref($init) eq "CODE") {
              $init->(\%spec);
          }
          elsif (ref($init) eq "HASH") {
              while (my($k, $v) = each %$init) {
                  $spec{$k} = $v;
              }
          }
          $spec{callback} ||= sub {};
          $spec{line} ||= join(":", (caller)[1,2]);
          $conf->add(\%spec);
          return \%spec;
      }
      return wantarray ? @h : $h[0];
  }
  
  sub remove_handler {
      my($self, $phase, %spec) = @_;
      if ($phase) {
          my $conf = $self->{handlers}{$phase} || return;
          my @h = $conf->remove(%spec);
          delete $self->{handlers}{$phase} if $conf->empty;
          return @h;
      }
  
      return unless $self->{handlers};
      return map $self->remove_handler($_), sort keys %{$self->{handlers}};
  }
  
  sub handlers {
      my($self, $phase, $o) = @_;
      my @h;
      if ($o->{handlers} && $o->{handlers}{$phase}) {
          push(@h, @{$o->{handlers}{$phase}});
      }
      if (my $conf = $self->{handlers}{$phase}) {
          push(@h, $conf->matching($o));
      }
      return @h;
  }
  
  sub run_handlers {
      my($self, $phase, $o) = @_;
      if (defined(wantarray)) {
          for my $h ($self->handlers($phase, $o)) {
              my $ret = $h->{callback}->($o, $self, $h);
              return $ret if $ret;
          }
          return undef;
      }
  
      for my $h ($self->handlers($phase, $o)) {
          $h->{callback}->($o, $self, $h);
      }
  }
  
  
  # deprecated
  sub use_eval   { shift->_elem('use_eval',  @_); }
  sub use_alarm
  {
      Carp::carp("LWP::UserAgent->use_alarm(BOOL) is a no-op")
  	if @_ > 1 && $^W;
      "";
  }
  
  
  sub clone
  {
      my $self = shift;
      my $copy = bless { %$self }, ref $self;  # copy most fields
  
      delete $copy->{handlers};
      delete $copy->{conn_cache};
  
      # copy any plain arrays and hashes; known not to need recursive copy
      for my $k (qw(proxy no_proxy requests_redirectable ssl_opts)) {
          next unless $copy->{$k};
          if (ref($copy->{$k}) eq "ARRAY") {
              $copy->{$k} = [ @{$copy->{$k}} ];
          }
          elsif (ref($copy->{$k}) eq "HASH") {
              $copy->{$k} = { %{$copy->{$k}} };
          }
      }
  
      if ($self->{def_headers}) {
          $copy->{def_headers} = $self->{def_headers}->clone;
      }
  
      # re-enable standard handlers
      $copy->parse_head($self->parse_head);
  
      # no easy way to clone the cookie jar; so let's just remove it for now
      $copy->cookie_jar(undef);
  
      $copy;
  }
  
  
  sub mirror
  {
      my($self, $url, $file) = @_;
  
      my $request = HTTP::Request->new('GET', $url);
  
      # If the file exists, add a cache-related header
      if ( -e $file ) {
          my ($mtime) = ( stat($file) )[9];
          if ($mtime) {
              $request->header( 'If-Modified-Since' => HTTP::Date::time2str($mtime) );
          }
      }
      my $tmpfile = "$file-$$";
  
      my $response = $self->request($request, $tmpfile);
      if ( $response->header('X-Died') ) {
  	die $response->header('X-Died');
      }
  
      # Only fetching a fresh copy of the would be considered success.
      # If the file was not modified, "304" would returned, which 
      # is considered by HTTP::Status to be a "redirect", /not/ "success"
      if ( $response->is_success ) {
          my @stat        = stat($tmpfile) or die "Could not stat tmpfile '$tmpfile': $!";
          my $file_length = $stat[7];
          my ($content_length) = $response->header('Content-length');
  
          if ( defined $content_length and $file_length < $content_length ) {
              unlink($tmpfile);
              die "Transfer truncated: " . "only $file_length out of $content_length bytes received\n";
          }
          elsif ( defined $content_length and $file_length > $content_length ) {
              unlink($tmpfile);
              die "Content-length mismatch: " . "expected $content_length bytes, got $file_length\n";
          }
          # The file was the expected length. 
          else {
              # Replace the stale file with a fresh copy
              if ( -e $file ) {
                  # Some dosish systems fail to rename if the target exists
                  chmod 0777, $file;
                  unlink $file;
              }
              rename( $tmpfile, $file )
                  or die "Cannot rename '$tmpfile' to '$file': $!\n";
  
              # make sure the file has the same last modification time
              if ( my $lm = $response->last_modified ) {
                  utime $lm, $lm, $file;
              }
          }
      }
      # The local copy is fresh enough, so just delete the temp file  
      else {
  	unlink($tmpfile);
      }
      return $response;
  }
  
  
  sub _need_proxy {
      my($req, $ua) = @_;
      return if exists $req->{proxy};
      my $proxy = $ua->{proxy}{$req->uri->scheme} || return;
      if ($ua->{no_proxy}) {
          if (my $host = eval { $req->uri->host }) {
              for my $domain (@{$ua->{no_proxy}}) {
                  if ($host =~ /\Q$domain\E$/) {
                      return;
                  }
              }
          }
      }
      $req->{proxy} = $HTTP::URI_CLASS->new($proxy);
  }
  
  
  sub proxy
  {
      my $self = shift;
      my $key  = shift;
      return map $self->proxy($_, @_), @$key if ref $key;
  
      Carp::croak("'$key' is not a valid URI scheme") unless $key =~ /^$URI::scheme_re\z/;
      my $old = $self->{'proxy'}{$key};
      if (@_) {
          my $url = shift;
          if (defined($url) && length($url)) {
              Carp::croak("Proxy must be specified as absolute URI; '$url' is not") unless $url =~ /^$URI::scheme_re:/;
              Carp::croak("Bad http proxy specification '$url'") if $url =~ /^https?:/ && $url !~ m,^https?://\w,;
          }
          $self->{proxy}{$key} = $url;
          $self->set_my_handler("request_preprepare", \&_need_proxy)
      }
      return $old;
  }
  
  
  sub env_proxy {
      my ($self) = @_;
      require Encode;
      require Encode::Locale;
      my($k,$v);
      while(($k, $v) = each %ENV) {
  	if ($ENV{REQUEST_METHOD}) {
  	    # Need to be careful when called in the CGI environment, as
  	    # the HTTP_PROXY variable is under control of that other guy.
  	    next if $k =~ /^HTTP_/;
  	    $k = "HTTP_PROXY" if $k eq "CGI_HTTP_PROXY";
  	}
  	$k = lc($k);
  	next unless $k =~ /^(.*)_proxy$/;
  	$k = $1;
  	if ($k eq 'no') {
  	    $self->no_proxy(split(/\s*,\s*/, $v));
  	}
  	else {
              # Ignore random _proxy variables, allow only valid schemes
              next unless $k =~ /^$URI::scheme_re\z/;
              # Ignore xxx_proxy variables if xxx isn't a supported protocol
              next unless LWP::Protocol::implementor($k);
  	    $self->proxy($k, Encode::decode(locale => $v));
  	}
      }
  }
  
  
  sub no_proxy {
      my($self, @no) = @_;
      if (@no) {
  	push(@{ $self->{'no_proxy'} }, @no);
      }
      else {
  	$self->{'no_proxy'} = [];
      }
  }
  
  
  sub _new_response {
      my($request, $code, $message, $content) = @_;
      $message ||= HTTP::Status::status_message($code);
      my $response = HTTP::Response->new($code, $message);
      $response->request($request);
      $response->header("Client-Date" => HTTP::Date::time2str(time));
      $response->header("Client-Warning" => "Internal response");
      $response->header("Content-Type" => "text/plain");
      $response->content($content || "$code $message\n");
      return $response;
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  LWP::UserAgent - Web user agent class
  
  =head1 SYNOPSIS
  
   require LWP::UserAgent;
   
   my $ua = LWP::UserAgent->new;
   $ua->timeout(10);
   $ua->env_proxy;
   
   my $response = $ua->get('http://search.cpan.org/');
   
   if ($response->is_success) {
       print $response->decoded_content;  # or whatever
   }
   else {
       die $response->status_line;
   }
  
  =head1 DESCRIPTION
  
  The C<LWP::UserAgent> is a class implementing a web user agent.
  C<LWP::UserAgent> objects can be used to dispatch web requests.
  
  In normal use the application creates an C<LWP::UserAgent> object, and
  then configures it with values for timeouts, proxies, name, etc. It
  then creates an instance of C<HTTP::Request> for the request that
  needs to be performed. This request is then passed to one of the
  request method the UserAgent, which dispatches it using the relevant
  protocol, and returns a C<HTTP::Response> object.  There are
  convenience methods for sending the most common request types: get(),
  head(), post(), put() and delete().  When using these methods then the
  creation of the request object is hidden as shown in the synopsis above.
  
  The basic approach of the library is to use HTTP style communication
  for all protocol schemes.  This means that you will construct
  C<HTTP::Request> objects and receive C<HTTP::Response> objects even
  for non-HTTP resources like I<gopher> and I<ftp>.  In order to achieve
  even more similarity to HTTP style communications, gopher menus and
  file directories are converted to HTML documents.
  
  =head1 CONSTRUCTOR METHODS
  
  The following constructor methods are available:
  
  =over 4
  
  =item $ua = LWP::UserAgent->new( %options )
  
  This method constructs a new C<LWP::UserAgent> object and returns it.
  Key/value pair arguments may be provided to set up the initial state.
  The following options correspond to attribute methods described below:
  
     KEY                     DEFAULT
     -----------             --------------------
     agent                   "libwww-perl/#.###"
     from                    undef
     conn_cache              undef
     cookie_jar              undef
     default_headers         HTTP::Headers->new
     local_address           undef
     ssl_opts		   { verify_hostname => 1 }
     max_size                undef
     max_redirect            7
     parse_head              1
     protocols_allowed       undef
     protocols_forbidden     undef
     requests_redirectable   ['GET', 'HEAD']
     timeout                 180
  
  The following additional options are also accepted: If the C<env_proxy> option
  is passed in with a TRUE value, then proxy settings are read from environment
  variables (see env_proxy() method below).  If C<env_proxy> isn't provided the
  C<PERL_LWP_ENV_PROXY> environment variable controls if env_proxy() is called
  during initialization.  If the C<keep_alive> option is passed in, then a
  C<LWP::ConnCache> is set up (see conn_cache() method below).  The C<keep_alive>
  value is passed on as the C<total_capacity> for the connection cache.
  
  =item $ua->clone
  
  Returns a copy of the LWP::UserAgent object.
  
  =back
  
  =head1 ATTRIBUTES
  
  The settings of the configuration attributes modify the behaviour of the
  C<LWP::UserAgent> when it dispatches requests.  Most of these can also
  be initialized by options passed to the constructor method.
  
  The following attribute methods are provided.  The attribute value is
  left unchanged if no argument is given.  The return value from each
  method is the old attribute value.
  
  =over
  
  =item $ua->agent
  
  =item $ua->agent( $product_id )
  
  Get/set the product token that is used to identify the user agent on
  the network.  The agent value is sent as the "User-Agent" header in
  the requests.  The default is the string returned by the _agent()
  method (see below).
  
  If the $product_id ends with space then the _agent() string is
  appended to it.
  
  The user agent string should be one or more simple product identifiers
  with an optional version number separated by the "/" character.
  Examples are:
  
    $ua->agent('Checkbot/0.4 ' . $ua->_agent);
    $ua->agent('Checkbot/0.4 ');    # same as above
    $ua->agent('Mozilla/5.0');
    $ua->agent("");                 # don't identify
  
  =item $ua->_agent
  
  Returns the default agent identifier.  This is a string of the form
  "libwww-perl/#.###", where "#.###" is substituted with the version number
  of this library.
  
  =item $ua->from
  
  =item $ua->from( $email_address )
  
  Get/set the e-mail address for the human user who controls
  the requesting user agent.  The address should be machine-usable, as
  defined in RFC 822.  The C<from> value is send as the "From" header in
  the requests.  Example:
  
    $ua->from('gaas@cpan.org');
  
  The default is to not send a "From" header.  See the default_headers()
  method for the more general interface that allow any header to be defaulted.
  
  =item $ua->cookie_jar
  
  =item $ua->cookie_jar( $cookie_jar_obj )
  
  Get/set the cookie jar object to use.  The only requirement is that
  the cookie jar object must implement the extract_cookies($request) and
  add_cookie_header($response) methods.  These methods will then be
  invoked by the user agent as requests are sent and responses are
  received.  Normally this will be a C<HTTP::Cookies> object or some
  subclass.
  
  The default is to have no cookie_jar, i.e. never automatically add
  "Cookie" headers to the requests.
  
  Shortcut: If a reference to a plain hash is passed in as the
  $cookie_jar_object, then it is replaced with an instance of
  C<HTTP::Cookies> that is initialized based on the hash.  This form also
  automatically loads the C<HTTP::Cookies> module.  It means that:
  
    $ua->cookie_jar({ file => "$ENV{HOME}/.cookies.txt" });
  
  is really just a shortcut for:
  
    require HTTP::Cookies;
    $ua->cookie_jar(HTTP::Cookies->new(file => "$ENV{HOME}/.cookies.txt"));
  
  =item $ua->default_headers
  
  =item $ua->default_headers( $headers_obj )
  
  Get/set the headers object that will provide default header values for
  any requests sent.  By default this will be an empty C<HTTP::Headers>
  object.
  
  =item $ua->default_header( $field )
  
  =item $ua->default_header( $field => $value )
  
  This is just a short-cut for $ua->default_headers->header( $field =>
  $value ). Example:
  
    $ua->default_header('Accept-Encoding' => scalar HTTP::Message::decodable());
    $ua->default_header('Accept-Language' => "no, en");
  
  =item $ua->conn_cache
  
  =item $ua->conn_cache( $cache_obj )
  
  Get/set the C<LWP::ConnCache> object to use.  See L<LWP::ConnCache>
  for details.
  
  =item $ua->credentials( $netloc, $realm )
  
  =item $ua->credentials( $netloc, $realm, $uname, $pass )
  
  Get/set the user name and password to be used for a realm.
  
  The $netloc is a string of the form "<host>:<port>".  The username and
  password will only be passed to this server.  Example:
  
    $ua->credentials("www.example.com:80", "Some Realm", "foo", "secret");
  
  =item $ua->local_address
  
  =item $ua->local_address( $address )
  
  Get/set the local interface to bind to for network connections.  The interface
  can be specified as a hostname or an IP address.  This value is passed as the
  C<LocalAddr> argument to L<IO::Socket::INET>.
  
  =item $ua->max_size
  
  =item $ua->max_size( $bytes )
  
  Get/set the size limit for response content.  The default is C<undef>,
  which means that there is no limit.  If the returned response content
  is only partial, because the size limit was exceeded, then a
  "Client-Aborted" header will be added to the response.  The content
  might end up longer than C<max_size> as we abort once appending a
  chunk of data makes the length exceed the limit.  The "Content-Length"
  header, if present, will indicate the length of the full content and
  will normally not be the same as C<< length($res->content) >>.
  
  =item $ua->max_redirect
  
  =item $ua->max_redirect( $n )
  
  This reads or sets the object's limit of how many times it will obey
  redirection responses in a given request cycle.
  
  By default, the value is 7. This means that if you call request()
  method and the response is a redirect elsewhere which is in turn a
  redirect, and so on seven times, then LWP gives up after that seventh
  request.
  
  =item $ua->parse_head
  
  =item $ua->parse_head( $boolean )
  
  Get/set a value indicating whether we should initialize response
  headers from the E<lt>head> section of HTML documents. The default is
  TRUE.  Do not turn this off, unless you know what you are doing.
  
  =item $ua->protocols_allowed
  
  =item $ua->protocols_allowed( \@protocols )
  
  This reads (or sets) this user agent's list of protocols that the
  request methods will exclusively allow.  The protocol names are case
  insensitive.
  
  For example: C<$ua-E<gt>protocols_allowed( [ 'http', 'https'] );>
  means that this user agent will I<allow only> those protocols,
  and attempts to use this user agent to access URLs with any other
  schemes (like "ftp://...") will result in a 500 error.
  
  To delete the list, call: C<$ua-E<gt>protocols_allowed(undef)>
  
  By default, an object has neither a C<protocols_allowed> list, nor a
  C<protocols_forbidden> list.
  
  Note that having a C<protocols_allowed> list causes any
  C<protocols_forbidden> list to be ignored.
  
  =item $ua->protocols_forbidden
  
  =item $ua->protocols_forbidden( \@protocols )
  
  This reads (or sets) this user agent's list of protocols that the
  request method will I<not> allow. The protocol names are case
  insensitive.
  
  For example: C<$ua-E<gt>protocols_forbidden( [ 'file', 'mailto'] );>
  means that this user agent will I<not> allow those protocols, and
  attempts to use this user agent to access URLs with those schemes
  will result in a 500 error.
  
  To delete the list, call: C<$ua-E<gt>protocols_forbidden(undef)>
  
  =item $ua->requests_redirectable
  
  =item $ua->requests_redirectable( \@requests )
  
  This reads or sets the object's list of request names that
  C<$ua-E<gt>redirect_ok(...)> will allow redirection for.  By
  default, this is C<['GET', 'HEAD']>, as per RFC 2616.  To
  change to include 'POST', consider:
  
     push @{ $ua->requests_redirectable }, 'POST';
  
  =item $ua->show_progress
  
  =item $ua->show_progress( $boolean )
  
  Get/set a value indicating whether a progress bar should be displayed
  on on the terminal as requests are processed. The default is FALSE.
  
  =item $ua->timeout
  
  =item $ua->timeout( $secs )
  
  Get/set the timeout value in seconds. The default timeout() value is
  180 seconds, i.e. 3 minutes.
  
  The requests is aborted if no activity on the connection to the server
  is observed for C<timeout> seconds.  This means that the time it takes
  for the complete transaction and the request() method to actually
  return might be longer.
  
  =item $ua->ssl_opts
  
  =item $ua->ssl_opts( $key )
  
  =item $ua->ssl_opts( $key => $value )
  
  Get/set the options for SSL connections.  Without argument return the list
  of options keys currently set.  With a single argument return the current
  value for the given option.  With 2 arguments set the option value and return
  the old.  Setting an option to the value C<undef> removes this option.
  
  The options that LWP relates to are:
  
  =over
  
  =item C<verify_hostname> => $bool
  
  When TRUE LWP will for secure protocol schemes ensure it connects to servers
  that have a valid certificate matching the expected hostname.  If FALSE no
  checks are made and you can't be sure that you communicate with the expected peer.
  The no checks behaviour was the default for libwww-perl-5.837 and earlier releases.
  
  This option is initialized from the L<PERL_LWP_SSL_VERIFY_HOSTNAME> environment
  variable.  If this environment variable isn't set; then C<verify_hostname>
  defaults to 1.
  
  =item C<SSL_ca_file> => $path
  
  The path to a file containing Certificate Authority certificates.
  A default setting for this option is provided by checking the environment
  variables C<PERL_LWP_SSL_CA_FILE> and C<HTTPS_CA_FILE> in order.
  
  =item C<SSL_ca_path> => $path
  
  The path to a directory containing files containing Certificate Authority
  certificates.
  A default setting for this option is provided by checking the environment
  variables C<PERL_LWP_SSL_CA_PATH> and C<HTTPS_CA_DIR> in order.
  
  =back
  
  Other options can be set and are processed directly by the SSL Socket implementation
  in use.  See L<IO::Socket::SSL> or L<Net::SSL> for details.
  
  The libwww-perl core no longer bundles protocol plugins for SSL.  You will need
  to install L<LWP::Protocol::https> separately to enable support for processing
  https-URLs.
  
  =back
  
  =head2 Proxy attributes
  
  The following methods set up when requests should be passed via a
  proxy server.
  
  =over
  
  =item $ua->proxy(\@schemes, $proxy_url)
  
  =item $ua->proxy($scheme, $proxy_url)
  
  Set/retrieve proxy URL for a scheme:
  
   $ua->proxy(['http', 'ftp'], 'http://proxy.sn.no:8001/');
   $ua->proxy('gopher', 'http://proxy.sn.no:8001/');
  
  The first form specifies that the URL is to be used for proxying of
  access methods listed in the list in the first method argument,
  i.e. 'http' and 'ftp'.
  
  The second form shows a shorthand form for specifying
  proxy URL for a single access scheme.
  
  =item $ua->no_proxy( $domain, ... )
  
  Do not proxy requests to the given domains.  Calling no_proxy without
  any domains clears the list of domains. Eg:
  
   $ua->no_proxy('localhost', 'example.com');
  
  =item $ua->env_proxy
  
  Load proxy settings from *_proxy environment variables.  You might
  specify proxies like this (sh-syntax):
  
    gopher_proxy=http://proxy.my.place/
    wais_proxy=http://proxy.my.place/
    no_proxy="localhost,example.com"
    export gopher_proxy wais_proxy no_proxy
  
  csh or tcsh users should use the C<setenv> command to define these
  environment variables.
  
  On systems with case insensitive environment variables there exists a
  name clash between the CGI environment variables and the C<HTTP_PROXY>
  environment variable normally picked up by env_proxy().  Because of
  this C<HTTP_PROXY> is not honored for CGI scripts.  The
  C<CGI_HTTP_PROXY> environment variable can be used instead.
  
  =back
  
  =head2 Handlers
  
  Handlers are code that injected at various phases during the
  processing of requests.  The following methods are provided to manage
  the active handlers:
  
  =over
  
  =item $ua->add_handler( $phase => \&cb, %matchspec )
  
  Add handler to be invoked in the given processing phase.  For how to
  specify %matchspec see L<HTTP::Config/"Matching">.
  
  The possible values $phase and the corresponding callback signatures are:
  
  =over
  
  =item request_preprepare => sub { my($request, $ua, $h) = @_; ... }
  
  The handler is called before the C<request_prepare> and other standard
  initialization of of the request.  This can be used to set up headers
  and attributes that the C<request_prepare> handler depends on.  Proxy
  initialization should take place here; but in general don't register
  handlers for this phase.
  
  =item request_prepare => sub { my($request, $ua, $h) = @_; ... }
  
  The handler is called before the request is sent and can modify the
  request any way it see fit.  This can for instance be used to add
  certain headers to specific requests.
  
  The method can assign a new request object to $_[0] to replace the
  request that is sent fully.
  
  The return value from the callback is ignored.  If an exception is
  raised it will abort the request and make the request method return a
  "400 Bad request" response.
  
  =item request_send => sub { my($request, $ua, $h) = @_; ... }
  
  This handler gets a chance of handling requests before they're sent to the
  protocol handlers.  It should return an HTTP::Response object if it
  wishes to terminate the processing; otherwise it should return nothing.
  
  The C<response_header> and C<response_data> handlers will not be
  invoked for this response, but the C<response_done> will be.
  
  =item response_header => sub { my($response, $ua, $h) = @_; ... }
  
  This handler is called right after the response headers have been
  received, but before any content data.  The handler might set up
  handlers for data and might croak to abort the request.
  
  The handler might set the $response->{default_add_content} value to
  control if any received data should be added to the response object
  directly.  This will initially be false if the $ua->request() method
  was called with a $content_file or $content_cb argument; otherwise true.
  
  =item response_data => sub { my($response, $ua, $h, $data) = @_; ... }
  
  This handler is called for each chunk of data received for the
  response.  The handler might croak to abort the request.
  
  This handler needs to return a TRUE value to be called again for
  subsequent chunks for the same request.
  
  =item response_done => sub { my($response, $ua, $h) = @_; ... }
  
  The handler is called after the response has been fully received, but
  before any redirect handling is attempted.  The handler can be used to
  extract information or modify the response.
  
  =item response_redirect => sub { my($response, $ua, $h) = @_; ... }
  
  The handler is called in $ua->request after C<response_done>.  If the
  handler returns an HTTP::Request object we'll start over with processing
  this request instead.
  
  =back
  
  =item $ua->remove_handler( undef, %matchspec )
  
  =item $ua->remove_handler( $phase, %matchspec )
  
  Remove handlers that match the given %matchspec.  If $phase is not
  provided remove handlers from all phases.
  
  Be careful as calling this function with %matchspec that is not not
  specific enough can remove handlers not owned by you.  It's probably
  better to use the set_my_handler() method instead.
  
  The removed handlers are returned.
  
  =item $ua->set_my_handler( $phase, $cb, %matchspec )
  
  Set handlers private to the executing subroutine.  Works by defaulting
  an C<owner> field to the %matchspec that holds the name of the called
  subroutine.  You might pass an explicit C<owner> to override this.
  
  If $cb is passed as C<undef>, remove the handler.
  
  =item $ua->get_my_handler( $phase, %matchspec )
  
  =item $ua->get_my_handler( $phase, %matchspec, $init )
  
  Will retrieve the matching handler as hash ref.
  
  If C<$init> is passed passed as a TRUE value, create and add the
  handler if it's not found.  If $init is a subroutine reference, then
  it's called with the created handler hash as argument.  This sub might
  populate the hash with extra fields; especially the callback.  If
  $init is a hash reference, merge the hashes.
  
  =item $ua->handlers( $phase, $request )
  
  =item $ua->handlers( $phase, $response )
  
  Returns the handlers that apply to the given request or response at
  the given processing phase.
  
  =back
  
  =head1 REQUEST METHODS
  
  The methods described in this section are used to dispatch requests
  via the user agent.  The following request methods are provided:
  
  =over
  
  =item $ua->get( $url )
  
  =item $ua->get( $url , $field_name => $value, ... )
  
  This method will dispatch a C<GET> request on the given $url.  Further
  arguments can be given to initialize the headers of the request. These
  are given as separate name/value pairs.  The return value is a
  response object.  See L<HTTP::Response> for a description of the
  interface it provides.
  
  There will still be a response object returned when LWP can't connect to the
  server specified in the URL or when other failures in protocol handlers occur.
  These internal responses use the standard HTTP status codes, so the responses
  can't be differentiated by testing the response status code alone.  Error
  responses that LWP generates internally will have the "Client-Warning" header
  set to the value "Internal response".  If you need to differentiate these
  internal responses from responses that a remote server actually generates, you
  need to test this header value.
  
  Fields names that start with ":" are special.  These will not
  initialize headers of the request but will determine how the response
  content is treated.  The following special field names are recognized:
  
      :content_file   => $filename
      :content_cb     => \&callback
      :read_size_hint => $bytes
  
  If a $filename is provided with the C<:content_file> option, then the
  response content will be saved here instead of in the response
  object.  If a callback is provided with the C<:content_cb> option then
  this function will be called for each chunk of the response content as
  it is received from the server.  If neither of these options are
  given, then the response content will accumulate in the response
  object itself.  This might not be suitable for very large response
  bodies.  Only one of C<:content_file> or C<:content_cb> can be
  specified.  The content of unsuccessful responses will always
  accumulate in the response object itself, regardless of the
  C<:content_file> or C<:content_cb> options passed in.
  
  The C<:read_size_hint> option is passed to the protocol module which
  will try to read data from the server in chunks of this size.  A
  smaller value for the C<:read_size_hint> will result in a higher
  number of callback invocations.
  
  The callback function is called with 3 arguments: a chunk of data, a
  reference to the response object, and a reference to the protocol
  object.  The callback can abort the request by invoking die().  The
  exception message will show up as the "X-Died" header field in the
  response returned by the get() function.
  
  =item $ua->head( $url )
  
  =item $ua->head( $url , $field_name => $value, ... )
  
  This method will dispatch a C<HEAD> request on the given $url.
  Otherwise it works like the get() method described above.
  
  =item $ua->post( $url, \%form )
  
  =item $ua->post( $url, \@form )
  
  =item $ua->post( $url, \%form, $field_name => $value, ... )
  
  =item $ua->post( $url, $field_name => $value,... Content => \%form )
  
  =item $ua->post( $url, $field_name => $value,... Content => \@form )
  
  =item $ua->post( $url, $field_name => $value,... Content => $content )
  
  This method will dispatch a C<POST> request on the given $url, with
  %form or @form providing the key/value pairs for the fill-in form
  content. Additional headers and content options are the same as for
  the get() method.
  
  This method will use the POST() function from C<HTTP::Request::Common>
  to build the request.  See L<HTTP::Request::Common> for a details on
  how to pass form content and other advanced features.
  
  =item $ua->put( $url, \%form )
  
  =item $ua->put( $url, \@form )
  
  =item $ua->put( $url, \%form, $field_name => $value, ... )
  
  =item $ua->put( $url, $field_name => $value,... Content => \%form )
  
  =item $ua->put( $url, $field_name => $value,... Content => \@form )
  
  =item $ua->put( $url, $field_name => $value,... Content => $content )
  
  This method will dispatch a C<PUT> request on the given $url, with
  %form or @form providing the key/value pairs for the fill-in form
  content. Additional headers and content options are the same as for
  the get() method.
  
  This method will use the PUT() function from C<HTTP::Request::Common>
  to build the request.  See L<HTTP::Request::Common> for a details on
  how to pass form content and other advanced features.
  
  =item $ua->delete( $url )
  
  =item $ua->delete( $url, $field_name => $value, ... )
  
  This method will dispatch a C<DELETE> request on the given $url.  Additional
  headers and content options are the same as for the get() method.
  
  This method will use the DELETE() function from C<HTTP::Request::Common>
  to build the request.  See L<HTTP::Request::Common> for a details on
  how to pass form content and other advanced features.
  
  =item $ua->mirror( $url, $filename )
  
  This method will get the document identified by $url and store it in
  file called $filename.  If the file already exists, then the request
  will contain an "If-Modified-Since" header matching the modification
  time of the file.  If the document on the server has not changed since
  this time, then nothing happens.  If the document has been updated, it
  will be downloaded again.  The modification time of the file will be
  forced to match that of the server.
  
  The return value is the the response object.
  
  =item $ua->request( $request )
  
  =item $ua->request( $request, $content_file )
  
  =item $ua->request( $request, $content_cb )
  
  =item $ua->request( $request, $content_cb, $read_size_hint )
  
  This method will dispatch the given $request object.  Normally this
  will be an instance of the C<HTTP::Request> class, but any object with
  a similar interface will do.  The return value is a response object.
  See L<HTTP::Request> and L<HTTP::Response> for a description of the
  interface provided by these classes.
  
  The request() method will process redirects and authentication
  responses transparently.  This means that it may actually send several
  simple requests via the simple_request() method described below.
  
  The request methods described above; get(), head(), post() and
  mirror(), will all dispatch the request they build via this method.
  They are convenience methods that simply hides the creation of the
  request object for you.
  
  The $content_file, $content_cb and $read_size_hint all correspond to
  options described with the get() method above.
  
  You are allowed to use a CODE reference as C<content> in the request
  object passed in.  The C<content> function should return the content
  when called.  The content can be returned in chunks.  The content
  function will be invoked repeatedly until it return an empty string to
  signal that there is no more content.
  
  =item $ua->simple_request( $request )
  
  =item $ua->simple_request( $request, $content_file )
  
  =item $ua->simple_request( $request, $content_cb )
  
  =item $ua->simple_request( $request, $content_cb, $read_size_hint )
  
  This method dispatches a single request and returns the response
  received.  Arguments are the same as for request() described above.
  
  The difference from request() is that simple_request() will not try to
  handle redirects or authentication responses.  The request() method
  will in fact invoke this method for each simple request it sends.
  
  =item $ua->is_online
  
  Tries to determine if you have access to the Internet.  Returns
  TRUE if the built-in heuristics determine that the user agent is
  able to access the Internet (over HTTP).  See also L<LWP::Online>.
  
  =item $ua->is_protocol_supported( $scheme )
  
  You can use this method to test whether this user agent object supports the
  specified C<scheme>.  (The C<scheme> might be a string (like 'http' or
  'ftp') or it might be an URI object reference.)
  
  Whether a scheme is supported, is determined by the user agent's
  C<protocols_allowed> or C<protocols_forbidden> lists (if any), and by
  the capabilities of LWP.  I.e., this will return TRUE only if LWP
  supports this protocol I<and> it's permitted for this particular
  object.
  
  =back
  
  =head2 Callback methods
  
  The following methods will be invoked as requests are processed. These
  methods are documented here because subclasses of C<LWP::UserAgent>
  might want to override their behaviour.
  
  =over
  
  =item $ua->prepare_request( $request )
  
  This method is invoked by simple_request().  Its task is to modify the
  given $request object by setting up various headers based on the
  attributes of the user agent. The return value should normally be the
  $request object passed in.  If a different request object is returned
  it will be the one actually processed.
  
  The headers affected by the base implementation are; "User-Agent",
  "From", "Range" and "Cookie".
  
  =item $ua->redirect_ok( $prospective_request, $response )
  
  This method is called by request() before it tries to follow a
  redirection to the request in $response.  This should return a TRUE
  value if this redirection is permissible.  The $prospective_request
  will be the request to be sent if this method returns TRUE.
  
  The base implementation will return FALSE unless the method
  is in the object's C<requests_redirectable> list,
  FALSE if the proposed redirection is to a "file://..."
  URL, and TRUE otherwise.
  
  =item $ua->get_basic_credentials( $realm, $uri, $isproxy )
  
  This is called by request() to retrieve credentials for documents
  protected by Basic or Digest Authentication.  The arguments passed in
  is the $realm provided by the server, the $uri requested and a boolean
  flag to indicate if this is authentication against a proxy server.
  
  The method should return a username and password.  It should return an
  empty list to abort the authentication resolution attempt.  Subclasses
  can override this method to prompt the user for the information. An
  example of this can be found in C<lwp-request> program distributed
  with this library.
  
  The base implementation simply checks a set of pre-stored member
  variables, set up with the credentials() method.
  
  =item $ua->progress( $status, $request_or_response )
  
  This is called frequently as the response is received regardless of
  how the content is processed.  The method is called with $status
  "begin" at the start of processing the request and with $state "end"
  before the request method returns.  In between these $status will be
  the fraction of the response currently received or the string "tick"
  if the fraction can't be calculated.
  
  When $status is "begin" the second argument is the request object,
  otherwise it is the response object.
  
  =back
  
  =head1 SEE ALSO
  
  See L<LWP> for a complete overview of libwww-perl5.  See L<lwpcook>
  and the scripts F<lwp-request> and F<lwp-download> for examples of
  usage.
  
  See L<HTTP::Request> and L<HTTP::Response> for a description of the
  message objects dispatched and received.  See L<HTTP::Request::Common>
  and L<HTML::Form> for other ways to build request objects.
  
  See L<WWW::Mechanize> and L<WWW::Search> for examples of more
  specialized user agents based on C<LWP::UserAgent>.
  
  =head1 COPYRIGHT
  
  Copyright 1995-2009 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
LWP_USERAGENT

$fatpacked{"LWP/UserAgent/Determined.pm"} = <<'LWP_USERAGENT_DETERMINED';
  
  package LWP::UserAgent::Determined;
  
  $VERSION = '1.06';
  use      LWP::UserAgent ();
  @ISA = ('LWP::UserAgent');
  
  use strict;
  die "Where's _elem?!!?" unless __PACKAGE__->can('_elem');
  
  sub timing                { shift->_elem('timing' , @_) }
  sub codes_to_determinate  { shift->_elem('codes_to_determinate' , @_) }
  sub before_determined_callback { shift->_elem('before_determined_callback' , @_) }
  sub  after_determined_callback { shift->_elem( 'after_determined_callback' , @_) }
  
  #==========================================================================
  
  sub simple_request {
    my($self, @args) = @_;
    my(@timing_tries) = ( $self->timing() =~ m<(\d+(?:\.\d+)*)>g );
    my $determination = $self->codes_to_determinate();
  
    my $resp;
    my $before_c = $self->before_determined_callback;
    my $after_c  = $self->after_determined_callback;
    foreach my $pause_if_unsuccessful (@timing_tries, undef) {
      
      $before_c and $before_c->(
        $self, \@timing_tries, $pause_if_unsuccessful, $determination, \@args);
      $resp = $self->SUPER::simple_request(@args);
      $after_c and $after_c->(
        $self, \@timing_tries, $pause_if_unsuccessful, $determination, \@args, $resp);
  
      my $code = $resp->code;
      unless( $determination->{$code} ) { # normal case: all is well (or 404, etc)
        return $resp;
      }
      if(defined $pause_if_unsuccessful) { # it's undef only on the last
  
        sleep $pause_if_unsuccessful if $pause_if_unsuccessful;
      }
    }
    
    return $resp;
  }
  
  #--------------------------------------------------------------------------
  
  sub new {
    my $self = shift->SUPER::new(@_);
    $self->_determined_init();
    return $self;
  }
  
  #--------------------------------------------------------------------------
  
  sub _determined_init {
    my $self = shift;
    $self->timing( '1,3,15' );
    $self->codes_to_determinate( { map { $_=>1 }
     '408', # Request Timeout
     '500', # Internal Server Error
     '502', # Bad Gateway
     '503', # Service Unavailable
     '504', # Gateway Timeout
    } );
    return;
  }
  
  #==========================================================================
  
  1;
  __END__
  
  
  =head1 NAME
  
  LWP::UserAgent::Determined - a virtual browser that retries errors
  
  =head1 SYNOPSIS
  
    use strict;
    use LWP::UserAgent::Determined;
    my $browser = LWP::UserAgent::Determined->new;
    my $response = $browser->get($url, headers... );
  
  =head1 DESCRIPTION
  
  This class works just like L<LWP::UserAgent> (and is based on it, by
  being a subclass of it), except that when you use it to get a web page
  but run into a possibly-temporary error (like a DNS lookup timeout),
  it'll wait a few seconds and retry a few times.
  
  It also adds some methods for controlling exactly what errors are
  considered retry-worthy and how many times to wait and for how many
  seconds, but normally you needn't bother about these, as the default
  settings are relatively sane.
  
  =head1 METHODS
  
  This module inherits all of L<LWP::UserAgent>'s methods,
  and adds the following.
  
  =over
  
  =item $timing_string = $browser->timing();
  
  =item $browser->timing( "10,30,90" )
  
  The C<timing> method gets or sets the string that controls how many
  times it should retry, and how long the pauses should be.
  
  If you specify empty-string, this means not to retry at all.
  
  If you specify a string consisting of a single number, like "10", that
  means that if the first request doesn't succeed, then
  C<< $browser->get(...) >> (or any other method based on C<request>
  or C<simple_request>)
  should wait 10 seconds and try again (and if that fails, then
  it's final).
  
  If you specify a string with several numbers in it (like "10,30,90"),
  then that means C<$browser> can I<re>try as that many times (i.e., one
  initial try, I<plus> a maximum of the three retries, because three numbers
  there), and that it should wait first those numbers of seconds each time.
  So C<< $browser->timing( "10,30,90" ) >> basically means:
  
    try the request; return it unless it's a temporary-looking error;
    sleep 10;
    retry the request; return it unless it's a temporary-looking error;
    sleep 30;
    retry the request; return it unless it's a temporary-looking error;
    sleep 90  the request;
    return it;
  
  The default value is "1,3,15".
  
  
  
  =item $http_codes_hr = $browser->codes_to_determinate();
  
  This returns the hash that is the set of HTTP codes that merit a retry
  (like 500 and 408, but unlike 404 or 200).  You can delete or add
  entries like so;
  
    $http_codes_hr = $browser->codes_to_determinate();
    delete $http_codes_hr->{408};
    $http_codes_hr->{567} = 1;
  
  (You can actually set a whole new hashset with C<<
  $browser->codes_to_determinate($new_hr) >>, but there's usually no
  benefit to that as opposed to the above.)
  
  The current default is 408 (Timeout) plus some 5xx codes.
  
  
  
  =item $browser->before_determined_callback()
  
  =item $browser->before_determined_callback( \&some_routine );
  
  =item $browser->after_determined_callback()
  
  =item $browser->after_determined_callback( \&some_routine );
  
  These read (first two) or set (second two) callbacks that are
  called before the actual HTTP/FTP/etc request is made.  By default,
  these are set to undef, meaning nothing special is called.  If you
  want to alter try requests, or inspect responses before any retrying
  is considered, you can set up these callbacks.
  
  The arguments passed to these routines are:
  
  =over
  
  =item 0: the current $browser object
  
  =item 1: an arrayref to the list of timing pauses (based on $browser->timing)
  
  =item 2: the duration of the number of seconds we'll pause if this request
  fails this time, or undef if this is the last chance.
  
  =item 3: the value of $browser->codes_to_determinate
  
  =item 4: an arrayref of the arguments we pass to LWP::UserAgent::simple_request
  (the first of which is the request object)
  
  =item (5): And, only for after_determined_callback, the response we
  just got.
  
  =back
  
  Example use:
  
    $browser->before_determined_callback( sub {
      print "Trying ", $_[4][0]->uri, " ...\n";
    });
  
  =back
  
  
  =head1 IMPLEMENTATION
  
  This class works by overriding LWP::UserAgent's C<simple_request> method
  with its own around-method that just loops.  See the source of this
  module; it's straightforward.  Relatively.
  
  
  =head1 SEE ALSO
  
  L<LWP>, L<LWP::UserAgent>
  
  
  =head1 COPYRIGHT AND DISCLAIMER
  
  Copyright 2004, Sean M. Burke, all rights
  reserved.  This program is free software; you can redistribute it
  and/or modify it under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful,
  but without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  
  =head1 AUTHOR
  
  Originally created by Sean M. Burke, C<sburke@cpan.org>
  
  Currently maintained by Jesse Vincent C<jesse@fsck.com>
  
  =cut
  
LWP_USERAGENT_DETERMINED

$fatpacked{"Locale/Maketext/Simple.pm"} = <<'LOCALE_MAKETEXT_SIMPLE';
  package Locale::Maketext::Simple;
  $Locale::Maketext::Simple::VERSION = '0.21';
  
  use strict;
  use 5.005;
  
  =head1 NAME
  
  Locale::Maketext::Simple - Simple interface to Locale::Maketext::Lexicon
  
  =head1 VERSION
  
  This document describes version 0.18 of Locale::Maketext::Simple,
  released Septermber 8, 2006.
  
  =head1 SYNOPSIS
  
  Minimal setup (looks for F<auto/Foo/*.po> and F<auto/Foo/*.mo>):
  
      package Foo;
      use Locale::Maketext::Simple;	# exports 'loc'
      loc_lang('fr');			# set language to French
      sub hello {
  	print loc("Hello, [_1]!", "World");
      }
  
  More sophisticated example:
  
      package Foo::Bar;
      use Locale::Maketext::Simple (
  	Class	    => 'Foo',	    # search in auto/Foo/
  	Style	    => 'gettext',   # %1 instead of [_1]
  	Export	    => 'maketext',  # maketext() instead of loc()
  	Subclass    => 'L10N',	    # Foo::L10N instead of Foo::I18N
  	Decode	    => 1,	    # decode entries to unicode-strings
  	Encoding    => 'locale',    # but encode lexicons in current locale
  				    # (needs Locale::Maketext::Lexicon 0.36)
      );
      sub japh {
  	print maketext("Just another %1 hacker", "Perl");
      }
  
  =head1 DESCRIPTION
  
  This module is a simple wrapper around B<Locale::Maketext::Lexicon>,
  designed to alleviate the need of creating I<Language Classes> for
  module authors.
  
  The language used is chosen from the loc_lang call. If a lookup is not
  possible, the i-default language will be used. If the lookup is not in the
  i-default language, then the key will be returned.
  
  If B<Locale::Maketext::Lexicon> is not present, it implements a
  minimal localization function by simply interpolating C<[_1]> with
  the first argument, C<[_2]> with the second, etc.  Interpolated
  function like C<[quant,_1]> are treated as C<[_1]>, with the sole
  exception of C<[tense,_1,X]>, which will append C<ing> to C<_1> when
  X is C<present>, or appending C<ed> to <_1> otherwise.
  
  =head1 OPTIONS
  
  All options are passed either via the C<use> statement, or via an
  explicit C<import>.
  
  =head2 Class
  
  By default, B<Locale::Maketext::Simple> draws its source from the
  calling package's F<auto/> directory; you can override this behaviour
  by explicitly specifying another package as C<Class>.
  
  =head2 Path
  
  If your PO and MO files are under a path elsewhere than C<auto/>,
  you may specify it using the C<Path> option.
  
  =head2 Style
  
  By default, this module uses the C<maketext> style of C<[_1]> and
  C<[quant,_1]> for interpolation.  Alternatively, you can specify the
  C<gettext> style, which uses C<%1> and C<%quant(%1)> for interpolation.
  
  This option is case-insensitive.
  
  =head2 Export
  
  By default, this module exports a single function, C<loc>, into its
  caller's namespace.  You can set it to another name, or set it to
  an empty string to disable exporting.
  
  =head2 Subclass
  
  By default, this module creates an C<::I18N> subclass under the
  caller's package (or the package specified by C<Class>), and stores
  lexicon data in its subclasses.  You can assign a name other than
  C<I18N> via this option.
  
  =head2 Decode
  
  If set to a true value, source entries will be converted into
  utf8-strings (available in Perl 5.6.1 or later).  This feature
  needs the B<Encode> or B<Encode::compat> module.
  
  =head2 Encoding
  
  Specifies an encoding to store lexicon entries, instead of
  utf8-strings.  If set to C<locale>, the encoding from the current
  locale setting is used.  Implies a true value for C<Decode>.
  
  =cut
  
  sub import {
      my ($class, %args) = @_;
  
      $args{Class}    ||= caller;
      $args{Style}    ||= 'maketext';
      $args{Export}   ||= 'loc';
      $args{Subclass} ||= 'I18N';
  
      my ($loc, $loc_lang) = $class->load_loc(%args);
      $loc ||= $class->default_loc(%args);
  
      no strict 'refs';
      *{caller(0) . "::$args{Export}"} = $loc if $args{Export};
      *{caller(0) . "::$args{Export}_lang"} = $loc_lang || sub { 1 };
  }
  
  my %Loc;
  
  sub reload_loc { %Loc = () }
  
  sub load_loc {
      my ($class, %args) = @_;
  
      my $pkg = join('::', grep { defined and length } $args{Class}, $args{Subclass});
      return $Loc{$pkg} if exists $Loc{$pkg};
  
      eval { require Locale::Maketext::Lexicon; 1 }   or return;
      $Locale::Maketext::Lexicon::VERSION > 0.20	    or return;
      eval { require File::Spec; 1 }		    or return;
  
      my $path = $args{Path} || $class->auto_path($args{Class}) or return;
      my $pattern = File::Spec->catfile($path, '*.[pm]o');
      my $decode = $args{Decode} || 0;
      my $encoding = $args{Encoding} || undef;
  
      $decode = 1 if $encoding;
  
      $pattern =~ s{\\}{/}g; # to counter win32 paths
  
      eval "
  	package $pkg;
  	use base 'Locale::Maketext';
  	Locale::Maketext::Lexicon->import({
  	    'i-default' => [ 'Auto' ],
  	    '*'	=> [ Gettext => \$pattern ],
  	    _decode => \$decode,
  	    _encoding => \$encoding,
  	});
  	*${pkg}::Lexicon = \\%${pkg}::i_default::Lexicon;
  	*tense = sub { \$_[1] . ((\$_[2] eq 'present') ? 'ing' : 'ed') }
  	    unless defined &tense;
  
  	1;
      " or die $@;
  
      my $lh = eval { $pkg->get_handle } or return;
      my $style = lc($args{Style});
      if ($style eq 'maketext') {
  	$Loc{$pkg} = sub {
  	    $lh->maketext(@_)
  	};
      }
      elsif ($style eq 'gettext') {
  	$Loc{$pkg} = sub {
  	    my $str = shift;
              $str =~ s{([\~\[\]])}{~$1}g;
              $str =~ s{
                  ([%\\]%)                        # 1 - escaped sequence
              |
                  %   (?:
                          ([A-Za-z#*]\w*)         # 2 - function call
                              \(([^\)]*)\)        # 3 - arguments
                      |
                          ([1-9]\d*|\*)           # 4 - variable
                      )
              }{
                  $1 ? $1
                     : $2 ? "\[$2,"._unescape($3)."]"
                          : "[_$4]"
              }egx;
  	    return $lh->maketext($str, @_);
  	};
      }
      else {
  	die "Unknown Style: $style";
      }
  
      return $Loc{$pkg}, sub {
  	$lh = $pkg->get_handle(@_);
      };
  }
  
  sub default_loc {
      my ($self, %args) = @_;
      my $style = lc($args{Style});
      if ($style eq 'maketext') {
  	return sub {
  	    my $str = shift;
              $str =~ s{((?<!~)(?:~~)*)\[_([1-9]\d*|\*)\]}
                       {$1%$2}g;
              $str =~ s{((?<!~)(?:~~)*)\[([A-Za-z#*]\w*),([^\]]+)\]}
                       {"$1%$2(" . _escape($3) . ')'}eg;
  	    _default_gettext($str, @_);
  	};
      }
      elsif ($style eq 'gettext') {
  	return \&_default_gettext;
      }
      else {
  	die "Unknown Style: $style";
      }
  }
  
  sub _default_gettext {
      my $str = shift;
      $str =~ s{
  	%			# leading symbol
  	(?:			# either one of
  	    \d+			#   a digit, like %1
  	    |			#     or
  	    (\w+)\(		#   a function call -- 1
  		(?:		#     either
  		    %\d+	#	an interpolation
  		    |		#     or
  		    ([^,]*)	#	some string -- 2
  		)		#     end either
  		(?:		#     maybe followed
  		    ,		#       by a comma
  		    ([^),]*)	#       and a param -- 3
  		)?		#     end maybe
  		(?:		#     maybe followed
  		    ,		#       by another comma
  		    ([^),]*)	#       and a param -- 4
  		)?		#     end maybe
  		[^)]*		#     and other ignorable params
  	    \)			#   closing function call
  	)			# closing either one of
      }{
  	my $digit = $2 || shift;
  	$digit . (
  	    $1 ? (
  		($1 eq 'tense') ? (($3 eq 'present') ? 'ing' : 'ed') :
  		($1 eq 'quant') ? ' ' . (($digit > 1) ? ($4 || "$3s") : $3) :
  		''
  	    ) : ''
  	);
      }egx;
      return $str;
  };
  
  sub _escape {
      my $text = shift;
      $text =~ s/\b_([1-9]\d*)/%$1/g;
      return $text;
  }
  
  sub _unescape {
      join(',', map {
          /\A(\s*)%([1-9]\d*|\*)(\s*)\z/ ? "$1_$2$3" : $_
      } split(/,/, $_[0]));
  }
  
  sub auto_path {
      my ($self, $calldir) = @_;
      $calldir =~ s#::#/#g;
      my $path = $INC{$calldir . '.pm'} or return;
  
      # Try absolute path name.
      if ($^O eq 'MacOS') {
  	(my $malldir = $calldir) =~ tr#/#:#;
  	$path =~ s#^(.*)$malldir\.pm\z#$1auto:$malldir:#s;
      } else {
  	$path =~ s#^(.*)$calldir\.pm\z#$1auto/$calldir/#;
      }
  
      return $path if -d $path;
  
      # If that failed, try relative path with normal @INC searching.
      $path = "auto/$calldir/";
      foreach my $inc (@INC) {
  	return "$inc/$path" if -d "$inc/$path";
      }
  
      return;
  }
  
  1;
  
  =head1 ACKNOWLEDGMENTS
  
  Thanks to Jos I. Boumans for suggesting this module to be written.
  
  Thanks to Chia-Liang Kao for suggesting C<Path> and C<loc_lang>.
  
  =head1 SEE ALSO
  
  L<Locale::Maketext>, L<Locale::Maketext::Lexicon>
  
  =head1 AUTHORS
  
  Audrey Tang E<lt>cpan@audreyt.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2003, 2004, 2005, 2006 by Audrey Tang E<lt>cpan@audreyt.orgE<gt>.
  
  This software is released under the MIT license cited below.  Additionally,
  when this software is distributed with B<Perl Kit, Version 5>, you may also
  redistribute it and/or modify it under the same terms as Perl itself.
  
  =head2 The "MIT" License
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
  
  =cut
LOCALE_MAKETEXT_SIMPLE

$fatpacked{"Log/Syslog/Constants.pm"} = <<'LOG_SYSLOG_CONSTANTS';
  package Log::Syslog::Constants;
  
  use 5.6.2;
  use strict;
  use warnings;
  
  our $VERSION = '1.02';
  
  # severities
  use constant LOG_EMERG      => 0; # system is unusable
  use constant LOG_ALERT      => 1; # action must be taken immediately
  use constant LOG_CRIT       => 2; # critical conditions
  use constant LOG_ERR        => 3; # error conditions
  use constant LOG_WARNING    => 4; # warning conditions
  use constant LOG_NOTICE     => 5; # normal but significant condition
  use constant LOG_INFO       => 6; # informational
  use constant LOG_DEBUG      => 7; # debug-level messages
  
  # facilities
  use constant LOG_KERN       => 0; # kernel messages
  use constant LOG_USER       => 1; # random user-level messages
  use constant LOG_MAIL       => 2; # mail system
  use constant LOG_DAEMON     => 3; # system daemons
  use constant LOG_AUTH       => 4; # security/authorization messages
  use constant LOG_SYSLOG     => 5; # messages generated internally by syslogd
  use constant LOG_LPR        => 6; # line printer subsystem
  use constant LOG_NEWS       => 7; # network news subsystem
  use constant LOG_UUCP       => 8; # UUCP subsystem
  use constant LOG_CRON       => 9; # clock daemon
  use constant LOG_AUTHPRIV   => 10; # security/authorization messages (private)
  use constant LOG_FTP        => 11; # ftp daemon
  use constant LOG_LOCAL0     => 16; # reserved for local use
  use constant LOG_LOCAL1     => 17; # reserved for local use
  use constant LOG_LOCAL2     => 18; # reserved for local use
  use constant LOG_LOCAL3     => 19; # reserved for local use
  use constant LOG_LOCAL4     => 20; # reserved for local use
  use constant LOG_LOCAL5     => 21; # reserved for local use
  use constant LOG_LOCAL6     => 22; # reserved for local use
  use constant LOG_LOCAL7     => 23; # reserved for local use
  
  my %_severities_by_name = (
      emerg    => LOG_EMERG,
      alert    => LOG_ALERT,
      crit     => LOG_CRIT,
      err      => LOG_ERR,
      warning  => LOG_WARNING,
      notice   => LOG_NOTICE,
      info     => LOG_INFO,
      debug    => LOG_DEBUG,
  );
  
  my %_facilities_by_name = (
      kern     => LOG_KERN,
      user     => LOG_USER,
      mail     => LOG_MAIL,
      daemon   => LOG_DAEMON,
      auth     => LOG_AUTH,
      syslog   => LOG_SYSLOG,
      lpr      => LOG_LPR,
      news     => LOG_NEWS,
      uucp     => LOG_UUCP,
      cron     => LOG_CRON,
      authpriv => LOG_AUTHPRIV,
      ftp      => LOG_FTP,
      local0   => LOG_LOCAL0,
      local1   => LOG_LOCAL1,
      local2   => LOG_LOCAL2,
      local3   => LOG_LOCAL3,
      local4   => LOG_LOCAL4,
      local5   => LOG_LOCAL5,
      local6   => LOG_LOCAL6,
      local7   => LOG_LOCAL7,
  );
  
  sub get_severity {
      $_severities_by_name{lc $_[0]};
  }
  
  sub get_facility {
      $_facilities_by_name{lc $_[0]};
  }
  
  require Exporter;
  
  our @ISA = qw(Exporter);
  
  our %EXPORT_TAGS = (
      severities   => [qw/
          LOG_EMERG LOG_ALERT LOG_CRIT LOG_ERR LOG_WARNING
          LOG_NOTICE LOG_INFO LOG_DEBUG
      /],
      facilities => [qw/
          LOG_KERN LOG_USER LOG_MAIL LOG_DAEMON LOG_AUTH
          LOG_SYSLOG LOG_LPR LOG_NEWS LOG_UUCP LOG_CRON
          LOG_AUTHPRIV LOG_FTP LOG_LOCAL0 LOG_LOCAL1 LOG_LOCAL2
          LOG_LOCAL3 LOG_LOCAL4 LOG_LOCAL5 LOG_LOCAL6 LOG_LOCAL7
      /],
      functions => [qw/
          get_severity get_facility
      /],
  );
  @{ $EXPORT_TAGS{'all'} } = (
      @{ $EXPORT_TAGS{'facilities'} },
      @{ $EXPORT_TAGS{'severities'} },
      @{ $EXPORT_TAGS{'functions'} },
  );
  
  our @EXPORT_OK = @{ $EXPORT_TAGS{'all'} };
  our @EXPORT = qw();
  
  1;
  
  __END__
  
  =head1 NAME
  
  Log::Syslog::Constants - Perl extension containing syslog priority constants as
  defined in RFC3164.
  
  =head1 SYNOPSIS
  
    use Log::Syslog::Constants ':all';
  
    @severities = (
      LOG_EMERG, LOG_ALERT, LOG_CRIT, LOG_ERR, LOG_WARNING, LOG_NOTICE, LOG_INFO,
      LOG_DEBUG
    );
  
    @facilities = (
      LOG_KERN, LOG_USER, LOG_MAIL, LOG_DAEMON, LOG_AUTH, LOG_SYSLOG, LOG_LPR,
      LOG_NEWS, LOG_UUCP, LOG_CRON, LOG_AUTHPRIV, LOG_FTP, LOG_LOCAL0,
      LOG_LOCAL1, LOG_LOCAL2, LOG_LOCAL3, LOG_LOCAL4, LOG_LOCAL5, LOG_LOCAL6,
      LOG_LOCAL7
    );
  
    $info_constant = get_severity('INFO');
    $local0_constant = get_facility('local0');
  
  =head1 DESCRIPTION
  
  Syslog messages--as standardized in RFC3164--embed a priority number (the PRI
  part) which is composed of a severity and a facility value. The constants which
  encode these values are specified in section 4.1.1, and are made available by
  this module. For instance, the exportable LOG_FTP constant has a value of 11,
  the value for the FTP facility.
  
  =head1 EXPORTS
  
  Nothing is exported by default. You may optionally import individual constants
  and functions or groups of them:
  
    use Log::Syslog::Constants qw(:severities); # LOG_CRIT, LOG_DEBUG, etc
    use Log::Syslog::Constants qw(:facilities); # LOG_CRON, LOG_LOCAL3, etc
    use Log::Syslog::Constants qw(:functions); # get_facility, get_severity
    use Log::Syslog::Constants qw(:all); # all of the above
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item * get_facility($facility_string)
  
  =item * get_severity($severity_string)
  
  These functions look up a constant value by name, e.g.
  C<get_severity('info') == LOG_INFO>.
  
  =back
  
  =head1 SEE ALSO
  
  L<RFC3164|http://www.ietf.org/rfc/rfc3164.txt>
  
  =head1 AUTHOR
  
  Adam Thomason, E<lt>athomason@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2010-2011 by Say Media, Inc.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.8.5 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
LOG_SYSLOG_CONSTANTS

$fatpacked{"Log/Syslog/Fast/PP.pm"} = <<'LOG_SYSLOG_FAST_PP';
  package Log::Syslog::Fast::PP;
  
  use 5.006002;
  use strict;
  use warnings;
  
  require Exporter;
  use Carp 'croak';
  
  our @ISA = qw(Exporter);
  
  # protocols
  use constant LOG_UDP    => 0; # UDP
  use constant LOG_TCP    => 1; # TCP
  use constant LOG_UNIX   => 2; # UNIX socket
  
  # format
  use constant LOG_RFC3164 => 0;
  use constant LOG_RFC5424 => 1;
  
  use POSIX 'strftime';
  use IO::Socket::INET;
  use IO::Socket::UNIX;
  
  our %EXPORT_TAGS = (
      protos => [qw/ LOG_TCP LOG_UDP LOG_UNIX /],
      formats => [qw/ LOG_RFC3164 LOG_RFC5424 /],
  );
  push @{ $EXPORT_TAGS{'all'} }, @{ $EXPORT_TAGS{'protos'} };
  push @{ $EXPORT_TAGS{'all'} }, @{ $EXPORT_TAGS{'formats'} };
  
  our @EXPORT_OK = @{ $EXPORT_TAGS{'all'} };
  our @EXPORT = qw();
  
  use constant PRIORITY   => 0;
  use constant SENDER     => 1;
  use constant NAME       => 2;
  use constant PID        => 3;
  use constant SOCK       => 4;
  use constant LAST_TIME  => 5;
  use constant PREFIX     => 6;
  use constant PREFIX_LEN => 7;
  use constant FORMAT     => 8;
  
  sub new {
      my $ref = shift;
      my $class = ref $ref || $ref;
  
      my ($proto, $hostname, $port, $facility, $severity, $sender, $name) = @_;
  
      my $self = bless [
          ($facility << 3) | $severity, # prio
          $sender, # sender
          $name, # name
          $$, # pid
          undef, # sock
          undef, # last_time
          undef, # prefix
          undef, # prefix_len
          LOG_RFC3164, # format
      ], $class;
  
      $self->update_prefix(time());
  
      $self->set_receiver($proto, $hostname, $port);
  
      return $self;
  }
  
  sub update_prefix {
      my $self = shift;
      my $t = shift;
  
      $self->[LAST_TIME] = $t;
  
      my $timestr = strftime("%h %e %T", localtime $t);
      if ($self->[FORMAT] == LOG_RFC5424) {
          $timestr = strftime("%Y-%m-%dT%H:%M:%S%z", localtime $t);
      }
  
      $self->[PREFIX] = sprintf "<%d>%s %s %s[%d]: ",
          $self->[PRIORITY], $timestr, $self->[SENDER], $self->[NAME], $self->[PID];
      if ($self->[FORMAT] == LOG_RFC5424) {
          $self->[PREFIX] = sprintf "<%d>1 %s %s %s %d - - ",
              $self->[PRIORITY], $timestr, $self->[SENDER], $self->[NAME], $self->[PID];
      }
  }
  
  sub set_receiver {
      my $self = shift;
      my ($proto, $hostname, $port) = @_;
  
      if ($proto == LOG_TCP) {
          $self->[SOCK] = IO::Socket::INET->new(
              Proto    => 'tcp',
              PeerHost => $hostname,
              PeerPort => $port,
          );
      }
      elsif ($proto == LOG_UDP) {
          $self->[SOCK] = IO::Socket::INET->new(
              Proto    => 'udp',
              PeerHost => $hostname,
              PeerPort => $port,
          );
      }
      elsif ($proto == LOG_UNIX) {
          eval {
              $self->[SOCK] = IO::Socket::UNIX->new(
                  Proto => SOCK_STREAM,
                  Peer  => $hostname,
              );
          };
          if ($@ || !$self->[SOCK]) {
              $self->[SOCK] = IO::Socket::UNIX->new(
                  Proto => SOCK_DGRAM,
                  Peer  => $hostname,
              );
          }
      }
  
      die "Error in ->set_receiver: $!" unless $self->[SOCK];
  }
  
  sub set_priority {
      my $self = shift;
      my ($facility, $severity) = @_;
      $self->[PRIORITY] = ($facility << 3) | $severity;
      $self->update_prefix(time);
  }
  
  sub set_facility {
      my $self = shift;
      $self->set_priority(shift, $self->get_severity);
  }
  
  sub set_severity {
      my $self = shift;
      $self->set_priority($self->get_facility, shift);
  }
  
  sub set_sender {
      my $self = shift;
      $self->[SENDER] = shift;
      $self->update_prefix(time);
  }
  
  sub set_name {
      my $self = shift;
      $self->[NAME] = shift;
      $self->update_prefix(time);
  }
  
  sub set_pid {
      my $self = shift;
      $self->[PID] = shift;
      $self->update_prefix(time);
  }
  
  sub set_format {
      my $self = shift;
      $self->[FORMAT] = shift;
      $self->update_prefix(time);
  }
  
  sub send {
      my $now = $_[2] || time;
  
      # update the prefix if seconds have rolled over
      if ($now != $_[0][LAST_TIME]) {
          $_[0]->update_prefix($now);
      }
  
      send $_[0][SOCK], $_[0][PREFIX] . $_[1], 0;
  }
  
  sub get_priority {
      my $self = shift;
      return $self->[PRIORITY];
  }
  
  sub get_facility {
      my $self = shift;
      return $self->[PRIORITY] >> 3;
  }
  
  sub get_severity {
      my $self = shift;
      return $self->[PRIORITY] & 7;
  }
  
  sub get_sender {
      my $self = shift;
      return $self->[SENDER];
  }
  
  sub get_name {
      my $self = shift;
      return $self->[NAME];
  }
  
  sub get_pid {
      my $self = shift;
      return $self->[PID];
  }
  
  sub get_format {
      my $self = shift;
      return $self->[FORMAT];
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Log::Syslog::Fast::PP - XS-free, API-compatible version of Log::Syslog::Fast
  
  =head1 SYNOPSIS
  
    use Log::Syslog::Fast::PP ':all';
    my $logger = Log::Syslog::Fast::PP->new(LOG_UDP, "127.0.0.1", 514, LOG_LOCAL0, LOG_INFO, "mymachine", "logger");
    $logger->send("log message", time);
  
  =head1 DESCRIPTION
  
  This module should be fully API-compatible with L<Log::Syslog::Fast>; refer to
  its documentation for usage.
  
  =head1 AUTHOR
  
  Adam Thomason, E<lt>athomason@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2009-2011 by Say Media, Inc.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.8.5 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
LOG_SYSLOG_FAST_PP

$fatpacked{"Module/Load.pm"} = <<'MODULE_LOAD';
  package Module::Load;
  
  $VERSION = '0.24';
  
  use strict;
  use File::Spec ();
  
  sub import {
      my $who = _who();
  
      {   no strict 'refs';
          *{"${who}::load"} = *load;
      }
  }
  
  sub load (*;@)  {
      my $mod = shift or return;
      my $who = _who();
  
      if( _is_file( $mod ) ) {
          require $mod;
      } else {
          LOAD: {
              my $err;
              for my $flag ( qw[1 0] ) {
                  my $file = _to_file( $mod, $flag);
                  eval { require $file };
                  $@ ? $err .= $@ : last LOAD;
              }
              die $err if $err;
          }
      }
  
      ### This addresses #41883: Module::Load cannot import
      ### non-Exporter module. ->import() routines weren't
      ### properly called when load() was used.
      {   no strict 'refs';
          my $import;
          if (@_ and $import = $mod->can('import')) {
              unshift @_, $mod;
              goto &$import;
          }
      }
  }
  
  sub _to_file{
      local $_    = shift;
      my $pm      = shift || '';
  
      ## trailing blanks ignored by default. [rt #69886]
      my @parts = split /::|'/, $_, -1;
      ## make sure that we can't hop out of @INC
      shift @parts if @parts && !$parts[0];
  
      ### because of [perl #19213], see caveats ###
      my $file = $^O eq 'MSWin32'
                      ? join "/", @parts
                      : File::Spec->catfile( @parts );
  
      $file   .= '.pm' if $pm;
  
      ### on perl's before 5.10 (5.9.5@31746) if you require
      ### a file in VMS format, it's stored in %INC in VMS
      ### format. Therefor, better unixify it first
      ### Patch in reply to John Malmbergs patch (as mentioned
      ### above) on p5p Tue 21 Aug 2007 04:55:07
      $file = VMS::Filespec::unixify($file) if $^O eq 'VMS';
  
      return $file;
  }
  
  sub _who { (caller(1))[0] }
  
  sub _is_file {
      local $_ = shift;
      return  /^\./               ? 1 :
              /[^\w:']/           ? 1 :
              undef
      #' silly bbedit..
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Module::Load - runtime require of both modules and files
  
  =head1 SYNOPSIS
  
  	use Module::Load;
  
      my $module = 'Data:Dumper';
      load Data::Dumper;      # loads that module
      load 'Data::Dumper';    # ditto
      load $module            # tritto
  
      my $script = 'some/script.pl'
      load $script;
      load 'some/script.pl';	# use quotes because of punctuations
  
      load thing;             # try 'thing' first, then 'thing.pm'
  
      load CGI, ':standard'   # like 'use CGI qw[:standard]'
  
  
  =head1 DESCRIPTION
  
  C<load> eliminates the need to know whether you are trying to require
  either a file or a module.
  
  If you consult C<perldoc -f require> you will see that C<require> will
  behave differently when given a bareword or a string.
  
  In the case of a string, C<require> assumes you are wanting to load a
  file. But in the case of a bareword, it assumes you mean a module.
  
  This gives nasty overhead when you are trying to dynamically require
  modules at runtime, since you will need to change the module notation
  (C<Acme::Comment>) to a file notation fitting the particular platform
  you are on.
  
  C<load> eliminates the need for this overhead and will just DWYM.
  
  =head1 Rules
  
  C<load> has the following rules to decide what it thinks you want:
  
  =over 4
  
  =item *
  
  If the argument has any characters in it other than those matching
  C<\w>, C<:> or C<'>, it must be a file
  
  =item *
  
  If the argument matches only C<[\w:']>, it must be a module
  
  =item *
  
  If the argument matches only C<\w>, it could either be a module or a
  file. We will try to find C<file.pm> first in C<@INC> and if that
  fails, we will try to find C<file> in @INC.  If both fail, we die with
  the respective error messages.
  
  =back
  
  =head1 Caveats
  
  Because of a bug in perl (#19213), at least in version 5.6.1, we have
  to hardcode the path separator for a require on Win32 to be C</>, like
  on Unix rather than the Win32 C<\>. Otherwise perl will not read its
  own %INC accurately double load files if they are required again, or
  in the worst case, core dump.
  
  C<Module::Load> cannot do implicit imports, only explicit imports.
  (in other words, you always have to specify explicitly what you wish
  to import from a module, even if the functions are in that modules'
  C<@EXPORT>)
  
  =head1 ACKNOWLEDGEMENTS
  
  Thanks to Jonas B. Nielsen for making explicit imports work.
  
  =head1 BUG REPORTS
  
  Please report bugs or other issues to E<lt>bug-module-load@rt.cpan.org<gt>.
  
  =head1 AUTHOR
  
  This module by Jos Boumans E<lt>kane@cpan.orgE<gt>.
  
  =head1 COPYRIGHT
  
  This library is free software; you may redistribute and/or modify it
  under the same terms as Perl itself.
  
  
  =cut
MODULE_LOAD

$fatpacked{"Module/Load/Conditional.pm"} = <<'MODULE_LOAD_CONDITIONAL';
  package Module::Load::Conditional;
  
  use strict;
  
  use Module::Load;
  use Params::Check                       qw[check];
  use Locale::Maketext::Simple Style  => 'gettext';
  
  use Carp        ();
  use File::Spec  ();
  use FileHandle  ();
  use version;
  
  use Module::Metadata ();
  
  use constant ON_VMS   => $^O eq 'VMS';
  use constant ON_WIN32 => $^O eq 'MSWin32' ? 1 : 0;
  use constant QUOTE    => do { ON_WIN32 ? q["] : q['] };
  
  BEGIN {
      use vars        qw[ $VERSION @ISA $VERBOSE $CACHE @EXPORT_OK $DEPRECATED
                          $FIND_VERSION $ERROR $CHECK_INC_HASH];
      use Exporter;
      @ISA            = qw[Exporter];
      $VERSION        = '0.58';
      $VERBOSE        = 0;
      $DEPRECATED     = 0;
      $FIND_VERSION   = 1;
      $CHECK_INC_HASH = 0;
      @EXPORT_OK      = qw[check_install can_load requires];
  }
  
  =pod
  
  =head1 NAME
  
  Module::Load::Conditional - Looking up module information / loading at runtime
  
  =head1 SYNOPSIS
  
      use Module::Load::Conditional qw[can_load check_install requires];
  
  
      my $use_list = {
              CPANPLUS        => 0.05,
              LWP             => 5.60,
              'Test::More'    => undef,
      };
  
      print can_load( modules => $use_list )
              ? 'all modules loaded successfully'
              : 'failed to load required modules';
  
  
      my $rv = check_install( module => 'LWP', version => 5.60 )
                  or print 'LWP is not installed!';
  
      print 'LWP up to date' if $rv->{uptodate};
      print "LWP version is $rv->{version}\n";
      print "LWP is installed as file $rv->{file}\n";
  
  
      print "LWP requires the following modules to be installed:\n";
      print join "\n", requires('LWP');
  
      ### allow M::L::C to peek in your %INC rather than just
      ### scanning @INC
      $Module::Load::Conditional::CHECK_INC_HASH = 1;
  
      ### reset the 'can_load' cache
      undef $Module::Load::Conditional::CACHE;
  
      ### don't have Module::Load::Conditional issue warnings --
      ### default is '1'
      $Module::Load::Conditional::VERBOSE = 0;
  
      ### The last error that happened during a call to 'can_load'
      my $err = $Module::Load::Conditional::ERROR;
  
  
  =head1 DESCRIPTION
  
  Module::Load::Conditional provides simple ways to query and possibly load any of
  the modules you have installed on your system during runtime.
  
  It is able to load multiple modules at once or none at all if one of
  them was not able to load. It also takes care of any error checking
  and so forth.
  
  =head1 Methods
  
  =head2 $href = check_install( module => NAME [, version => VERSION, verbose => BOOL ] );
  
  C<check_install> allows you to verify if a certain module is installed
  or not. You may call it with the following arguments:
  
  =over 4
  
  =item module
  
  The name of the module you wish to verify -- this is a required key
  
  =item version
  
  The version this module needs to be -- this is optional
  
  =item verbose
  
  Whether or not to be verbose about what it is doing -- it will default
  to $Module::Load::Conditional::VERBOSE
  
  =back
  
  It will return undef if it was not able to find where the module was
  installed, or a hash reference with the following keys if it was able
  to find the file:
  
  =over 4
  
  =item file
  
  Full path to the file that contains the module
  
  =item dir
  
  Directory, or more exact the C<@INC> entry, where the module was
  loaded from.
  
  =item version
  
  The version number of the installed module - this will be C<undef> if
  the module had no (or unparsable) version number, or if the variable
  C<$Module::Load::Conditional::FIND_VERSION> was set to true.
  (See the C<GLOBAL VARIABLES> section below for details)
  
  =item uptodate
  
  A boolean value indicating whether or not the module was found to be
  at least the version you specified. If you did not specify a version,
  uptodate will always be true if the module was found.
  If no parsable version was found in the module, uptodate will also be
  true, since C<check_install> had no way to verify clearly.
  
  See also C<$Module::Load::Conditional::DEPRECATED>, which affects
  the outcome of this value.
  
  =back
  
  =cut
  
  ### this checks if a certain module is installed already ###
  ### if it returns true, the module in question is already installed
  ### or we found the file, but couldn't open it, OR there was no version
  ### to be found in the module
  ### it will return 0 if the version in the module is LOWER then the one
  ### we are looking for, or if we couldn't find the desired module to begin with
  ### if the installed version is higher or equal to the one we want, it will return
  ### a hashref with he module name and version in it.. so 'true' as well.
  sub check_install {
      my %hash = @_;
  
      my $tmpl = {
              version => { default    => '0.0'    },
              module  => { required   => 1        },
              verbose => { default    => $VERBOSE },
      };
  
      my $args;
      unless( $args = check( $tmpl, \%hash, $VERBOSE ) ) {
          warn loc( q[A problem occurred checking arguments] ) if $VERBOSE;
          return;
      }
  
      my $file     = File::Spec->catfile( split /::/, $args->{module} ) . '.pm';
      my $file_inc = File::Spec::Unix->catfile(
                          split /::/, $args->{module}
                      ) . '.pm';
  
      ### where we store the return value ###
      my $href = {
              file        => undef,
              version     => undef,
              uptodate    => undef,
      };
  
      my $filename;
  
      ### check the inc hash if we're allowed to
      if( $CHECK_INC_HASH ) {
          $filename = $href->{'file'} =
              $INC{ $file_inc } if defined $INC{ $file_inc };
  
          ### find the version by inspecting the package
          if( defined $filename && $FIND_VERSION ) {
              no strict 'refs';
              $href->{version} = ${ "$args->{module}"."::VERSION" };
          }
      }
  
      ### we didn't find the filename yet by looking in %INC,
      ### so scan the dirs
      unless( $filename ) {
  
          DIR: for my $dir ( @INC ) {
  
              my $fh;
  
              if ( ref $dir ) {
                  ### @INC hook -- we invoke it and get the filehandle back
                  ### this is actually documented behaviour as of 5.8 ;)
  
                  my $existed_in_inc = $INC{$file_inc};
  
                  if (UNIVERSAL::isa($dir, 'CODE')) {
                      ($fh) = $dir->($dir, $file);
  
                  } elsif (UNIVERSAL::isa($dir, 'ARRAY')) {
                      ($fh) = $dir->[0]->($dir, $file, @{$dir}{1..$#{$dir}})
  
                  } elsif (UNIVERSAL::can($dir, 'INC')) {
                      ($fh) = $dir->INC($file);
                  }
  
                  if (!UNIVERSAL::isa($fh, 'GLOB')) {
                      warn loc(q[Cannot open file '%1': %2], $file, $!)
                              if $args->{verbose};
                      next;
                  }
  
                  $filename = $INC{$file_inc} || $file;
  
                  delete $INC{$file_inc} if not $existed_in_inc;
  
              } else {
                  $filename = File::Spec->catfile($dir, $file);
                  next unless -e $filename;
  
                  $fh = new FileHandle;
                  if (!$fh->open($filename)) {
                      warn loc(q[Cannot open file '%1': %2], $file, $!)
                              if $args->{verbose};
                      next;
                  }
              }
  
              ### store the directory we found the file in
              $href->{dir} = $dir;
  
              ### files need to be in unix format under vms,
              ### or they might be loaded twice
              $href->{file} = ON_VMS
                  ? VMS::Filespec::unixify( $filename )
                  : $filename;
  
              ### if we don't need the version, we're done
              last DIR unless $FIND_VERSION;
  
              ### otherwise, the user wants us to find the version from files
              my $mod_info = Module::Metadata->new_from_handle( $fh, $filename );
              my $ver      = $mod_info->version( $args->{module} );
  
              if( defined $ver ) {
                  $href->{version} = $ver;
  
                  last DIR;
              }
          }
      }
  
      ### if we couldn't find the file, return undef ###
      return unless defined $href->{file};
  
      ### only complain if we're expected to find a version higher than 0.0 anyway
      if( $FIND_VERSION and not defined $href->{version} ) {
          {   ### don't warn about the 'not numeric' stuff ###
              local $^W;
  
              ### if we got here, we didn't find the version
              warn loc(q[Could not check version on '%1'], $args->{module} )
                      if $args->{verbose} and $args->{version} > 0;
          }
          $href->{uptodate} = 1;
  
      } else {
          ### don't warn about the 'not numeric' stuff ###
          local $^W;
  
          ### use qv(), as it will deal with developer release number
          ### ie ones containing _ as well. This addresses bug report
          ### #29348: Version compare logic doesn't handle alphas?
          ###
          ### Update from JPeacock: apparently qv() and version->new
          ### are different things, and we *must* use version->new
          ### here, or things like #30056 might start happening
  
          ### We have to wrap this in an eval as version-0.82 raises
          ### exceptions and not warnings now *sigh*
  
          eval {
  
            $href->{uptodate} =
              version->new( $args->{version} ) <= version->new( $href->{version} )
                  ? 1
                  : 0;
  
          };
      }
  
      if ( $DEPRECATED and "$]" >= 5.011 ) {
          require Module::CoreList;
          require Config;
  
          $href->{uptodate} = 0 if
             exists $Module::CoreList::version{ 0+$] }{ $args->{module} } and
             Module::CoreList::is_deprecated( $args->{module} ) and
             $Config::Config{privlibexp} eq $href->{dir};
      }
  
      return $href;
  }
  
  =head2 $bool = can_load( modules => { NAME => VERSION [,NAME => VERSION] }, [verbose => BOOL, nocache => BOOL] )
  
  C<can_load> will take a list of modules, optionally with version
  numbers and determine if it is able to load them. If it can load *ALL*
  of them, it will. If one or more are unloadable, none will be loaded.
  
  This is particularly useful if you have More Than One Way (tm) to
  solve a problem in a program, and only wish to continue down a path
  if all modules could be loaded, and not load them if they couldn't.
  
  This function uses the C<load> function from Module::Load under the
  hood.
  
  C<can_load> takes the following arguments:
  
  =over 4
  
  =item modules
  
  This is a hashref of module/version pairs. The version indicates the
  minimum version to load. If no version is provided, any version is
  assumed to be good enough.
  
  =item verbose
  
  This controls whether warnings should be printed if a module failed
  to load.
  The default is to use the value of $Module::Load::Conditional::VERBOSE.
  
  =item nocache
  
  C<can_load> keeps its results in a cache, so it will not load the
  same module twice, nor will it attempt to load a module that has
  already failed to load before. By default, C<can_load> will check its
  cache, but you can override that by setting C<nocache> to true.
  
  =cut
  
  sub can_load {
      my %hash = @_;
  
      my $tmpl = {
          modules     => { default => {}, strict_type => 1 },
          verbose     => { default => $VERBOSE },
          nocache     => { default => 0 },
      };
  
      my $args;
  
      unless( $args = check( $tmpl, \%hash, $VERBOSE ) ) {
          $ERROR = loc(q[Problem validating arguments!]);
          warn $ERROR if $VERBOSE;
          return;
      }
  
      ### layout of $CACHE:
      ### $CACHE = {
      ###     $ module => {
      ###             usable  => BOOL,
      ###             version => \d,
      ###             file    => /path/to/file,
      ###     },
      ### };
  
      $CACHE ||= {}; # in case it was undef'd
  
      my $error;
      BLOCK: {
          my $href = $args->{modules};
  
          my @load;
          for my $mod ( keys %$href ) {
  
              next if $CACHE->{$mod}->{usable} && !$args->{nocache};
  
              ### else, check if the hash key is defined already,
              ### meaning $mod => 0,
              ### indicating UNSUCCESSFUL prior attempt of usage
  
              ### use qv(), as it will deal with developer release number
              ### ie ones containing _ as well. This addresses bug report
              ### #29348: Version compare logic doesn't handle alphas?
              ###
              ### Update from JPeacock: apparently qv() and version->new
              ### are different things, and we *must* use version->new
              ### here, or things like #30056 might start happening
              if (    !$args->{nocache}
                      && defined $CACHE->{$mod}->{usable}
                      && (version->new( $CACHE->{$mod}->{version}||0 )
                          >= version->new( $href->{$mod} ) )
              ) {
                  $error = loc( q[Already tried to use '%1', which was unsuccessful], $mod);
                  last BLOCK;
              }
  
              my $mod_data = check_install(
                                      module  => $mod,
                                      version => $href->{$mod}
                                  );
  
              if( !$mod_data or !defined $mod_data->{file} ) {
                  $error = loc(q[Could not find or check module '%1'], $mod);
                  $CACHE->{$mod}->{usable} = 0;
                  last BLOCK;
              }
  
              map {
                  $CACHE->{$mod}->{$_} = $mod_data->{$_}
              } qw[version file uptodate];
  
              push @load, $mod;
          }
  
          for my $mod ( @load ) {
  
              if ( $CACHE->{$mod}->{uptodate} ) {
  
                  eval { load $mod };
  
                  ### in case anything goes wrong, log the error, the fact
                  ### we tried to use this module and return 0;
                  if( $@ ) {
                      $error = $@;
                      $CACHE->{$mod}->{usable} = 0;
                      last BLOCK;
                  } else {
                      $CACHE->{$mod}->{usable} = 1;
                  }
  
              ### module not found in @INC, store the result in
              ### $CACHE and return 0
              } else {
  
                  $error = loc(q[Module '%1' is not uptodate!], $mod);
                  $CACHE->{$mod}->{usable} = 0;
                  last BLOCK;
              }
          }
  
      } # BLOCK
  
      if( defined $error ) {
          $ERROR = $error;
          Carp::carp( loc(q|%1 [THIS MAY BE A PROBLEM!]|,$error) ) if $args->{verbose};
          return;
      } else {
          return 1;
      }
  }
  
  =back
  
  =head2 @list = requires( MODULE );
  
  C<requires> can tell you what other modules a particular module
  requires. This is particularly useful when you're intending to write
  a module for public release and are listing its prerequisites.
  
  C<requires> takes but one argument: the name of a module.
  It will then first check if it can actually load this module, and
  return undef if it can't.
  Otherwise, it will return a list of modules and pragmas that would
  have been loaded on the module's behalf.
  
  Note: The list C<require> returns has originated from your current
  perl and your current install.
  
  =cut
  
  sub requires {
      my $who = shift;
  
      unless( check_install( module => $who ) ) {
          warn loc(q[You do not have module '%1' installed], $who) if $VERBOSE;
          return undef;
      }
  
      my $lib = join " ", map { qq["-I$_"] } @INC;
      my $oneliner = 'print(join(qq[\n],map{qq[BONG=$_]}keys(%INC)),qq[\n])';
      my $cmd = join '', qq["$^X" $lib -M$who -e], QUOTE, $oneliner, QUOTE;
  
      return  sort
                  grep { !/^$who$/  }
                  map  { chomp; s|/|::|g; $_ }
                  grep { s|\.pm$||i; }
                  map  { s!^BONG\=!!; $_ }
                  grep { m!^BONG\=! }
              `$cmd`;
  }
  
  1;
  
  __END__
  
  =head1 Global Variables
  
  The behaviour of Module::Load::Conditional can be altered by changing the
  following global variables:
  
  =head2 $Module::Load::Conditional::VERBOSE
  
  This controls whether Module::Load::Conditional will issue warnings and
  explanations as to why certain things may have failed. If you set it
  to 0, Module::Load::Conditional will not output any warnings.
  The default is 0;
  
  =head2 $Module::Load::Conditional::FIND_VERSION
  
  This controls whether Module::Load::Conditional will try to parse
  (and eval) the version from the module you're trying to load.
  
  If you don't wish to do this, set this variable to C<false>. Understand
  then that version comparisons are not possible, and Module::Load::Conditional
  can not tell you what module version you have installed.
  This may be desirable from a security or performance point of view.
  Note that C<$FIND_VERSION> code runs safely under C<taint mode>.
  
  The default is 1;
  
  =head2 $Module::Load::Conditional::CHECK_INC_HASH
  
  This controls whether C<Module::Load::Conditional> checks your
  C<%INC> hash to see if a module is available. By default, only
  C<@INC> is scanned to see if a module is physically on your
  filesystem, or available via an C<@INC-hook>. Setting this variable
  to C<true> will trust any entries in C<%INC> and return them for
  you.
  
  The default is 0;
  
  =head2 $Module::Load::Conditional::CACHE
  
  This holds the cache of the C<can_load> function. If you explicitly
  want to remove the current cache, you can set this variable to
  C<undef>
  
  =head2 $Module::Load::Conditional::ERROR
  
  This holds a string of the last error that happened during a call to
  C<can_load>. It is useful to inspect this when C<can_load> returns
  C<undef>.
  
  =head2 $Module::Load::Conditional::DEPRECATED
  
  This controls whether C<Module::Load::Conditional> checks if
  a dual-life core module has been deprecated. If this is set to
  true C<check_install> will return false to C<uptodate>, if
  a dual-life module is found to be loaded from C<$Config{privlibexp}>
  
  The default is 0;
  
  =head1 See Also
  
  C<Module::Load>
  
  =head1 BUG REPORTS
  
  Please report bugs or other issues to E<lt>bug-module-load-conditional@rt.cpan.orgE<gt>.
  
  =head1 AUTHOR
  
  This module by Jos Boumans E<lt>kane@cpan.orgE<gt>.
  
  =head1 COPYRIGHT
  
  This library is free software; you may redistribute and/or modify it
  under the same terms as Perl itself.
  
  =cut
MODULE_LOAD_CONDITIONAL

$fatpacked{"Module/Metadata.pm"} = <<'MODULE_METADATA';
  # -*- mode: cperl; tab-width: 8; indent-tabs-mode: nil; basic-offset: 2 -*-
  # vim:ts=8:sw=2:et:sta:sts=2
  package Module::Metadata;
  
  # Adapted from Perl-licensed code originally distributed with
  # Module-Build by Ken Williams
  
  # This module provides routines to gather information about
  # perl modules (assuming this may be expanded in the distant
  # parrot future to look at other types of modules).
  
  use strict;
  use warnings;
  
  our $VERSION = '1.000019';
  $VERSION = eval $VERSION;
  
  use Carp qw/croak/;
  use File::Spec;
  use IO::File;
  use version 0.87;
  BEGIN {
    if ($INC{'Log/Contextual.pm'}) {
      Log::Contextual->import('log_info');
    } else {
      *log_info = sub (&) { warn $_[0]->() };
    }
  }
  use File::Find qw(find);
  
  my $V_NUM_REGEXP = qr{v?[0-9._]+};  # crudely, a v-string or decimal
  
  my $PKG_FIRST_WORD_REGEXP = qr{ # the FIRST word in a package name
    [a-zA-Z_]                     # the first word CANNOT start with a digit
      (?:
        [\w']?                    # can contain letters, digits, _, or ticks
        \w                        # But, NO multi-ticks or trailing ticks
      )*
  }x;
  
  my $PKG_ADDL_WORD_REGEXP = qr{ # the 2nd+ word in a package name
    \w                           # the 2nd+ word CAN start with digits
      (?:
        [\w']?                   # and can contain letters or ticks
        \w                       # But, NO multi-ticks or trailing ticks
      )*
  }x;
  
  my $PKG_NAME_REGEXP = qr{ # match a package name
    (?: :: )?               # a pkg name can start with aristotle
    $PKG_FIRST_WORD_REGEXP  # a package word
    (?:
      (?: :: )+             ### aristotle (allow one or many times)
      $PKG_ADDL_WORD_REGEXP ### a package word
    )*                      # ^ zero, one or many times
    (?:
      ::                    # allow trailing aristotle
    )?
  }x;
  
  my $PKG_REGEXP  = qr{   # match a package declaration
    ^[\s\{;]*             # intro chars on a line
    package               # the word 'package'
    \s+                   # whitespace
    ($PKG_NAME_REGEXP)    # a package name
    \s*                   # optional whitespace
    ($V_NUM_REGEXP)?        # optional version number
    \s*                   # optional whitesapce
    [;\{]                 # semicolon line terminator or block start (since 5.16)
  }x;
  
  my $VARNAME_REGEXP = qr{ # match fully-qualified VERSION name
    ([\$*])         # sigil - $ or *
    (
      (             # optional leading package name
        (?:::|\')?  # possibly starting like just :: (  la $::VERSION)
        (?:\w+(?:::|\'))*  # Foo::Bar:: ...
      )?
      VERSION
    )\b
  }x;
  
  my $VERS_REGEXP = qr{ # match a VERSION definition
    (?:
      \(\s*$VARNAME_REGEXP\s*\) # with parens
    |
      $VARNAME_REGEXP           # without parens
    )
    \s*
    =[^=~]  # = but not ==, nor =~
  }x;
  
  sub new_from_file {
    my $class    = shift;
    my $filename = File::Spec->rel2abs( shift );
  
    return undef unless defined( $filename ) && -f $filename;
    return $class->_init(undef, $filename, @_);
  }
  
  sub new_from_handle {
    my $class    = shift;
    my $handle   = shift;
    my $filename = shift;
    return undef unless defined($handle) && defined($filename);
    $filename = File::Spec->rel2abs( $filename );
  
    return $class->_init(undef, $filename, @_, handle => $handle);
  
  }
  
  
  sub new_from_module {
    my $class   = shift;
    my $module  = shift;
    my %props   = @_;
  
    $props{inc} ||= \@INC;
    my $filename = $class->find_module_by_name( $module, $props{inc} );
    return undef unless defined( $filename ) && -f $filename;
    return $class->_init($module, $filename, %props);
  }
  
  {
  
    my $compare_versions = sub {
      my ($v1, $op, $v2) = @_;
      $v1 = version->new($v1)
        unless UNIVERSAL::isa($v1,'version');
  
      my $eval_str = "\$v1 $op \$v2";
      my $result   = eval $eval_str;
      log_info { "error comparing versions: '$eval_str' $@" } if $@;
  
      return $result;
    };
  
    my $normalize_version = sub {
      my ($version) = @_;
      if ( $version =~ /[=<>!,]/ ) { # logic, not just version
        # take as is without modification
      }
      elsif ( ref $version eq 'version' ) { # version objects
        $version = $version->is_qv ? $version->normal : $version->stringify;
      }
      elsif ( $version =~ /^[^v][^.]*\.[^.]+\./ ) { # no leading v, multiple dots
        # normalize string tuples without "v": "1.2.3" -> "v1.2.3"
        $version = "v$version";
      }
      else {
        # leave alone
      }
      return $version;
    };
  
    # separate out some of the conflict resolution logic
  
    my $resolve_module_versions = sub {
      my $packages = shift;
  
      my( $file, $version );
      my $err = '';
        foreach my $p ( @$packages ) {
          if ( defined( $p->{version} ) ) {
    	if ( defined( $version ) ) {
     	  if ( $compare_versions->( $version, '!=', $p->{version} ) ) {
    	    $err .= "  $p->{file} ($p->{version})\n";
    	  } else {
    	    # same version declared multiple times, ignore
    	  }
    	} else {
    	  $file    = $p->{file};
    	  $version = $p->{version};
    	}
          }
          $file ||= $p->{file} if defined( $p->{file} );
        }
  
      if ( $err ) {
        $err = "  $file ($version)\n" . $err;
      }
  
      my %result = (
        file    => $file,
        version => $version,
        err     => $err
      );
  
      return \%result;
    };
  
    sub provides {
      my $class = shift;
  
      croak "provides() requires key/value pairs \n" if @_ % 2;
      my %args = @_;
  
      croak "provides() takes only one of 'dir' or 'files'\n"
        if $args{dir} && $args{files};
  
      croak "provides() requires a 'version' argument"
        unless defined $args{version};
  
      croak "provides() does not support version '$args{version}' metadata"
          unless grep { $args{version} eq $_ } qw/1.4 2/;
  
      $args{prefix} = 'lib' unless defined $args{prefix};
  
      my $p;
      if ( $args{dir} ) {
        $p = $class->package_versions_from_directory($args{dir});
      }
      else {
        croak "provides() requires 'files' to be an array reference\n"
          unless ref $args{files} eq 'ARRAY';
        $p = $class->package_versions_from_directory($args{files});
      }
  
      # Now, fix up files with prefix
      if ( length $args{prefix} ) { # check in case disabled with q{}
        $args{prefix} =~ s{/$}{};
        for my $v ( values %$p ) {
          $v->{file} = "$args{prefix}/$v->{file}";
        }
      }
  
      return $p
    }
  
    sub package_versions_from_directory {
      my ( $class, $dir, $files ) = @_;
  
      my @files;
  
      if ( $files ) {
        @files = @$files;
      } else {
        find( {
          wanted => sub {
            push @files, $_ if -f $_ && /\.pm$/;
          },
          no_chdir => 1,
        }, $dir );
      }
  
      # First, we enumerate all packages & versions,
      # separating into primary & alternative candidates
      my( %prime, %alt );
      foreach my $file (@files) {
        my $mapped_filename = File::Spec::Unix->abs2rel( $file, $dir );
        my @path = split( /\//, $mapped_filename );
        (my $prime_package = join( '::', @path )) =~ s/\.pm$//;
  
        my $pm_info = $class->new_from_file( $file );
  
        foreach my $package ( $pm_info->packages_inside ) {
          next if $package eq 'main';  # main can appear numerous times, ignore
          next if $package eq 'DB';    # special debugging package, ignore
          next if grep /^_/, split( /::/, $package ); # private package, ignore
  
          my $version = $pm_info->version( $package );
  
          $prime_package = $package if lc($prime_package) eq lc($package);
          if ( $package eq $prime_package ) {
            if ( exists( $prime{$package} ) ) {
              croak "Unexpected conflict in '$package'; multiple versions found.\n";
            } else {
              $mapped_filename = "$package.pm" if lc("$package.pm") eq lc($mapped_filename);
              $prime{$package}{file} = $mapped_filename;
              $prime{$package}{version} = $version if defined( $version );
            }
          } else {
            push( @{$alt{$package}}, {
                                      file    => $mapped_filename,
                                      version => $version,
                                     } );
          }
        }
      }
  
      # Then we iterate over all the packages found above, identifying conflicts
      # and selecting the "best" candidate for recording the file & version
      # for each package.
      foreach my $package ( keys( %alt ) ) {
        my $result = $resolve_module_versions->( $alt{$package} );
  
        if ( exists( $prime{$package} ) ) { # primary package selected
  
          if ( $result->{err} ) {
    	# Use the selected primary package, but there are conflicting
    	# errors among multiple alternative packages that need to be
    	# reported
            log_info {
    	    "Found conflicting versions for package '$package'\n" .
    	    "  $prime{$package}{file} ($prime{$package}{version})\n" .
    	    $result->{err}
            };
  
          } elsif ( defined( $result->{version} ) ) {
    	# There is a primary package selected, and exactly one
    	# alternative package
  
    	if ( exists( $prime{$package}{version} ) &&
    	     defined( $prime{$package}{version} ) ) {
    	  # Unless the version of the primary package agrees with the
    	  # version of the alternative package, report a conflict
    	  if ( $compare_versions->(
                   $prime{$package}{version}, '!=', $result->{version}
                 )
               ) {
  
              log_info {
                "Found conflicting versions for package '$package'\n" .
    	      "  $prime{$package}{file} ($prime{$package}{version})\n" .
    	      "  $result->{file} ($result->{version})\n"
              };
    	  }
  
    	} else {
    	  # The prime package selected has no version so, we choose to
    	  # use any alternative package that does have a version
    	  $prime{$package}{file}    = $result->{file};
    	  $prime{$package}{version} = $result->{version};
    	}
  
          } else {
    	# no alt package found with a version, but we have a prime
    	# package so we use it whether it has a version or not
          }
  
        } else { # No primary package was selected, use the best alternative
  
          if ( $result->{err} ) {
            log_info {
              "Found conflicting versions for package '$package'\n" .
    	    $result->{err}
            };
          }
  
          # Despite possible conflicting versions, we choose to record
          # something rather than nothing
          $prime{$package}{file}    = $result->{file};
          $prime{$package}{version} = $result->{version}
    	  if defined( $result->{version} );
        }
      }
  
      # Normalize versions.  Can't use exists() here because of bug in YAML::Node.
      # XXX "bug in YAML::Node" comment seems irrelevant -- dagolden, 2009-05-18
      for (grep defined $_->{version}, values %prime) {
        $_->{version} = $normalize_version->( $_->{version} );
      }
  
      return \%prime;
    }
  }
  
  
  sub _init {
    my $class    = shift;
    my $module   = shift;
    my $filename = shift;
    my %props = @_;
  
    my $handle = delete $props{handle};
    my( %valid_props, @valid_props );
    @valid_props = qw( collect_pod inc );
    @valid_props{@valid_props} = delete( @props{@valid_props} );
    warn "Unknown properties: @{[keys %props]}\n" if scalar( %props );
  
    my %data = (
      module       => $module,
      filename     => $filename,
      version      => undef,
      packages     => [],
      versions     => {},
      pod          => {},
      pod_headings => [],
      collect_pod  => 0,
  
      %valid_props,
    );
  
    my $self = bless(\%data, $class);
  
    if ( $handle ) {
      $self->_parse_fh($handle);
    }
    else {
      $self->_parse_file();
    }
  
    unless($self->{module} and length($self->{module})) {
      my ($v, $d, $f) = File::Spec->splitpath($self->{filename});
      if($f =~ /\.pm$/) {
        $f =~ s/\..+$//;
        my @candidates = grep /$f$/, @{$self->{packages}};
        $self->{module} = shift(@candidates); # punt
      }
      else {
        if(grep /main/, @{$self->{packages}}) {
          $self->{module} = 'main';
        }
        else {
          $self->{module} = $self->{packages}[0] || '';
        }
      }
    }
  
    $self->{version} = $self->{versions}{$self->{module}}
        if defined( $self->{module} );
  
    return $self;
  }
  
  # class method
  sub _do_find_module {
    my $class   = shift;
    my $module  = shift || croak 'find_module_by_name() requires a package name';
    my $dirs    = shift || \@INC;
  
    my $file = File::Spec->catfile(split( /::/, $module));
    foreach my $dir ( @$dirs ) {
      my $testfile = File::Spec->catfile($dir, $file);
      return [ File::Spec->rel2abs( $testfile ), $dir ]
  	if -e $testfile and !-d _;  # For stuff like ExtUtils::xsubpp
      return [ File::Spec->rel2abs( "$testfile.pm" ), $dir ]
  	if -e "$testfile.pm";
    }
    return;
  }
  
  # class method
  sub find_module_by_name {
    my $found = shift()->_do_find_module(@_) or return;
    return $found->[0];
  }
  
  # class method
  sub find_module_dir_by_name {
    my $found = shift()->_do_find_module(@_) or return;
    return $found->[1];
  }
  
  
  # given a line of perl code, attempt to parse it if it looks like a
  # $VERSION assignment, returning sigil, full name, & package name
  sub _parse_version_expression {
    my $self = shift;
    my $line = shift;
  
    my( $sig, $var, $pkg );
    if ( $line =~ /$VERS_REGEXP/o ) {
      ( $sig, $var, $pkg ) = $2 ? ( $1, $2, $3 ) : ( $4, $5, $6 );
      if ( $pkg ) {
        $pkg = ($pkg eq '::') ? 'main' : $pkg;
        $pkg =~ s/::$//;
      }
    }
  
    return ( $sig, $var, $pkg );
  }
  
  sub _parse_file {
    my $self = shift;
  
    my $filename = $self->{filename};
    my $fh = IO::File->new( $filename )
      or croak( "Can't open '$filename': $!" );
  
    $self->_handle_bom($fh, $filename);
  
    $self->_parse_fh($fh);
  }
  
  # Look for a UTF-8/UTF-16BE/UTF-16LE BOM at the beginning of the stream.
  # If there's one, then skip it and set the :encoding layer appropriately.
  sub _handle_bom {
    my ($self, $fh, $filename) = @_;
  
    my $pos = $fh->getpos;
    return unless defined $pos;
  
    my $buf = ' ' x 2;
    my $count = $fh->read( $buf, length $buf );
    return unless defined $count and $count >= 2;
  
    my $encoding;
    if ( $buf eq "\x{FE}\x{FF}" ) {
      $encoding = 'UTF-16BE';
    } elsif ( $buf eq "\x{FF}\x{FE}" ) {
      $encoding = 'UTF-16LE';
    } elsif ( $buf eq "\x{EF}\x{BB}" ) {
      $buf = ' ';
      $count = $fh->read( $buf, length $buf );
      if ( defined $count and $count >= 1 and $buf eq "\x{BF}" ) {
        $encoding = 'UTF-8';
      }
    }
  
    if ( defined $encoding ) {
      if ( "$]" >= 5.008 ) {
        # $fh->binmode requires perl 5.10
        binmode( $fh, ":encoding($encoding)" );
      }
    } else {
      $fh->setpos($pos)
        or croak( sprintf "Can't reset position to the top of '$filename'" );
    }
  
    return $encoding;
  }
  
  sub _parse_fh {
    my ($self, $fh) = @_;
  
    my( $in_pod, $seen_end, $need_vers ) = ( 0, 0, 0 );
    my( @pkgs, %vers, %pod, @pod );
    my $pkg = 'main';
    my $pod_sect = '';
    my $pod_data = '';
    my $in_end = 0;
  
    while (defined( my $line = <$fh> )) {
      my $line_num = $.;
  
      chomp( $line );
  
      # From toke.c : any line that begins by "=X", where X is an alphabetic
      # character, introduces a POD segment.
      my $is_cut;
      if ( $line =~ /^=([a-zA-Z].*)/ ) {
        my $cmd = $1;
        # Then it goes back to Perl code for "=cutX" where X is a non-alphabetic
        # character (which includes the newline, but here we chomped it away).
        $is_cut = $cmd =~ /^cut(?:[^a-zA-Z]|$)/;
        $in_pod = !$is_cut;
      }
  
      if ( $in_pod ) {
  
        if ( $line =~ /^=head[1-4]\s+(.+)\s*$/ ) {
  	push( @pod, $1 );
  	if ( $self->{collect_pod} && length( $pod_data ) ) {
            $pod{$pod_sect} = $pod_data;
            $pod_data = '';
          }
  	$pod_sect = $1;
  
        } elsif ( $self->{collect_pod} ) {
  	$pod_data .= "$line\n";
  
        }
  
      } elsif ( $is_cut ) {
  
        if ( $self->{collect_pod} && length( $pod_data ) ) {
          $pod{$pod_sect} = $pod_data;
          $pod_data = '';
        }
        $pod_sect = '';
  
      } else {
  
        # Skip after __END__
        next if $in_end;
  
        # Skip comments in code
        next if $line =~ /^\s*#/;
  
        # Would be nice if we could also check $in_string or something too
        if ($line eq '__END__') {
          $in_end++;
          next;
        }
        last if $line eq '__DATA__';
  
        # parse $line to see if it's a $VERSION declaration
        my( $vers_sig, $vers_fullname, $vers_pkg ) =
            ($line =~ /VERSION/)
                ? $self->_parse_version_expression( $line )
                : ();
  
        if ( $line =~ /$PKG_REGEXP/o ) {
          $pkg = $1;
          push( @pkgs, $pkg ) unless grep( $pkg eq $_, @pkgs );
          $vers{$pkg} = $2 unless exists( $vers{$pkg} );
          $need_vers = defined $2 ? 0 : 1;
  
        # VERSION defined with full package spec, i.e. $Module::VERSION
        } elsif ( $vers_fullname && $vers_pkg ) {
  	push( @pkgs, $vers_pkg ) unless grep( $vers_pkg eq $_, @pkgs );
  	$need_vers = 0 if $vers_pkg eq $pkg;
  
  	unless ( defined $vers{$vers_pkg} && length $vers{$vers_pkg} ) {
  	  $vers{$vers_pkg} =
  	    $self->_evaluate_version_line( $vers_sig, $vers_fullname, $line );
  	}
  
        # first non-comment line in undeclared package main is VERSION
        } elsif ( !exists($vers{main}) && $pkg eq 'main' && $vers_fullname ) {
  	$need_vers = 0;
  	my $v =
  	  $self->_evaluate_version_line( $vers_sig, $vers_fullname, $line );
  	$vers{$pkg} = $v;
  	push( @pkgs, 'main' );
  
        # first non-comment line in undeclared package defines package main
        } elsif ( !exists($vers{main}) && $pkg eq 'main' && $line =~ /\w+/ ) {
  	$need_vers = 1;
  	$vers{main} = '';
  	push( @pkgs, 'main' );
  
        # only keep if this is the first $VERSION seen
        } elsif ( $vers_fullname && $need_vers ) {
  	$need_vers = 0;
  	my $v =
  	  $self->_evaluate_version_line( $vers_sig, $vers_fullname, $line );
  
  
  	unless ( defined $vers{$pkg} && length $vers{$pkg} ) {
  	  $vers{$pkg} = $v;
  	}
  
        }
  
      }
  
    }
  
    if ( $self->{collect_pod} && length($pod_data) ) {
      $pod{$pod_sect} = $pod_data;
    }
  
    $self->{versions} = \%vers;
    $self->{packages} = \@pkgs;
    $self->{pod} = \%pod;
    $self->{pod_headings} = \@pod;
  }
  
  {
  my $pn = 0;
  sub _evaluate_version_line {
    my $self = shift;
    my( $sigil, $var, $line ) = @_;
  
    # Some of this code came from the ExtUtils:: hierarchy.
  
    # We compile into $vsub because 'use version' would cause
    # compiletime/runtime issues with local()
    my $vsub;
    $pn++; # everybody gets their own package
    my $eval = qq{BEGIN { my \$dummy = q#  Hide from _packages_inside()
      #; package Module::Metadata::_version::p$pn;
      use version;
      no strict;
      no warnings;
  
        \$vsub = sub {
          local $sigil$var;
          \$$var=undef;
          $line;
          \$$var
        };
    }};
  
    $eval = $1 if $eval =~ m{^(.+)}s;
  
    local $^W;
    # Try to get the $VERSION
    eval $eval;
    # some modules say $VERSION = $Foo::Bar::VERSION, but Foo::Bar isn't
    # installed, so we need to hunt in ./lib for it
    if ( $@ =~ /Can't locate/ && -d 'lib' ) {
      local @INC = ('lib',@INC);
      eval $eval;
    }
    warn "Error evaling version line '$eval' in $self->{filename}: $@\n"
      if $@;
    (ref($vsub) eq 'CODE') or
      croak "failed to build version sub for $self->{filename}";
    my $result = eval { $vsub->() };
    croak "Could not get version from $self->{filename} by executing:\n$eval\n\nThe fatal error was: $@\n"
      if $@;
  
    # Upgrade it into a version object
    my $version = eval { _dwim_version($result) };
  
    croak "Version '$result' from $self->{filename} does not appear to be valid:\n$eval\n\nThe fatal error was: $@\n"
      unless defined $version; # "0" is OK!
  
    return $version;
  }
  }
  
  # Try to DWIM when things fail the lax version test in obvious ways
  {
    my @version_prep = (
      # Best case, it just works
      sub { return shift },
  
      # If we still don't have a version, try stripping any
      # trailing junk that is prohibited by lax rules
      sub {
        my $v = shift;
        $v =~ s{([0-9])[a-z-].*$}{$1}i; # 1.23-alpha or 1.23b
        return $v;
      },
  
      # Activestate apparently creates custom versions like '1.23_45_01', which
      # cause version.pm to think it's an invalid alpha.  So check for that
      # and strip them
      sub {
        my $v = shift;
        my $num_dots = () = $v =~ m{(\.)}g;
        my $num_unders = () = $v =~ m{(_)}g;
        my $leading_v = substr($v,0,1) eq 'v';
        if ( ! $leading_v && $num_dots < 2 && $num_unders > 1 ) {
          $v =~ s{_}{}g;
          $num_unders = () = $v =~ m{(_)}g;
        }
        return $v;
      },
  
      # Worst case, try numifying it like we would have before version objects
      sub {
        my $v = shift;
        no warnings 'numeric';
        return 0 + $v;
      },
  
    );
  
    sub _dwim_version {
      my ($result) = shift;
  
      return $result if ref($result) eq 'version';
  
      my ($version, $error);
      for my $f (@version_prep) {
        $result = $f->($result);
        $version = eval { version->new($result) };
        $error ||= $@ if $@; # capture first failure
        last if defined $version;
      }
  
      croak $error unless defined $version;
  
      return $version;
    }
  }
  
  ############################################################
  
  # accessors
  sub name            { $_[0]->{module}            }
  
  sub filename        { $_[0]->{filename}          }
  sub packages_inside { @{$_[0]->{packages}}       }
  sub pod_inside      { @{$_[0]->{pod_headings}}   }
  sub contains_pod    { 0+@{$_[0]->{pod_headings}} }
  
  sub version {
      my $self = shift;
      my $mod  = shift || $self->{module};
      my $vers;
      if ( defined( $mod ) && length( $mod ) &&
  	 exists( $self->{versions}{$mod} ) ) {
  	return $self->{versions}{$mod};
      } else {
  	return undef;
      }
  }
  
  sub pod {
      my $self = shift;
      my $sect = shift;
      if ( defined( $sect ) && length( $sect ) &&
  	 exists( $self->{pod}{$sect} ) ) {
  	return $self->{pod}{$sect};
      } else {
  	return undef;
      }
  }
  
  1;
  
  =head1 NAME
  
  Module::Metadata - Gather package and POD information from perl module files
  
  =head1 SYNOPSIS
  
    use Module::Metadata;
  
    # information about a .pm file
    my $info = Module::Metadata->new_from_file( $file );
    my $version = $info->version;
  
    # CPAN META 'provides' field for .pm files in a directory
    my $provides = Module::Metadata->provides(
      dir => 'lib', version => 2
    );
  
  =head1 DESCRIPTION
  
  This module provides a standard way to gather metadata about a .pm file through
  (mostly) static analysis and (some) code execution.  When determining the
  version of a module, the C<$VERSION> assignment is C<eval>ed, as is traditional
  in the CPAN toolchain.
  
  =head1 USAGE
  
  =head2 Class methods
  
  =over 4
  
  =item C<< new_from_file($filename, collect_pod => 1) >>
  
  Constructs a C<Module::Metadata> object given the path to a file.  Returns
  undef if the filename does not exist.
  
  C<collect_pod> is a optional boolean argument that determines whether POD
  data is collected and stored for reference.  POD data is not collected by
  default.  POD headings are always collected.
  
  If the file begins by an UTF-8, UTF-16BE or UTF-16LE byte-order mark, then
  it is skipped before processing, and the content of the file is also decoded
  appropriately starting from perl 5.8.
  
  =item C<< new_from_handle($handle, $filename, collect_pod => 1) >>
  
  This works just like C<new_from_file>, except that a handle can be provided
  as the first argument.
  
  Note that there is no validation to confirm that the handle is a handle or
  something that can act like one.  Passing something that isn't a handle will
  cause a exception when trying to read from it.  The C<filename> argument is
  mandatory or undef will be returned.
  
  You are responsible for setting the decoding layers on C<$handle> if
  required.
  
  =item C<< new_from_module($module, collect_pod => 1, inc => \@dirs) >>
  
  Constructs a C<Module::Metadata> object given a module or package name.
  Returns undef if the module cannot be found.
  
  In addition to accepting the C<collect_pod> argument as described above,
  this method accepts a C<inc> argument which is a reference to an array of
  directories to search for the module.  If none are given, the default is
  @INC.
  
  If the file that contains the module begins by an UTF-8, UTF-16BE or
  UTF-16LE byte-order mark, then it is skipped before processing, and the
  content of the file is also decoded appropriately starting from perl 5.8.
  
  =item C<< find_module_by_name($module, \@dirs) >>
  
  Returns the path to a module given the module or package name. A list
  of directories can be passed in as an optional parameter, otherwise
  @INC is searched.
  
  Can be called as either an object or a class method.
  
  =item C<< find_module_dir_by_name($module, \@dirs) >>
  
  Returns the entry in C<@dirs> (or C<@INC> by default) that contains
  the module C<$module>. A list of directories can be passed in as an
  optional parameter, otherwise @INC is searched.
  
  Can be called as either an object or a class method.
  
  =item C<< provides( %options ) >>
  
  This is a convenience wrapper around C<package_versions_from_directory>
  to generate a CPAN META C<provides> data structure.  It takes key/value
  pairs.  Valid option keys include:
  
  =over
  
  =item version B<(required)>
  
  Specifies which version of the L<CPAN::Meta::Spec> should be used as
  the format of the C<provides> output.  Currently only '1.4' and '2'
  are supported (and their format is identical).  This may change in
  the future as the definition of C<provides> changes.
  
  The C<version> option is required.  If it is omitted or if
  an unsupported version is given, then C<provides> will throw an error.
  
  =item dir
  
  Directory to search recursively for F<.pm> files.  May not be specified with
  C<files>.
  
  =item files
  
  Array reference of files to examine.  May not be specified with C<dir>.
  
  =item prefix
  
  String to prepend to the C<file> field of the resulting output. This defaults
  to F<lib>, which is the common case for most CPAN distributions with their
  F<.pm> files in F<lib>.  This option ensures the META information has the
  correct relative path even when the C<dir> or C<files> arguments are
  absolute or have relative paths from a location other than the distribution
  root.
  
  =back
  
  For example, given C<dir> of 'lib' and C<prefix> of 'lib', the return value
  is a hashref of the form:
  
    {
      'Package::Name' => {
        version => '0.123',
        file => 'lib/Package/Name.pm'
      },
      'OtherPackage::Name' => ...
    }
  
  =item C<< package_versions_from_directory($dir, \@files?) >>
  
  Scans C<$dir> for .pm files (unless C<@files> is given, in which case looks
  for those files in C<$dir> - and reads each file for packages and versions,
  returning a hashref of the form:
  
    {
      'Package::Name' => {
        version => '0.123',
        file => 'Package/Name.pm'
      },
      'OtherPackage::Name' => ...
    }
  
  The C<DB> and C<main> packages are always omitted, as are any "private"
  packages that have leading underscores in the namespace (e.g.
  C<Foo::_private>)
  
  Note that the file path is relative to C<$dir> if that is specified.
  This B<must not> be used directly for CPAN META C<provides>.  See
  the C<provides> method instead.
  
  =item C<< log_info (internal) >>
  
  Used internally to perform logging; imported from Log::Contextual if
  Log::Contextual has already been loaded, otherwise simply calls warn.
  
  =back
  
  =head2 Object methods
  
  =over 4
  
  =item C<< name() >>
  
  Returns the name of the package represented by this module. If there
  are more than one packages, it makes a best guess based on the
  filename. If it's a script (i.e. not a *.pm) the package name is
  'main'.
  
  =item C<< version($package) >>
  
  Returns the version as defined by the $VERSION variable for the
  package as returned by the C<name> method if no arguments are
  given. If given the name of a package it will attempt to return the
  version of that package if it is specified in the file.
  
  =item C<< filename() >>
  
  Returns the absolute path to the file.
  
  =item C<< packages_inside() >>
  
  Returns a list of packages. Note: this is a raw list of packages
  discovered (or assumed, in the case of C<main>).  It is not
  filtered for C<DB>, C<main> or private packages the way the
  C<provides> method does.  Invalid package names are not returned,
  for example "Foo:Bar".  Strange but valid package names are
  returned, for example "Foo::Bar::", and are left up to the caller
  on how to handle.
  
  =item C<< pod_inside() >>
  
  Returns a list of POD sections.
  
  =item C<< contains_pod() >>
  
  Returns true if there is any POD in the file.
  
  =item C<< pod($section) >>
  
  Returns the POD data in the given section.
  
  =back
  
  =head1 AUTHOR
  
  Original code from Module::Build::ModuleInfo by Ken Williams
  <kwilliams@cpan.org>, Randy W. Sims <RandyS@ThePierianSpring.org>
  
  Released as Module::Metadata by Matt S Trout (mst) <mst@shadowcat.co.uk> with
  assistance from David Golden (xdg) <dagolden@cpan.org>.
  
  =head1 COPYRIGHT & LICENSE
  
  Original code Copyright (c) 2001-2011 Ken Williams.
  Additional code Copyright (c) 2010-2011 Matt Trout and David Golden.
  All rights reserved.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
MODULE_METADATA

$fatpacked{"Mozilla/CA.pm"} = <<'MOZILLA_CA';
  package Mozilla::CA;
  
  use strict;
  our $VERSION = '20130114';
  
  use Cwd ();
  use File::Spec ();
  use File::Basename qw(dirname);
  
  sub SSL_ca_file {
      my $file = File::Spec->catfile(dirname(__FILE__), "CA", "cacert.pem");
      if (!File::Spec->file_name_is_absolute($file)) {
  	$file = File::Spec->catfile(Cwd::cwd(), $file);
      }
      return $file;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Mozilla::CA - Mozilla's CA cert bundle in PEM format
  
  =head1 SYNOPSIS
  
      use IO::Socket::SSL;
      use Mozilla::CA;
  
      my $host = "www.paypal.com";
      my $client = IO::Socket::SSL->new(
  	PeerHost => "$host:443",
  	SSL_verify_mode => 0x02,
  	SSL_ca_file => Mozilla::CA::SSL_ca_file(),
      )
  	|| die "Can't connect: $@";
  
      $client->verify_hostname($host, "http")
  	|| die "hostname verification failure";
  
  =head1 DESCRIPTION
  
  Mozilla::CA provides a copy of Mozilla's bundle of Certificate Authority
  certificates in a form that can be consumed by modules and libraries
  based on OpenSSL.
  
  The module provide a single function:
  
  =over
  
  =item SSL_ca_file()
  
  Returns the absolute path to the Mozilla's CA cert bundle PEM file.
  
  =back
  
  =head1 SEE ALSO
  
  L<http://curl.haxx.se/docs/caextract.html>
  
  =head1 LICENSE
  
  For the bundled Mozilla CA PEM file the following applies:
  
  =over
  
  The contents of this file are subject to the Mozilla Public License Version
  1.1 (the "License"); you may not use this file except in compliance with
  the License. You may obtain a copy of the License at
  http://www.mozilla.org/MPL/
  
  Software distributed under the License is distributed on an "AS IS" basis,
  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  for the specific language governing rights and limitations under the
  License.
  
  The Original Code is the Netscape security libraries.
  
  The Initial Developer of the Original Code is
  Netscape Communications Corporation.
  Portions created by the Initial Developer are Copyright (C) 1994-2000
  the Initial Developer. All Rights Reserved.
  
  Alternatively, the contents of this file may be used under the terms of
  either the GNU General Public License Version 2 or later (the "GPL"), or
  the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  in which case the provisions of the GPL or the LGPL are applicable instead
  of those above. If you wish to allow use of your version of this file only
  under the terms of either the GPL or the LGPL, and not to allow others to
  use your version of this file under the terms of the MPL, indicate your
  decision by deleting the provisions above and replace them with the notice
  and other provisions required by the GPL or the LGPL. If you do not delete
  the provisions above, a recipient may use your version of this file under
  the terms of any one of the MPL, the GPL or the LGPL.
  
  =back
  
  The Mozilla::CA distribution itself is available under the same license.
MOZILLA_CA

$fatpacked{"Net/HTTP.pm"} = <<'NET_HTTP';
  package Net::HTTP;
  
  use strict;
  use vars qw($VERSION @ISA $SOCKET_CLASS);
  
  $VERSION = "6.06";
  unless ($SOCKET_CLASS) {
      eval { require IO::Socket::INET } || require IO::Socket;
      $SOCKET_CLASS = "IO::Socket::INET";
  }
  require Net::HTTP::Methods;
  require Carp;
  
  @ISA = ($SOCKET_CLASS, 'Net::HTTP::Methods');
  
  sub new {
      my $class = shift;
      Carp::croak("No Host option provided") unless @_;
      $class->SUPER::new(@_);
  }
  
  sub configure {
      my($self, $cnf) = @_;
      $self->http_configure($cnf);
  }
  
  sub http_connect {
      my($self, $cnf) = @_;
      $self->SUPER::configure($cnf);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Net::HTTP - Low-level HTTP connection (client)
  
  =head1 SYNOPSIS
  
   use Net::HTTP;
   my $s = Net::HTTP->new(Host => "www.perl.com") || die $@;
   $s->write_request(GET => "/", 'User-Agent' => "Mozilla/5.0");
   my($code, $mess, %h) = $s->read_response_headers;
  
   while (1) {
      my $buf;
      my $n = $s->read_entity_body($buf, 1024);
      die "read failed: $!" unless defined $n;
      last unless $n;
      print $buf;
   }
  
  =head1 DESCRIPTION
  
  The C<Net::HTTP> class is a low-level HTTP client.  An instance of the
  C<Net::HTTP> class represents a connection to an HTTP server.  The
  HTTP protocol is described in RFC 2616.  The C<Net::HTTP> class
  supports C<HTTP/1.0> and C<HTTP/1.1>.
  
  C<Net::HTTP> is a sub-class of C<IO::Socket::INET>.  You can mix the
  methods described below with reading and writing from the socket
  directly.  This is not necessary a good idea, unless you know what you
  are doing.
  
  The following methods are provided (in addition to those of
  C<IO::Socket::INET>):
  
  =over
  
  =item $s = Net::HTTP->new( %options )
  
  The C<Net::HTTP> constructor method takes the same options as
  C<IO::Socket::INET>'s as well as these:
  
    Host:            Initial host attribute value
    KeepAlive:       Initial keep_alive attribute value
    SendTE:          Initial send_te attribute_value
    HTTPVersion:     Initial http_version attribute value
    PeerHTTPVersion: Initial peer_http_version attribute value
    MaxLineLength:   Initial max_line_length attribute value
    MaxHeaderLines:  Initial max_header_lines attribute value
  
  The C<Host> option is also the default for C<IO::Socket::INET>'s
  C<PeerAddr>.  The C<PeerPort> defaults to 80 if not provided.
  
  The C<Listen> option provided by C<IO::Socket::INET>'s constructor
  method is not allowed.
  
  If unable to connect to the given HTTP server then the constructor
  returns C<undef> and $@ contains the reason.  After a successful
  connect, a C<Net:HTTP> object is returned.
  
  =item $s->host
  
  Get/set the default value of the C<Host> header to send.  The $host
  must not be set to an empty string (or C<undef>) for HTTP/1.1.
  
  =item $s->keep_alive
  
  Get/set the I<keep-alive> value.  If this value is TRUE then the
  request will be sent with headers indicating that the server should try
  to keep the connection open so that multiple requests can be sent.
  
  The actual headers set will depend on the value of the C<http_version>
  and C<peer_http_version> attributes.
  
  =item $s->send_te
  
  Get/set the a value indicating if the request will be sent with a "TE"
  header to indicate the transfer encodings that the server can choose to
  use.  The list of encodings announced as accepted by this client depends
  on availability of the following modules: C<Compress::Raw::Zlib> for
  I<deflate>, and C<IO::Compress::Gunzip> for I<gzip>.
  
  =item $s->http_version
  
  Get/set the HTTP version number that this client should announce.
  This value can only be set to "1.0" or "1.1".  The default is "1.1".
  
  =item $s->peer_http_version
  
  Get/set the protocol version number of our peer.  This value will
  initially be "1.0", but will be updated by a successful
  read_response_headers() method call.
  
  =item $s->max_line_length
  
  Get/set a limit on the length of response line and response header
  lines.  The default is 8192.  A value of 0 means no limit.
  
  =item $s->max_header_length
  
  Get/set a limit on the number of header lines that a response can
  have.  The default is 128.  A value of 0 means no limit.
  
  =item $s->format_request($method, $uri, %headers, [$content])
  
  Format a request message and return it as a string.  If the headers do
  not include a C<Host> header, then a header is inserted with the value
  of the C<host> attribute.  Headers like C<Connection> and
  C<Keep-Alive> might also be added depending on the status of the
  C<keep_alive> attribute.
  
  If $content is given (and it is non-empty), then a C<Content-Length>
  header is automatically added unless it was already present.
  
  =item $s->write_request($method, $uri, %headers, [$content])
  
  Format and send a request message.  Arguments are the same as for
  format_request().  Returns true if successful.
  
  =item $s->format_chunk( $data )
  
  Returns the string to be written for the given chunk of data.  
  
  =item $s->write_chunk($data)
  
  Will write a new chunk of request entity body data.  This method
  should only be used if the C<Transfer-Encoding> header with a value of
  C<chunked> was sent in the request.  Note, writing zero-length data is
  a no-op.  Use the write_chunk_eof() method to signal end of entity
  body data.
  
  Returns true if successful.
  
  =item $s->format_chunk_eof( %trailers )
  
  Returns the string to be written for signaling EOF when a
  C<Transfer-Encoding> of C<chunked> is used.
  
  =item $s->write_chunk_eof( %trailers )
  
  Will write eof marker for chunked data and optional trailers.  Note
  that trailers should not really be used unless is was signaled
  with a C<Trailer> header.
  
  Returns true if successful.
  
  =item ($code, $mess, %headers) = $s->read_response_headers( %opts )
  
  Read response headers from server and return it.  The $code is the 3
  digit HTTP status code (see L<HTTP::Status>) and $mess is the textual
  message that came with it.  Headers are then returned as key/value
  pairs.  Since key letter casing is not normalized and the same key can
  even occur multiple times, assigning these values directly to a hash
  is not wise.  Only the $code is returned if this method is called in
  scalar context.
  
  As a side effect this method updates the 'peer_http_version'
  attribute.
  
  Options might be passed in as key/value pairs.  There are currently
  only two options supported; C<laxed> and C<junk_out>.
  
  The C<laxed> option will make read_response_headers() more forgiving
  towards servers that have not learned how to speak HTTP properly.  The
  C<laxed> option is a boolean flag, and is enabled by passing in a TRUE
  value.  The C<junk_out> option can be used to capture bad header lines
  when C<laxed> is enabled.  The value should be an array reference.
  Bad header lines will be pushed onto the array.
  
  The C<laxed> option must be specified in order to communicate with
  pre-HTTP/1.0 servers that don't describe the response outcome or the
  data they send back with a header block.  For these servers
  peer_http_version is set to "0.9" and this method returns (200,
  "Assumed OK").
  
  The method will raise an exception (die) if the server does not speak
  proper HTTP or if the C<max_line_length> or C<max_header_length>
  limits are reached.  If the C<laxed> option is turned on and
  C<max_line_length> and C<max_header_length> checks are turned off,
  then no exception will be raised and this method will always
  return a response code.
  
  =item $n = $s->read_entity_body($buf, $size);
  
  Reads chunks of the entity body content.  Basically the same interface
  as for read() and sysread(), but the buffer offset argument is not
  supported yet.  This method should only be called after a successful
  read_response_headers() call.
  
  The return value will be C<undef> on read errors, 0 on EOF, -1 if no data
  could be returned this time, otherwise the number of bytes assigned
  to $buf.  The $buf is set to "" when the return value is -1.
  
  You normally want to retry this call if this function returns either
  -1 or C<undef> with C<$!> as EINTR or EAGAIN (see L<Errno>).  EINTR
  can happen if the application catches signals and EAGAIN can happen if
  you made the socket non-blocking.
  
  This method will raise exceptions (die) if the server does not speak
  proper HTTP.  This can only happen when reading chunked data.
  
  =item %headers = $s->get_trailers
  
  After read_entity_body() has returned 0 to indicate end of the entity
  body, you might call this method to pick up any trailers.
  
  =item $s->_rbuf
  
  Get/set the read buffer content.  The read_response_headers() and
  read_entity_body() methods use an internal buffer which they will look
  for data before they actually sysread more from the socket itself.  If
  they read too much, the remaining data will be left in this buffer.
  
  =item $s->_rbuf_length
  
  Returns the number of bytes in the read buffer.  This should always be
  the same as:
  
      length($s->_rbuf)
  
  but might be more efficient.
  
  =back
  
  =head1 SUBCLASSING
  
  The read_response_headers() and read_entity_body() will invoke the
  sysread() method when they need more data.  Subclasses might want to
  override this method to control how reading takes place.
  
  The object itself is a glob.  Subclasses should avoid using hash key
  names prefixed with C<http_> and C<io_>.
  
  =head1 SEE ALSO
  
  L<LWP>, L<IO::Socket::INET>, L<Net::HTTP::NB>
  
  =head1 COPYRIGHT
  
  Copyright 2001-2003 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
NET_HTTP

$fatpacked{"Net/HTTP/Methods.pm"} = <<'NET_HTTP_METHODS';
  package Net::HTTP::Methods;
  
  require 5.005;  # 4-arg substr
  
  use strict;
  use vars qw($VERSION);
  
  $VERSION = "6.06";
  
  my $CRLF = "\015\012";   # "\r\n" is not portable
  
  *_bytes = defined(&utf8::downgrade) ?
      sub {
          unless (utf8::downgrade($_[0], 1)) {
              require Carp;
              Carp::croak("Wide character in HTTP request (bytes required)");
          }
          return $_[0];
      }
      :
      sub {
          return $_[0];
      };
  
  
  sub new {
      my $class = shift;
      unshift(@_, "Host") if @_ == 1;
      my %cnf = @_;
      require Symbol;
      my $self = bless Symbol::gensym(), $class;
      return $self->http_configure(\%cnf);
  }
  
  sub http_configure {
      my($self, $cnf) = @_;
  
      die "Listen option not allowed" if $cnf->{Listen};
      my $explict_host = (exists $cnf->{Host});
      my $host = delete $cnf->{Host};
      my $peer = $cnf->{PeerAddr} || $cnf->{PeerHost};
      if (!$peer) {
  	die "No Host option provided" unless $host;
  	$cnf->{PeerAddr} = $peer = $host;
      }
  
      if ($peer =~ s,:(\d+)$,,) {
  	$cnf->{PeerPort} = int($1);  # always override
      }
      if (!$cnf->{PeerPort}) {
  	$cnf->{PeerPort} = $self->http_default_port;
      }
  
      if (!$explict_host) {
  	$host = $peer;
  	$host =~ s/:.*//;
      }
      if ($host && $host !~ /:/) {
  	my $p = $cnf->{PeerPort};
  	$host .= ":$p" if $p != $self->http_default_port;
      }
  
      $cnf->{Proto} = 'tcp';
  
      my $keep_alive = delete $cnf->{KeepAlive};
      my $http_version = delete $cnf->{HTTPVersion};
      $http_version = "1.1" unless defined $http_version;
      my $peer_http_version = delete $cnf->{PeerHTTPVersion};
      $peer_http_version = "1.0" unless defined $peer_http_version;
      my $send_te = delete $cnf->{SendTE};
      my $max_line_length = delete $cnf->{MaxLineLength};
      $max_line_length = 8*1024 unless defined $max_line_length;
      my $max_header_lines = delete $cnf->{MaxHeaderLines};
      $max_header_lines = 128 unless defined $max_header_lines;
  
      return undef unless $self->http_connect($cnf);
  
      $self->host($host);
      $self->keep_alive($keep_alive);
      $self->send_te($send_te);
      $self->http_version($http_version);
      $self->peer_http_version($peer_http_version);
      $self->max_line_length($max_line_length);
      $self->max_header_lines($max_header_lines);
  
      ${*$self}{'http_buf'} = "";
  
      return $self;
  }
  
  sub http_default_port {
      80;
  }
  
  # set up property accessors
  for my $method (qw(host keep_alive send_te max_line_length max_header_lines peer_http_version)) {
      my $prop_name = "http_" . $method;
      no strict 'refs';
      *$method = sub {
  	my $self = shift;
  	my $old = ${*$self}{$prop_name};
  	${*$self}{$prop_name} = shift if @_;
  	return $old;
      };
  }
  
  # we want this one to be a bit smarter
  sub http_version {
      my $self = shift;
      my $old = ${*$self}{'http_version'};
      if (@_) {
  	my $v = shift;
  	$v = "1.0" if $v eq "1";  # float
  	unless ($v eq "1.0" or $v eq "1.1") {
  	    require Carp;
  	    Carp::croak("Unsupported HTTP version '$v'");
  	}
  	${*$self}{'http_version'} = $v;
      }
      $old;
  }
  
  sub format_request {
      my $self = shift;
      my $method = shift;
      my $uri = shift;
  
      my $content = (@_ % 2) ? pop : "";
  
      for ($method, $uri) {
  	require Carp;
  	Carp::croak("Bad method or uri") if /\s/ || !length;
      }
  
      push(@{${*$self}{'http_request_method'}}, $method);
      my $ver = ${*$self}{'http_version'};
      my $peer_ver = ${*$self}{'http_peer_http_version'} || "1.0";
  
      my @h;
      my @connection;
      my %given = (host => 0, "content-length" => 0, "te" => 0);
      while (@_) {
  	my($k, $v) = splice(@_, 0, 2);
  	my $lc_k = lc($k);
  	if ($lc_k eq "connection") {
  	    $v =~ s/^\s+//;
  	    $v =~ s/\s+$//;
  	    push(@connection, split(/\s*,\s*/, $v));
  	    next;
  	}
  	if (exists $given{$lc_k}) {
  	    $given{$lc_k}++;
  	}
  	push(@h, "$k: $v");
      }
  
      if (length($content) && !$given{'content-length'}) {
  	push(@h, "Content-Length: " . length($content));
      }
  
      my @h2;
      if ($given{te}) {
  	push(@connection, "TE") unless grep lc($_) eq "te", @connection;
      }
      elsif ($self->send_te && gunzip_ok()) {
  	# gzip is less wanted since the IO::Uncompress::Gunzip interface for
  	# it does not really allow chunked decoding to take place easily.
  	push(@h2, "TE: deflate,gzip;q=0.3");
  	push(@connection, "TE");
      }
  
      unless (grep lc($_) eq "close", @connection) {
  	if ($self->keep_alive) {
  	    if ($peer_ver eq "1.0") {
  		# from looking at Netscape's headers
  		push(@h2, "Keep-Alive: 300");
  		unshift(@connection, "Keep-Alive");
  	    }
  	}
  	else {
  	    push(@connection, "close") if $ver ge "1.1";
  	}
      }
      push(@h2, "Connection: " . join(", ", @connection)) if @connection;
      unless ($given{host}) {
  	my $h = ${*$self}{'http_host'};
  	push(@h2, "Host: $h") if $h;
      }
  
      return _bytes(join($CRLF, "$method $uri HTTP/$ver", @h2, @h, "", $content));
  }
  
  
  sub write_request {
      my $self = shift;
      $self->print($self->format_request(@_));
  }
  
  sub format_chunk {
      my $self = shift;
      return $_[0] unless defined($_[0]) && length($_[0]);
      return _bytes(sprintf("%x", length($_[0])) . $CRLF . $_[0] . $CRLF);
  }
  
  sub write_chunk {
      my $self = shift;
      return 1 unless defined($_[0]) && length($_[0]);
      $self->print(_bytes(sprintf("%x", length($_[0])) . $CRLF . $_[0] . $CRLF));
  }
  
  sub format_chunk_eof {
      my $self = shift;
      my @h;
      while (@_) {
  	push(@h, sprintf "%s: %s$CRLF", splice(@_, 0, 2));
      }
      return _bytes(join("", "0$CRLF", @h, $CRLF));
  }
  
  sub write_chunk_eof {
      my $self = shift;
      $self->print($self->format_chunk_eof(@_));
  }
  
  
  sub my_read {
      die if @_ > 3;
      my $self = shift;
      my $len = $_[1];
      for (${*$self}{'http_buf'}) {
  	if (length) {
  	    $_[0] = substr($_, 0, $len, "");
  	    return length($_[0]);
  	}
  	else {
  	    die "read timeout" unless $self->can_read;
  	    return $self->sysread($_[0], $len);
  	}
      }
  }
  
  
  sub my_readline {
      my $self = shift;
      my $what = shift;
      for (${*$self}{'http_buf'}) {
  	my $max_line_length = ${*$self}{'http_max_line_length'};
  	my $pos;
  	while (1) {
  	    # find line ending
  	    $pos = index($_, "\012");
  	    last if $pos >= 0;
  	    die "$what line too long (limit is $max_line_length)"
  		if $max_line_length && length($_) > $max_line_length;
  
  	    # need to read more data to find a line ending
            READ:
              {
                  die "read timeout" unless $self->can_read;
                  my $n = $self->sysread($_, 1024, length);
                  unless (defined $n) {
                      redo READ if $!{EINTR} || $!{EAGAIN};
                      # if we have already accumulated some data let's at least
                      # return that as a line
                      die "$what read failed: $!" unless length;
                  }
                  unless ($n) {
                      return undef unless length;
                      return substr($_, 0, length, "");
                  }
              }
  	}
  	die "$what line too long ($pos; limit is $max_line_length)"
  	    if $max_line_length && $pos > $max_line_length;
  
  	my $line = substr($_, 0, $pos+1, "");
  	$line =~ s/(\015?\012)\z// || die "Assert";
  	return wantarray ? ($line, $1) : $line;
      }
  }
  
  
  sub can_read {
      my $self = shift;
      return 1 unless defined(fileno($self));
      return 1 if $self->isa('IO::Socket::SSL') && $self->pending;
  
      # With no timeout, wait forever.  An explict timeout of 0 can be
      # used to just check if the socket is readable without waiting.
      my $timeout = @_ ? shift : (${*$self}{io_socket_timeout} || undef);
  
      my $fbits = '';
      vec($fbits, fileno($self), 1) = 1;
    SELECT:
      {
          my $before;
          $before = time if $timeout;
          my $nfound = select($fbits, undef, undef, $timeout);
          if ($nfound < 0) {
              if ($!{EINTR} || $!{EAGAIN}) {
                  # don't really think EAGAIN can happen here
                  if ($timeout) {
                      $timeout -= time - $before;
                      $timeout = 0 if $timeout < 0;
                  }
                  redo SELECT;
              }
              die "select failed: $!";
          }
          return $nfound > 0;
      }
  }
  
  
  sub _rbuf {
      my $self = shift;
      if (@_) {
  	for (${*$self}{'http_buf'}) {
  	    my $old;
  	    $old = $_ if defined wantarray;
  	    $_ = shift;
  	    return $old;
  	}
      }
      else {
  	return ${*$self}{'http_buf'};
      }
  }
  
  sub _rbuf_length {
      my $self = shift;
      return length ${*$self}{'http_buf'};
  }
  
  
  sub _read_header_lines {
      my $self = shift;
      my $junk_out = shift;
  
      my @headers;
      my $line_count = 0;
      my $max_header_lines = ${*$self}{'http_max_header_lines'};
      while (my $line = my_readline($self, 'Header')) {
  	if ($line =~ /^(\S+?)\s*:\s*(.*)/s) {
  	    push(@headers, $1, $2);
  	}
  	elsif (@headers && $line =~ s/^\s+//) {
  	    $headers[-1] .= " " . $line;
  	}
  	elsif ($junk_out) {
  	    push(@$junk_out, $line);
  	}
  	else {
  	    die "Bad header: '$line'\n";
  	}
  	if ($max_header_lines) {
  	    $line_count++;
  	    if ($line_count >= $max_header_lines) {
  		die "Too many header lines (limit is $max_header_lines)";
  	    }
  	}
      }
      return @headers;
  }
  
  
  sub read_response_headers {
      my($self, %opt) = @_;
      my $laxed = $opt{laxed};
  
      my($status, $eol) = my_readline($self, 'Status');
      unless (defined $status) {
  	die "Server closed connection without sending any data back";
      }
  
      my($peer_ver, $code, $message) = split(/\s+/, $status, 3);
      if (!$peer_ver || $peer_ver !~ s,^HTTP/,, || $code !~ /^[1-5]\d\d$/) {
  	die "Bad response status line: '$status'" unless $laxed;
  	# assume HTTP/0.9
  	${*$self}{'http_peer_http_version'} = "0.9";
  	${*$self}{'http_status'} = "200";
  	substr(${*$self}{'http_buf'}, 0, 0) = $status . ($eol || "");
  	return 200 unless wantarray;
  	return (200, "Assumed OK");
      };
  
      ${*$self}{'http_peer_http_version'} = $peer_ver;
      ${*$self}{'http_status'} = $code;
  
      my $junk_out;
      if ($laxed) {
  	$junk_out = $opt{junk_out} || [];
      }
      my @headers = $self->_read_header_lines($junk_out);
  
      # pick out headers that read_entity_body might need
      my @te;
      my $content_length;
      for (my $i = 0; $i < @headers; $i += 2) {
  	my $h = lc($headers[$i]);
  	if ($h eq 'transfer-encoding') {
  	    my $te = $headers[$i+1];
  	    $te =~ s/^\s+//;
  	    $te =~ s/\s+$//;
  	    push(@te, $te) if length($te);
  	}
  	elsif ($h eq 'content-length') {
  	    # ignore bogus and overflow values
  	    if ($headers[$i+1] =~ /^\s*(\d{1,15})(?:\s|$)/) {
  		$content_length = $1;
  	    }
  	}
      }
      ${*$self}{'http_te'} = join(",", @te);
      ${*$self}{'http_content_length'} = $content_length;
      ${*$self}{'http_first_body'}++;
      delete ${*$self}{'http_trailers'};
      return $code unless wantarray;
      return ($code, $message, @headers);
  }
  
  
  sub read_entity_body {
      my $self = shift;
      my $buf_ref = \$_[0];
      my $size = $_[1];
      die "Offset not supported yet" if $_[2];
  
      my $chunked;
      my $bytes;
  
      if (${*$self}{'http_first_body'}) {
  	${*$self}{'http_first_body'} = 0;
  	delete ${*$self}{'http_chunked'};
  	delete ${*$self}{'http_bytes'};
  	my $method = shift(@{${*$self}{'http_request_method'}});
  	my $status = ${*$self}{'http_status'};
  	if ($method eq "HEAD") {
  	    # this response is always empty regardless of other headers
  	    $bytes = 0;
  	}
  	elsif (my $te = ${*$self}{'http_te'}) {
  	    my @te = split(/\s*,\s*/, lc($te));
  	    die "Chunked must be last Transfer-Encoding '$te'"
  		unless pop(@te) eq "chunked";
  	    pop(@te) while @te && $te[-1] eq "chunked";  # ignore repeated chunked spec
  
  	    for (@te) {
  		if ($_ eq "deflate" && inflate_ok()) {
  		    #require Compress::Raw::Zlib;
  		    my ($i, $status) = Compress::Raw::Zlib::Inflate->new();
  		    die "Can't make inflator: $status" unless $i;
  		    $_ = sub { my $out; $i->inflate($_[0], \$out); $out }
  		}
  		elsif ($_ eq "gzip" && gunzip_ok()) {
  		    #require IO::Uncompress::Gunzip;
  		    my @buf;
  		    $_ = sub {
  			push(@buf, $_[0]);
  			return "" unless $_[1];
  			my $input = join("", @buf);
  			my $output;
  			IO::Uncompress::Gunzip::gunzip(\$input, \$output, Transparent => 0)
  			    or die "Can't gunzip content: $IO::Uncompress::Gunzip::GunzipError";
  			return \$output;
  		    };
  		}
  		elsif ($_ eq "identity") {
  		    $_ = sub { $_[0] };
  		}
  		else {
  		    die "Can't handle transfer encoding '$te'";
  		}
  	    }
  
  	    @te = reverse(@te);
  
  	    ${*$self}{'http_te2'} = @te ? \@te : "";
  	    $chunked = -1;
  	}
  	elsif (defined(my $content_length = ${*$self}{'http_content_length'})) {
  	    $bytes = $content_length;
  	}
          elsif ($status =~ /^(?:1|[23]04)/) {
              # RFC 2616 says that these responses should always be empty
              # but that does not appear to be true in practice [RT#17907]
              $bytes = 0;
          }
  	else {
  	    # XXX Multi-Part types are self delimiting, but RFC 2616 says we
  	    # only has to deal with 'multipart/byteranges'
  
  	    # Read until EOF
  	}
      }
      else {
  	$chunked = ${*$self}{'http_chunked'};
  	$bytes   = ${*$self}{'http_bytes'};
      }
  
      if (defined $chunked) {
  	# The state encoded in $chunked is:
  	#   $chunked == 0:   read CRLF after chunk, then chunk header
          #   $chunked == -1:  read chunk header
  	#   $chunked > 0:    bytes left in current chunk to read
  
  	if ($chunked <= 0) {
  	    my $line = my_readline($self, 'Entity body');
  	    if ($chunked == 0) {
  		die "Missing newline after chunk data: '$line'"
  		    if !defined($line) || $line ne "";
  		$line = my_readline($self, 'Entity body');
  	    }
  	    die "EOF when chunk header expected" unless defined($line);
  	    my $chunk_len = $line;
  	    $chunk_len =~ s/;.*//;  # ignore potential chunk parameters
  	    unless ($chunk_len =~ /^([\da-fA-F]+)\s*$/) {
  		die "Bad chunk-size in HTTP response: $line";
  	    }
  	    $chunked = hex($1);
  	    ${*$self}{'http_chunked'} = $chunked;
  	    if ($chunked == 0) {
  		${*$self}{'http_trailers'} = [$self->_read_header_lines];
  		$$buf_ref = "";
  
  		my $n = 0;
  		if (my $transforms = delete ${*$self}{'http_te2'}) {
  		    for (@$transforms) {
  			$$buf_ref = &$_($$buf_ref, 1);
  		    }
  		    $n = length($$buf_ref);
  		}
  
  		# in case somebody tries to read more, make sure we continue
  		# to return EOF
  		delete ${*$self}{'http_chunked'};
  		${*$self}{'http_bytes'} = 0;
  
  		return $n;
  	    }
  	}
  
  	my $n = $chunked;
  	$n = $size if $size && $size < $n;
  	$n = my_read($self, $$buf_ref, $n);
  	return undef unless defined $n;
  
  	${*$self}{'http_chunked'} = $chunked - $n;
  
  	if ($n > 0) {
  	    if (my $transforms = ${*$self}{'http_te2'}) {
  		for (@$transforms) {
  		    $$buf_ref = &$_($$buf_ref, 0);
  		}
  		$n = length($$buf_ref);
  		$n = -1 if $n == 0;
  	    }
  	}
  	return $n;
      }
      elsif (defined $bytes) {
  	unless ($bytes) {
  	    $$buf_ref = "";
  	    return 0;
  	}
  	my $n = $bytes;
  	$n = $size if $size && $size < $n;
  	$n = my_read($self, $$buf_ref, $n);
  	${*$self}{'http_bytes'} = defined $n ? $bytes - $n : $bytes;
  	return $n;
      }
      else {
  	# read until eof
  	$size ||= 8*1024;
  	return my_read($self, $$buf_ref, $size);
      }
  }
  
  sub get_trailers {
      my $self = shift;
      @{${*$self}{'http_trailers'} || []};
  }
  
  BEGIN {
  my $gunzip_ok;
  my $inflate_ok;
  
  sub gunzip_ok {
      return $gunzip_ok if defined $gunzip_ok;
  
      # Try to load IO::Uncompress::Gunzip.
      local $@;
      local $SIG{__DIE__};
      $gunzip_ok = 0;
  
      eval {
  	require IO::Uncompress::Gunzip;
  	$gunzip_ok++;
      };
  
      return $gunzip_ok;
  }
  
  sub inflate_ok {
      return $inflate_ok if defined $inflate_ok;
  
      # Try to load Compress::Raw::Zlib.
      local $@;
      local $SIG{__DIE__};
      $inflate_ok = 0;
  
      eval {
  	require Compress::Raw::Zlib;
  	$inflate_ok++;
      };
  
      return $inflate_ok;
  }
  
  } # BEGIN
  
  1;
NET_HTTP_METHODS

$fatpacked{"Net/HTTP/NB.pm"} = <<'NET_HTTP_NB';
  package Net::HTTP::NB;
  
  use strict;
  use vars qw($VERSION @ISA);
  
  $VERSION = "6.04";
  
  require Net::HTTP;
  @ISA=qw(Net::HTTP);
  
  sub can_read {
      return 1;
  }
  
  sub sysread {
      my $self = $_[0];
      if (${*$self}{'httpnb_read_count'}++) {
  	${*$self}{'http_buf'} = ${*$self}{'httpnb_save'};
  	die "Multi-read\n";
      }
      my $buf;
      my $offset = $_[3] || 0;
      my $n = sysread($self, $_[1], $_[2], $offset);
      ${*$self}{'httpnb_save'} .= substr($_[1], $offset);
      return $n;
  }
  
  sub read_response_headers {
      my $self = shift;
      ${*$self}{'httpnb_read_count'} = 0;
      ${*$self}{'httpnb_save'} = ${*$self}{'http_buf'};
      my @h = eval { $self->SUPER::read_response_headers(@_) };
      if ($@) {
  	return if $@ eq "Multi-read\n";
  	die;
      }
      return @h;
  }
  
  sub read_entity_body {
      my $self = shift;
      ${*$self}{'httpnb_read_count'} = 0;
      ${*$self}{'httpnb_save'} = ${*$self}{'http_buf'};
      # XXX I'm not so sure this does the correct thing in case of
      # transfer-encoding tranforms
      my $n = eval { $self->SUPER::read_entity_body(@_); };
      if ($@) {
  	$_[0] = "";
  	return -1;
      }
      return $n;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Net::HTTP::NB - Non-blocking HTTP client
  
  =head1 SYNOPSIS
  
   use Net::HTTP::NB;
   my $s = Net::HTTP::NB->new(Host => "www.perl.com") || die $@;
   $s->write_request(GET => "/");
  
   use IO::Select;
   my $sel = IO::Select->new($s);
  
   READ_HEADER: {
      die "Header timeout" unless $sel->can_read(10);
      my($code, $mess, %h) = $s->read_response_headers;
      redo READ_HEADER unless $code;
   }
  
   while (1) {
      die "Body timeout" unless $sel->can_read(10);
      my $buf;
      my $n = $s->read_entity_body($buf, 1024);
      last unless $n;
      print $buf;
   }
  
  =head1 DESCRIPTION
  
  Same interface as C<Net::HTTP> but it will never try multiple reads
  when the read_response_headers() or read_entity_body() methods are
  invoked.  This make it possible to multiplex multiple Net::HTTP::NB
  using select without risk blocking.
  
  If read_response_headers() did not see enough data to complete the
  headers an empty list is returned.
  
  If read_entity_body() did not see new entity data in its read
  the value -1 is returned.
  
  =head1 SEE ALSO
  
  L<Net::HTTP>
  
  =head1 COPYRIGHT
  
  Copyright 2001 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
NET_HTTP_NB

$fatpacked{"Net/HTTPS.pm"} = <<'NET_HTTPS';
  package Net::HTTPS;
  
  use strict;
  use vars qw($VERSION $SSL_SOCKET_CLASS @ISA);
  
  $VERSION = "6.04";
  
  # Figure out which SSL implementation to use
  if ($SSL_SOCKET_CLASS) {
      # somebody already set it
  }
  elsif ($SSL_SOCKET_CLASS = $ENV{PERL_NET_HTTPS_SSL_SOCKET_CLASS}) {
      unless ($SSL_SOCKET_CLASS =~ /^(IO::Socket::SSL|Net::SSL)\z/) {
  	die "Bad socket class [$SSL_SOCKET_CLASS]";
      }
      eval "require $SSL_SOCKET_CLASS";
      die $@ if $@;
  }
  elsif ($IO::Socket::SSL::VERSION) {
      $SSL_SOCKET_CLASS = "IO::Socket::SSL"; # it was already loaded
  }
  elsif ($Net::SSL::VERSION) {
      $SSL_SOCKET_CLASS = "Net::SSL";
  }
  else {
      eval { require IO::Socket::SSL; };
      if ($@) {
  	my $old_errsv = $@;
  	eval {
  	    require Net::SSL;  # from Crypt-SSLeay
  	};
  	if ($@) {
  	    $old_errsv =~ s/\s\(\@INC contains:.*\)/)/g;
  	    die $old_errsv . $@;
  	}
  	$SSL_SOCKET_CLASS = "Net::SSL";
      }
      else {
  	$SSL_SOCKET_CLASS = "IO::Socket::SSL";
      }
  }
  
  require Net::HTTP::Methods;
  
  @ISA=($SSL_SOCKET_CLASS, 'Net::HTTP::Methods');
  
  sub configure {
      my($self, $cnf) = @_;
      $self->http_configure($cnf);
  }
  
  sub http_connect {
      my($self, $cnf) = @_;
      if ($self->isa("Net::SSL")) {
  	if ($cnf->{SSL_verify_mode}) {
  	    if (my $f = $cnf->{SSL_ca_file}) {
  		$ENV{HTTPS_CA_FILE} = $f;
  	    }
  	    if (my $f = $cnf->{SSL_ca_path}) {
  		$ENV{HTTPS_CA_DIR} = $f;
  	    }
  	}
  	if ($cnf->{SSL_verifycn_scheme}) {
  	    $@ = "Net::SSL from Crypt-SSLeay can't verify hostnames; either install IO::Socket::SSL or turn off verification by setting the PERL_LWP_SSL_VERIFY_HOSTNAME environment variable to 0";
  	    return undef;
  	}
      }
      $self->SUPER::configure($cnf);
  }
  
  sub http_default_port {
      443;
  }
  
  if ($SSL_SOCKET_CLASS eq "Net::SSL") {
      # The underlying SSLeay classes fails to work if the socket is
      # placed in non-blocking mode.  This override of the blocking
      # method makes sure it stays the way it was created.
      *blocking = sub { };
  }
  
  1;
  
  =head1 NAME
  
  Net::HTTPS - Low-level HTTP over SSL/TLS connection (client)
  
  =head1 DESCRIPTION
  
  The C<Net::HTTPS> is a low-level HTTP over SSL/TLS client.  The interface is the same
  as the interface for C<Net::HTTP>, but the constructor method take additional parameters
  as accepted by L<IO::Socket::SSL>.  The C<Net::HTTPS> object isa C<IO::Socket::SSL>
  too, which make it inherit additional methods from that base class.
  
  For historical reasons this module also supports using C<Net::SSL> (from the
  Crypt-SSLeay distribution) as its SSL driver and base class.  This base is
  automatically selected if available and C<IO::Socket::SSL> isn't.  You might
  also force which implementation to use by setting $Net::HTTPS::SSL_SOCKET_CLASS
  before loading this module.  If not set this variable is initialized from the
  C<PERL_NET_HTTPS_SSL_SOCKET_CLASS> environment variable.
  
  =head1 ENVIRONMENT
  
  You might set the C<PERL_NET_HTTPS_SSL_SOCKET_CLASS> environment variable to the name
  of the base SSL implementation (and Net::HTTPS base class) to use.  The default
  is C<IO::Socket::SSL>.  Currently the only other supported value is C<Net::SSL>.
  
  =head1 SEE ALSO
  
  L<Net::HTTP>, L<IO::Socket::SSL>
NET_HTTPS

$fatpacked{"Parallel/Fork/BossWorker.pm"} = <<'PARALLEL_FORK_BOSSWORKER';
  package Parallel::Fork::BossWorker;
  #
  # $Id: BossWorker.pm 11 2011-07-16 15:49:45Z twilde $
  #
  
  use 5.008008;
  use strict;
  use warnings;
  use Carp;
  use Data::Dumper qw(Dumper);
  use IO::Handle;
  use IO::Select;
  
  # Perl module variables
  our @ISA = qw();
  our $VERSION = '0.05';
  
  sub new {
      my $class = shift;
      my %values = @_;
      
      my $self = {
          result_handler => $values{result_handler} || undef,  # Method for handling output of the workers
          worker_count   => $values{worker_count}   || 10,     # Number of workers
          global_timeout => $values{global_timeout} || 0,      # Number of seconds before the worker terminates the job, 0 for unlimited
          work_handler   => $values{work_handler},             # Handler which will process the data from the boss
          work_queue     => [],
          msg_delimiter  => $values{msg_delimiter} || "\0\0\0",
          select         => IO::Select->new(),
      };
      $self->{msg_delimiter_length} = length($self->{msg_delimiter});
      bless $self, ref($class) || $class;
  
      # The work handler is required
      if (not defined $self->{work_handler}) {
          croak("Parameters \`work_handler' is required.");
      }
  
      return $self;
  }
  
  sub add_work(\@) {
      my $self = shift;
      my $work = shift;
      unshift (@{ $self->{work_queue} }, $work);
  }
  
  sub process {
      my $self = shift;
      my $handler = shift;
      
      eval {
          
          # If a worker dies, there's a problem
          local $SIG{CHLD} = sub {
              my $pid = wait();
              if (defined $self->{workers}->{$pid}) {
                  confess("Worker $pid died.");
              }
          };
          
          # Start the workers
          $self->start();
          
          # Read from the workers, loop until they all shut down
          while (%{$self->{workers}}) {
              while (my @ready = $self->{select}->can_read()) {
                  foreach my $fh (@ready) {
                      my $result = $self->receive($fh);
                      if (!$result) {
                          $self->{select}->remove($fh);
                          print STDERR "$fh got eof\n";
                          next;
                      }
                      
                      # Process the result handler
                      if ($result->{data} && defined $self->{result_handler}) {
                          &{ $self->{result_handler} }( $result->{data} );
                      }
                      
                      # If there's still work to be done, send it to the worker, otherwise shut it down
                      if ($#{ $self->{work_queue} } > -1) {
                          my $worker = $self->{workers}->{$result->{pid}};
                          $self->send(
                              $self->{workers}->{ $result->{pid} }, # Worker's pipe
                              pop(@{ $self->{work_queue} })
                          );
                      } else {
                          $self->{select}->remove($fh);
                          my $fh = $self->{workers}->{ $result->{pid} };
                          delete($self->{workers}->{ $result->{pid} });
                          close($fh);
                      }
                  }
              }
          }
          
          # Wait for our children so the process table won't fill up
          while ((my $pid = wait()) != -1) { }
      };
      
      if ($@) {
          croak($@);
      }
  }
  
  sub start {
      my $self = shift();
      
      # Create a pipe for the workers to communicate to the boss
      
      # Create the workers
      foreach (1..$self->{worker_count}) {
          
          # Open a pipe for the worker
          pipe(my $from_boss, my $to_worker);
          pipe(my $from_worker, my $to_boss);
          
          # Fork off a worker
          my $pid = fork();
          
          if ($pid > 0) {
              
              # Boss
              $self->{workers}->{$pid} = $to_worker;
              $self->{from_worker}->{$pid} = $from_worker;
              $self->{select}->add($from_worker);
  
              # Close unused pipes
              close($to_boss);
              close($from_boss);
              
          } elsif ($pid == 0) {
              
              # Worker
              
              # Close unused pipes
              close($from_worker);
              close($to_worker);
              
              # Setup communication pipes
              $self->{to_boss} = $to_boss;
              open(STDIN, '/dev/null');
              
              # Send the initial request
              $self->send($to_boss, {pid => $$});
              
              # Start processing
              $self->worker($from_boss);
              
              # When the worker subroutine completes, exit
              exit;
          } else {
              confess("Failed to fork: $!");
          }
      }
  }
  
  sub worker(\*) {
      my $self = shift();
      my $from_boss = shift();
      
      # Read instructions from the server
      while (my $instructions = $self->receive($from_boss)) {
          
          # If the handler's children die, that's not our business
          $SIG{CHLD} = 'IGNORE';
          
          # Execute the handler with the given instructions
          my $result;
          eval {
              # Handle alarms
              local $SIG{ALRM} = sub {
                  die "Work handler timed out."
              };
              
              # Set alarm
              alarm($self->{global_timeout});
              
              # Execute the handler and get it's result
              if (defined $self->{work_handler}) {
                  $result = &{ $self->{work_handler} }($instructions);
              }
              
              # Disable alarm
              alarm(0);
          };
          
          # Warn on errors
          if ($@) {
              croak("Worker $$ error: $@");
          }
          
          # Send the result to the server
          $self->send($self->{to_boss}, {pid => $$, data => $result});
      }
  }
  
  sub receive(\*) {
      my $self = shift();
  
      # Get the file handle
      my $fh = shift();
      
      # Get a value from the file handle
      my $value;
      my $char;
      while (read($fh, $char, 1)) {
          $value .= $char;
          if (substr($value, -($self->{msg_delimiter_length})) eq $self->{msg_delimiter}) {
              $value = substr($value, 0, -($self->{msg_delimiter_length}));
              last;
          }
      }
      
      # Deserialize the data
      no strict;
      no warnings;
      my $data = eval($value);
  
      if ($@) {
          print STDERR "Value: '$value'\n" if $ENV{PFBW_DEBUG};
          confess("Failed to deserialize data: $@");
      }
  
      return $data;
  }
  
  sub send(\*$) {
      my $self = shift();
  
      # Get the file handle
      my $fh = shift();
  
      # Get the value which will be sent
      my $value = shift();
  
      # Print the value to the file handle
      local $Data::Dumper::Deepcopy = 1;
      local $Data::Dumper::Indent = 0;
      local $Data::Dumper::Purity = 1;
      print $fh Dumper($value) . $self->{msg_delimiter};
      
      # Force the file handle to flush
      $fh->flush();
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Parallel::Fork::BossWorker - Perl extension for easiliy creating forking queue processing applications.
  
  =head1 SYNOPSIS
  
  The minimal usage of Parallel::Fork::BossWorker requires you supply
  the work_handler argument which returns a hash reference.
  
      use Parallel::Fork::BossWorker;
      
      # Create new BossWorker instance
      my $bw = Parallel::Fork::BossWorker->new(
          work_handler => sub {
              my $work = shift;
              ... do work here ...
              return {};
          }
      );
      
      $bw->add_work({key=>"value"});
      $bw->process();
  
  Additionally, you could specify the result_handler argument, which
  is passed the hash reference returned from your work_handler.
  
      use Parallel::Fork::BossWorker;
      
      # Create new BossWorker instance
      my $bw = Parallel::Fork::BossWorker->new(
          work_handler => sub {
              my $work = shift;
              ... do work here ...
              return {result => "Looks good"};
          },
          result_handler => sub {
              my $result = shift;
              print "$result->{result}\n";
          }
      );
  
  =head1 DESCRIPTION
  
  Parallel::Fork::BossWorker makes creating multiprocess applications easy.
  
  The module is designed to work in a queue style of setup; with the worker
  processes requesting 'work' from the boss process. The boss process
  transparently serializes and sends the work data to your work handler, to be
  consumed and worked. The worker process then transparently serializes and sends
  optional data back to the boss process to be handled in your result handler.
  
  This process repeats until the work queue is empty.
  
  =head1 METHODS
  
  =head2 new(...)
  
  Creates and returns a new Parallel::Fork::BossWorker object.
  
      my $bw = Parallel::Fork::BossWorker->new(work_handler => \&routine)
  
  Parallel::Fork::BossWorker has options which allow you to customize
  how exactly the queue is handled and what is done with the data.
  
  =over 4
  
  =item * C<< work_handler => \&routine >>
  
  The work_handler argument is required, the sub is called with it's first
  and only argument being one of the values in the work queue. Each worker calls
  this sub each time it receives work from the boss process. The handler may trap
  $SIG{ALRM}, which may be called if global_timeout is specified.
  
  The work_handler should clean up after itself, as the workers may call the
  work_handler more than once.
  
  =item * C<< result_handler => \&routine >>
  
  The result_handler argument is optional, the sub is called with it's first
  and only argument being the return value of work_handler. The boss process
  calls this sub each time a worker returns data. This subroutine is not affected
  by the value of global_timeout.
  
  =item * C<< global_timeout => $seconds >>
  
  By default, a handler can execute forever. If global_timeout is specified, an
  alarm is setup to terminate the work_handler so processing can continue.
  
  =item * C<< worker_count => $count >>
  
  By default, 10 workers are started to process the data queue. Specifying
  worker_count can scale the worker count to any number of workers you wish.
  
  Take care though, as too many workers can adversely impact performance, though
  the optimal number of workers will depend on what your handlers do.
  
  =item * C<< msg_delimiter => $delimiter >>
  
  Sending messages to and from the child processes is accomplished using
  Data::Dumper. When transmitting data, a delimiter must be used to identify the
  breaks in messages. By default, this delimiter is "\0\0\0", this delimiter may
  not appear in your data.
  
  =head2 add_work(\%work)
  
  Adds work to the instance's queue.
  
      $bw->add_work({data => "my data"});
  
  =head2 process()
  
  Forks off the child processes and begins processing data.
  
      $bw->process();
  
  =head1 REQUIREMENTS
  
  This module depends on the following modules:
  
  Carp
  
  Data::Dumper
  
  IO::Handle
  
  IO::Select
  
  =head1 BUGS
  
  If we knew about any bugs, we would have fixed them. :)
  
  =head1 SEE ALSO
  
  =head1 AUTHOR
  
  Jeff Rodriguez, E<lt>jeff@jeffrodriguez.comE<gt>
  
  Tim Wilde, E<lt>twilde@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (c) 2007, Jeff Rodriguez
  
  Portions Copyright (c) 2011, Tim Wilde
  
  All rights reserved.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.8.8 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
PARALLEL_FORK_BOSSWORKER

$fatpacked{"Parallel/Fork/BossWorkerAsync.pm"} = <<'PARALLEL_FORK_BOSSWORKERASYNC';
  package Parallel::Fork::BossWorkerAsync;
  use strict;
  use warnings;
  use Carp;
  use Data::Dumper qw( Dumper );
  use Socket       qw( AF_UNIX SOCK_STREAM PF_UNSPEC );
  use Fcntl        qw( F_GETFL F_SETFL O_NONBLOCK );
  use POSIX        qw( EINTR EWOULDBLOCK );
  use IO::Select ();
  
  our @ISA = qw();
  our $VERSION = '0.08';
  
  # TO DO (wish list):
  # Restart crashed child workers.
  
  # -----------------------------------------------------------------
  sub new {
    my ($class, %attrs)=@_;
    my $self = {
      work_handler    => $attrs{work_handler},                # required
      init_handler    => $attrs{init_handler}   || undef,     # optional
      result_handler  => $attrs{result_handler} || undef,     # optional
      worker_count    => $attrs{worker_count}   || 3,         # optional, how many child workers
      global_timeout  => $attrs{global_timeout} || 0,         # optional, in seconds, 0 is unlimited
      msg_delimiter   => $attrs{msg_delimiter}  || "\0\0\0",  # optional, may not appear in data
      read_size       => $attrs{read_size}      || 1024*1024, # optional, defaults to 1 MB
      verbose         => $attrs{verbose}        || 0,         # optional, *undocumented*, 0=silence, 1=debug
      shutting_down   => 0,
      force_down      => 0,
      pending         => 0,
      result_stream   => '',
      result_queue    => [],
      job_queue       => [],
    };
    bless($self, ref($class) || $class);
  
    croak("Parameter 'work_handler' is required") if ! defined($self->{work_handler});
  
    # Start the "boss" process, which will start the workers
    $self->start_boss();
  
    return $self;
  }
  
  # -----------------------------------------------------------------
  sub serialize {
    my ($self, $ref)=@_;
    local $Data::Dumper::Deepcopy = 1;
    local $Data::Dumper::Indent = 0;
    local $Data::Dumper::Purity = 1;
    return Dumper($ref) . $self->{msg_delimiter};
  }
  
  # -----------------------------------------------------------------
  sub deserialize {
    my ($self, $data)=@_;
    $data = substr($data, 0, - length($self->{msg_delimiter}));
    my $VAR1;
    my $ref = eval($data);
    if ($@) {
      confess("failed to deserialize: $@");
    }
    return $ref;  
  }
  
  # -----------------------------------------------------------------
  # Pass one or more hashrefs for the jobs.
  # Main app sends jobs to Boss.
  sub add_work {
    my ($self, @jobs)=@_;
    $self->blocking($self->{boss_socket}, 1);
    while (@jobs) {
      $self->log("add_work: adding job to queue\n");
      my $job = shift(@jobs);
      my $n = syswrite( $self->{boss_socket}, $self->serialize($job) );
      croak("add_work: app write to boss: syswrite: $!") if ! defined($n);
      $self->{pending} ++;
      $self->log("add_work: job added to queue, $self->{pending} pending\n");
    }
  }
  
  # -----------------------------------------------------------------
  # Syntactic nicety
  sub get_result_nb {
    my ($self)=@_;
    return $self->get_result(blocking => 0);
  }
  
  # -----------------------------------------------------------------
  # Main app gets a complete, single result from Boss.
  # If defined, result_handler fires here.
  # Return is result of work_handler, or result_handler (if defined),
  # or {} (empty hash ref).
  # Undef is returned if socket marked nonblocking and read would have
  # blocked.
  sub get_result {
    my ($self, %args)=@_;
    $args{blocking} = 1 if ! defined($args{blocking});
    carp("get_result() when no results pending") if ! $self->pending();
  
    my $rq_count = scalar(@{ $self->{result_queue} });  
    $self->log("get_result: $self->{pending} jobs in process, $rq_count results ready\n");
  
    if ( ! @{ $self->{result_queue} }) {
      $self->blocking($self->{boss_socket}, $args{blocking});
      $self->read($self->{boss_socket}, $self->{result_queue}, \$self->{result_stream}, 'app');
    
      # Handle nonblocking case
      if ( ! $args{blocking}  &&  ! @{ $self->{result_queue} }) {
        return undef;
      }
    }
  
    $self->log("get_result: got result\n");
  
    $self->{pending} --;
    if ($self->{pending} == 0  &&  $self->{shutting_down}) {
      $self->log("get_result: no jobs pending; closing boss\n");
      close($self->{boss_socket});
    }
    my $ref = $self->deserialize( shift( @{ $self->{result_queue} } ) );
    my $retval = $self->{result_handler} ? $self->{result_handler}->($ref) : $ref;
    $retval = {} if ! defined($retval);
    return $retval;
  }
  
  # -----------------------------------------------------------------
  # Main app calls to see if there are submitted jobs for which no
  # response has been collected.  It doesn't mean the responses are
  # ready yet.
  sub pending {
    my ($self)=@_;
    return $self->{pending};
  }
  
  # -----------------------------------------------------------------
  # App tells boss to shut down by half-close.
  # Boss then finishes work in progress, and eventually tells
  # workers to exit.
  # Boss sends all results back to app before exiting itself.
  # Note: Boss won't be able to close cleanly if app ignores
  # final reads...
  # args: force => 0,1  defaults to 0
  sub shut_down {
    my ($self, %args)=@_;
    $args{force} ||= 0;
    $self->{shutting_down} = 1;
  
    $self->log("shut_down: MARK\n");
  
    if ($args{force}) {
      # kill boss pid
      kill(9, $self->{boss_pid});
    } elsif ($self->pending()) {
      shutdown($self->{boss_socket}, 1);
    } else {
      close($self->{boss_socket});
    }
  
    while (wait() != -1) {};		# waits/reaps Boss process
  }
  
  # -----------------------------------------------------------------
  # Make socket blocking/nonblocking
  sub blocking {
    my ($self, $socket, $makeblocking)=@_;
    my $flags = fcntl($socket, F_GETFL, 0)
      or croak("fcntl failed: $!");
    my $blocking = ($flags & O_NONBLOCK) == 0;
    if ($blocking  && ! $makeblocking) {
      $flags |= O_NONBLOCK;
    } elsif (! $blocking && $makeblocking) {
      $flags &= ~O_NONBLOCK;
    } else {
      # do nothing
      return $blocking;
    }
    
    fcntl($socket, F_SETFL, $flags)
      or croak("fcntl failed: $!");
    return $blocking;
  }
  
  # -----------------------------------------------------------------
  sub start_boss {
    my ($self)=@_;
    $self->log("start_boss: start\n");
    eval {
      my ($b1, $b2);
      socketpair($b1, $b2, AF_UNIX, SOCK_STREAM, PF_UNSPEC)
        or die("socketpair: $!");
  
      my $pid = fork();
      defined $pid || confess("fork failed: $!");
  
      if ($pid) {
        # Application (parent)
        $self->{boss_pid} = $pid;
  
        # App won't write to, or read from itself.
        close($b2);
        $self->{boss_socket} = $b1;
  
        $self->log("start_boss: Application: Boss started\n");
  
      } else {
        # Manager aka Boss (child)
        # Boss won't write to, or read from itself.
        close($b1);
        
        $self->{app_socket} = $b2;
        
        # Make nonblocking
        $self->blocking( $self->{app_socket}, 0 );
        open(STDIN, '/dev/null');
        
        $self->start_workers();
        $self->boss_loop();
        while (wait() != -1) {};			# waits/reaps workers only
  
        $self->log("start_boss: Boss: exiting\n");
        exit;
      }
    };
    if ($@) {
      croak($@);
    }
  }
  
  # -----------------------------------------------------------------
  sub start_workers {
    my ($self)=@_;
    $self->log("start_workers: starting $self->{worker_count} workers\n");
    eval {
      for (1 .. $self->{worker_count}) {
        my ($w1, $w2);
        socketpair($w1, $w2, AF_UNIX, SOCK_STREAM, PF_UNSPEC)
          or die("socketpair: $!");
        
        my $pid = fork();
        defined $pid || confess("fork failed: $!");
  
        if ($pid) {
          # Boss (parent)
          close($w2);
          $self->{workers}->{ $w1 } = { pid => $pid, socket => $w1 };
  
          # Make nonblocking
          $self->blocking( $w1, 0 );
          
        } else {
          # Worker (child)
          close($self->{app_socket});
          delete($self->{workers});
          close($w1);
          $self->{socket} = $w2;
          open(STDIN, '/dev/null');
        
          $self->worker_loop();
          exit;
        }
      }
  
      $self->log("start_workers: start workers complete\n");
    };
    if ($@) {
      croak($@);
    }
  }
  
  # -----------------------------------------------------------------
  # Boss process; have an open socket to the app, and one to each worker.
  # Loop select(), checking for read and write on app socket, and read
  # on working children, and write on idle children.
  # Keep track of idle vs. working children.
  # When receive a shutdown order from the app, keep looping until the
  # job queue is empty, and all results have been retrieved (all
  # children will now be idle.)  Then close the worker sockets.
  # They'll be reading, and will notice this and exit.
  # Don't deserialize any data.  Just look for the delimiters to know
  # we're processing whole records.
  #
  
  sub boss_loop {
    my ($self)=@_;
  
    $self->log("boss_loop: start\n");
    eval {
      # handy
      my $workers = $self->{workers};
      
      # All workers start out idle
      for my $s (keys(%$workers)) {
        $workers->{ $s }->{idle} = 1;
      }
      
      while ( 1 ) {
        # When to exit loop?
        #   shutting_down = 1
        #   job_queue empty
        #   all workers idle, and no partial jobs
        #   result_queue empty
        if ($self->{shutting_down}  &&
            ! @{ $self->{job_queue} }  &&
            ! @{ $self->{result_queue} } ) {
          my $busy=0;
          my $partials = 0;
          for my $s (keys(%$workers)) {
            if ( ! $workers->{ $s }->{idle}) {
              $busy ++;
              last;
            } elsif (exists($workers->{ $s }->{partial_job})) {
              $partials ++;
              last;
            }
          }
          if ( ! $busy  &&  ! $partials) {
            # Close all workers
            for my $s (keys(%$workers)) {
              close($workers->{ $s }->{socket});
            }
            close($self->{app_socket});
            last;
          }
        }
        
        # Set up selectors:
        # Always check app for read, unless shutting down.  App write only if
        # there's something in @result_queue.
        my (@rpids, @wpids);
        my $rs = IO::Select->new();
        if ( ! $self->{shutting_down}) {
          $rs->add($self->{app_socket});
          push(@rpids, "app");
        }
        my $ws = IO::Select->new();
        if ( @{ $self->{result_queue} } ) {
          $ws->add($self->{app_socket});
          push(@wpids, "app");
        }
        
        # Check workers for read only if not idle
        # Otherwise, IF job_queue isn't empty,
        # check nonidle workers for write.
        for my $s (keys(%$workers)) {
          if ( $workers->{ $s }->{idle}) {
            if ( @{ $self->{job_queue} }  ||  exists($workers->{ $s }->{partial_job})) {
              $ws->add($workers->{ $s }->{socket});
              push(@wpids, $workers->{ $s }->{pid});
            }
          } else {
            $rs->add($workers->{ $s }->{socket});
            push(@rpids, $workers->{ $s }->{pid});
          }
        }
        
        # Blocking
        my @rdy = IO::Select->select($rs, $ws, undef);
        if ( ! @rdy) {
          if ($! == EINTR) {
            # signal interrupt, continue waiting
            next;
          }
          croak("select failed: $!");
        }
        my ($r, $w) = @rdy[0,1];
        
        # Now we have zero or more reabable sockets, and
        # zero or more writable sockets, but there's at
        # least one socket among the two groups.
        # Read first, as things read can be further handled
        # by writables immediately afterwards.
        
        for my $rh (@$r) {
          my ($source, $queue, $rstream);
          if ($rh != $self->{app_socket}) {
            $source = $workers->{$rh}->{pid};
            $queue = $self->{result_queue};
            $rstream = \$workers->{$rh}->{result_stream};
          } else {
            $source = 'app';
            $queue = $self->{job_queue};
            $rstream = \$self->{job_stream};
          }
  
          $self->log("boss_loop: reading socket\n");        
          $self->read($rh, $queue, $rstream, 'boss');
          $self->log("boss_loop: read socket complete\n");
        }
  
        for my $wh (@$w) {
          my $source = exists($workers->{ $wh }) ? $workers->{ $wh }->{pid} : "app";
          $self->log("boss_loop: writing socket\n");
          $self->write($wh);
          $self->log("boss_loop: write socket complete\n");
        }
      }
    };
    if ($@) {
      croak($@);
    }
  }
  
  # -----------------------------------------------------------------
  sub write {
    my ($self, $socket)=@_;
    if ($socket == $self->{app_socket}) {
      $self->write_app($socket);
    } else {
      $self->write_worker($socket);
    }
  }
  
  # -----------------------------------------------------------------
  sub write_app {
    my ($self, $socket)=@_;
    
    # App socket: write all bytes until would block, or complete.
    # This means process result_queue in order, doing as many elems
    # as possible.  Don't remove from the queue until complete.  In
    # other words, the first item on the queue may be a partial from
    # the previous write attempt.
    my $queue = $self->{result_queue};
    while (@$queue) {
      $self->log("write_app: processing queue entry\n");
      while ( $queue->[0] ) {
        my $n = syswrite($socket, $queue->[0]);
        if ( ! defined($n)) {
          # Block or real socket error
          if ($! == EWOULDBLOCK) {
            # That's it for this socket, try another, or select again.
            return;
          } else {
            croak("boss write to app: syswrite: $!");
          }
        }
          
        elsif ($n == 0) {
          # Application error: socket has been closed prematurely by other party.
          # Boss is supposed to close app socket before app.  App tells Boss to
          # stop, but it only happens after all existing work is completed, and
          # data is sent back to app.
          croak("boss write to app: peer closed prematurely");
            
        } else {
          # wrote some bytes, remove them from the queue elem
          substr($queue->[0], 0, $n) = '';
        }
      }
      # queue elem is empty, remove it, go try next one
      $self->log("write_app: process queue entry complete\n");
      shift(@$queue);
    }
    $self->log("write_app: all queue entries have been written\n");
    # queue is empty, all written!
  }
   
  # -----------------------------------------------------------------
  sub write_worker {
    my ($self, $socket)=@_;
     
    # A worker: check to see if we have a remaining partial
    # job we already started to send.  If so, continue with this.
    # Otherwise, take a *single* job off the job_queue, and send that.
    # When we've gotten either complete, or would block, write remaining
    # portion to per-worker job-in-progress, or make it '' if complete.
    # With worker, we only send ONE job, never more.
    # Once job send is complete, mark worker not-idle.
    
    if ( ! exists($self->{workers}->{ $socket }->{partial_job})) {
      $self->log("write_worker: processing new job\n");
      if (@{ $self->{job_queue} }) {
        $self->{workers}->{ $socket }->{partial_job} = shift(@{ $self->{job_queue} });
      } else {
        # Nothing left on queue.  Remember, we select on *all* idle workers,
        # even if there's only one job on the queue.
        return;
      }
    } else {
      $self->log("write_worker: processing job remnant\n");
    }
    my $rjob = \$self->{workers}->{ $socket }->{partial_job};
    
    while ( length($$rjob) ) {
      $self->log("write_worker: writing...\n");
      my $n = syswrite($socket, $$rjob);
      if ( ! defined($n)) {
        # Block or real socket error
        if ($! == EWOULDBLOCK) {
          # That's it for this socket, try another, or select again.
          return;
        } else {
          croak("boss write to worker: syswrite: $!");
        }
      }
          
      elsif ($n == 0) {
        # Application error: socket has been closed prematurely by other party.
        # Boss is supposed to close worker socket before worker - that's how
        # worker knows to exit.
        croak("boss write to worker: peer closed prematurely (pid " . $self->{workers}->{ $socket }->{pid} . ")");
            
      } else {
        # wrote some bytes, remove them from the job
        substr($$rjob, 0, $n) = '';
        $self->log("write_worker: wrote $n bytes\n");
      }
    }
    # job all written!
    $self->log("write_worker: job complete\n");
    delete($self->{workers}->{ $socket }->{partial_job});
    $self->{workers}->{ $socket }->{idle} = 0;
  }
  
  # -----------------------------------------------------------------
  # Boss exits loop on error, wouldblock, or shutdown msg (socket close).
  # Worker exits loop on error, recd full record, or boss socket close.
  # App exits loop on error, recd full record, wouldblock (nb only), early boss close (error).
  # Stream (as external ref) isn't needed for worker, as it's blocking, and only reads a single
  # record, no more.
  # So $rstream can be undef, and if so, we init locally.
  sub read {
    my ($self, $socket, $queue, $rstream, $iam)=@_;
    my $stream;
    $rstream = \$stream if ! defined($rstream);
    $$rstream = '' if ! defined($$rstream);
  
    # croak messaging details...
    my $source;
    if ($iam eq 'boss') {
      if ($socket == $self->{app_socket}) {
        $source = 'app';
      } else {
        $source = "worker [$self->{workers}->{$socket}->{pid}]";
      }
    } else {    # app or worker, same source
      $source = "boss";
    }
  
    while ( 1 ) {
      $self->log("read: $iam is reading...\n");
  
      my $n = sysread($socket, $$rstream, $self->{read_size}, length($$rstream));
      if ( ! defined($n)) {
        if ($! == EINTR) {
          # signal interrupt, continue reading
          next;
        } elsif ($! == EWOULDBLOCK) {
          last;    # No bytes recd, no need to chunk.
        } else {
          croak("$iam read from $source: sysread: $!");
        }
            
      } elsif ($n == 0) {
        # Application error: socket has been closed prematurely by other party.
        # Boss is supposed to close worker socket before worker - that's how
        # worker knows to exit.
        # Boss is supposed to close app socket before app.  App tells Boss to
        # stop, but it only happens after all existing work is completed, and
        # data is sent back to app.
        if ($iam eq 'boss') {
          if ($socket == $self->{app_socket}) {
            $self->{shutting_down} = 1;
          } elsif (exists($self->{workers}->{$socket})) {
            croak("$iam read from $source: peer closed prematurely (pid " . $self->{workers}->{ $socket }->{pid} . ")");
          }
        } elsif ($iam eq 'worker') {
          close($socket);
        } else {    # i am app
          croak("$iam read from $source: peer closed prematurely (pid " . $self->{boss_pid} . ")");
        }
  
        # if we didn't croak...
        last;
        
      } else {
        # We actually read some bytes.  See if we can chunk
        # out any record(s).
        $self->log("read: $iam read $n bytes\n");
        
        # Split on delimiter
        my @records = split(/(?<=$self->{msg_delimiter})/, $$rstream);
  
        # All but last elem are full records
        my $rcount=$#records;
        push(@$queue, @records[0..$#records-1]);
  
        # Deal with last elem, which may or may not be full record
        if ($records[ $#records ] =~ /$self->{msg_delimiter}$/) {
          # We have a full record
          $rcount++;
          $self->log("read: $iam pushing full record onto queue\n");
          push(@$queue, $records[ $#records ]);
          $$rstream = '';
          if (exists($self->{workers}->{ $socket })) {
            $self->{workers}->{ $socket }->{idle} = 1;
          }
        } else {
          $$rstream = $records[$#records];
        }
  
        # Boss grabs all it can get, only exiting loop on wouldblock.
        # App (even nb method), and workers all exit when one full
        # record is received.
        last if $rcount  &&  $iam ne 'boss';
      }
    }
  }
  
  # -----------------------------------------------------------------
  # Worker process; single blocking socket open to boss.
  # Blocking select loop:
  # Only do read OR write, not both.  We never want more than a single
  # job at a time.  So, if no job currently, read, waiting for one.
  # Get a job, perform it, and try to write results.
  # Send delimiter, which tells boss it has all the results, and we're ready
  # for another job.
  #
  sub worker_loop {
    my ($self)=@_;
    eval {
      if ($self->{init_handler}) {
        $self->log("worker_loop: calling init_handler()\n");
        $self->{init_handler}->();
      }
  
      # String buffers to store serialized data: in and out.
      my $result_stream;
      while ( 1 ) {
        if (defined($result_stream)) {
          # We have a result: write it to boss
          $self->log("worker_loop: writing result...\n");
          
          my $n = syswrite( $self->{socket}, $result_stream);
          croak("worker [$$] write to boss: syswrite: $!") if ! defined($n);
          $self->log("worker_loop: wrote $n bytes\n")       if defined($n);
          $result_stream = undef;
          # will return to top of loop
          
        } else {
          # Get job from boss
          
          my @queue;
          $self->log("worker_loop: reading job from queue...\n");
          $self->read($self->{socket}, \@queue, undef, 'worker');
          return if ! @queue;
          $self->log("worker_loop: read job complete, we have a job\n");
  
          my $job = $self->deserialize($queue[0]);
          my $result;
          eval {
            local $SIG{ALRM} = sub {
              die("BossWorkerAsync: timed out");
            };
  
            # Set alarm
            alarm($self->{global_timeout});
  
            # Invoke handler and get result
            $self->log("worker_loop: calling work_handler for this job\n");
            $result = $self->{work_handler}->($job);
  
            # Disable alarm
            alarm(0);
          };
  
          if ($@) {
            $result = {ERROR => $@};
            $self->log("worker_loop: ERROR: $@\n");
          }
          
          $result_stream = $self->serialize($result);
        }
      }
    };
    if ($@) {
      croak($@);
    }
  }
  
  
  # -----------------------------------------------------------------
  # IN: log message
  # If verbose is enabled, print the message.
  sub log {
    my ($self, $msg) = @_;
    print STDERR $msg   if $self->{verbose};
  }
  
  
  1;
  __END__
  
  =head1 NAME
  
  Parallel::Fork::BossWorkerAsync - Perl extension for creating asynchronous forking queue processing applications.
  
  =head1 SYNOPSIS
  
    use Parallel::Fork::BossWorkerAsync ();
    my $bw = Parallel::Fork::BossWorkerAsync->new(
      work_handler    => \&work,
      result_handler  => \&handle_result,
      global_timeout  => 2,
    );
  
    # Jobs are hashrefs
    $bw->add_work( {a => 3, b => 4} );
    while ($bw->pending()) {
      my $ref = $bw->get_result();
      if ($ref->{ERROR}) {
        print STDERR $ref->{ERROR};
      } else {
        print "$ref->{product}\n";
        print "$ref->{string}\n";
      }
    }
    $bw->shut_down();
  
    sub work {
      my ($job)=@_;
  
      # Uncomment to test timeout
      # sleep(3);
      
      # Uncomment to test worker error
      # die("rattle");
      
      # do something with hash ref $job
      my $c = $job->{a} * $job->{b};
  
      
      # Return values are hashrefs
      return { product => $c };
    }
  
    sub handle_result {
      my ($result)=@_;
      if (exists($result->{product})) {
        $result->{string} = "the answer is: $result->{product}";
      }
      return $result;
    }
  
    __END__
    Prints:
    12
    the answer is: 12
  
  =head1 DESCRIPTION
  
  Parallel::Fork::BossWorkerAsync is a multiprocess preforking server.  On construction, the current process forks a "Boss" process (the server), which then forks one or more "Worker" processes.  The Boss acts as a manager, accepting jobs from the main process, queueing and passing them to the next available idle Worker.  The Boss then listens for, and collects any responses from the Workers as they complete jobs, queueing them for the main process.
  
  The main process can collect available responses from the Boss, and/or send it more jobs, at any time. While waiting for jobs to complete, the main process can enter a blocking wait loop, or do something else altogether, opting to check back later.
  
  In general, it's a good idea to construct the object early in a program's life, before any threads are spawned, and before much memory is allocated, as the Boss, and each Worker will inherit the memory footprint.
  
  =head1 METHODS
  
  =head2 new(...)
  
  Creates and returns a new Parallel::Fork::BossWorkerAsync object.
  
    my $bw = Parallel::Fork::BossWorkerAsync->new(
      work_handler    => \&work_sub,
      result_handler  => \&result_sub,
      init_handler    => \&init_sub,
      global_timeout  => 0,
      worker_count    => 3,
      msg_delimiter   => "\0\0\0",
      read_size       => 1024 * 1024,
    );
  
  =over 4
  
  =item * C<< work_handler => \&work_sub >>
    
  work_handler is the only required argument.  The sub is called with it's first and only argument being one of the values (hashrefs) in the work queue. Each worker calls this sub each time it receives work from the boss process. The handler may trap $SIG{ALRM}, which may be called if global_timeout is specified.
  
  The work_handler should clean up after itself, as the workers may call the work_handler more than once.
  
  The work_handler is expected to return a hashref.
  
  =item * C<< result_handler => \&result_sub >>
  
  The result_handler argument is optional. The sub is called with it's first and only argument being the return value of work_handler, which is expected to be a hashref. If defined, the boss process calls this sub each time the application requests (and receives) a result. This handler is not timed out via $SIG{ALRM}.
  
  The result_handler is expected to return a hashref.
  
  =item * C<< init_handler => \&init_sub >>
  
  The init_handler argument is optional.  The referenced function receives no arguments and returns nothing.  It is called only once by each worker, just after it's forked off from the boss, and before entering the job processing loop. This subroutine is not affected by the value of global_timeout.  This could be used to connect to a database, instantiate a non-shared object, etc.
  
  =item * C<< global_timeout => $seconds >>
  
  By default, a handler can execute forever. If global_timeout is specified, an alarm is setup to terminate the work_handler so processing can continue.
  
  =item * C<< worker_count => $count >>
  
  By default, 3 workers are started to process the data queue. Specifying worker_count can scale the worker count to any number of workers you wish.
  
  =item * C<< msg_delimiter => $delimiter >>
  
  Sending messages to and from the child processes is accomplished using Data::Dumper. When transmitting data, a delimiter must be used to identify the breaks in messages. By default, this delimiter is "\0\0\0".  This delimiter may not appear in your data.
  
  =item * C<< read_size => $number_of_bytes >>
  
  The default read buffer size is 1 megabyte. The application, the boss, and each worker all sysread() from their respective socket connections. Ideally, the read buffer is just large enough to hold all the data that's ready to read. Depending on your application, the default might be ridiculously large, if for example you only pass lookup keys in, and error codes out. If you're running in a memory-constrained environment, you might lower the buffer significantly, perhaps to 64k (1024 * 64), or all the way down to 1k (1024 bytes). If for example you're passing (copying) high resolution audio/video, you will likely benefit from increasing the buffer size. 
  
  An issue has cropped up, reported in more detail under the Bugs section below. Regardless of how large you set the read buffer with this parameter, BSD ignores this, and uses 8192 bytes instead. This can be a big problem if you pass megs of data back and forth, resulting in so many small reads tha the application appears to hang. It will eventually complete, but it's not pretty. Bottom line: don't pass huge chunks of data cross-process under BSD.
  
  =back
  
  =head2 add_work(\%work)
  
  Adds work to the instance's queue.  It accepts a list of hash refs.  add_work() can be called at any time before shut_down().  All work can be added at the beginning, and then the results gathered, or these can be interleaved: add a few jobs, grab the results of one of them, add a few more, grab more results, etc.
  
  Note: Jobs are not guaranteed to be processed in the order they're added.  This is because they are farmed out to multiple workers running concurrently.
  
    $bw->add_work({data => "my data"}, {data => "more stuff"}, ...);
  
  =head2 B<pending()>
  
  This simple function returns a true value if there are jobs that have been submitted for which the results have not yet been retrieved.
  
  Note: This says nothing about the readiness of the results.  Just that at some point, now or in the future, the results will be available for collection.
  
    while ($bw->pending()) { }
  
  =head2 B<get_result()>
  
  Requests the next single available job result from the Boss' result queue.  Returns the return value of the work_handler.  If there is a result_handler defined, it's called here, and the return value of this function is returned instead.  Return from either function is expected to be a hashref. Depending on what your work_handler, or result_handler, does, it may not be interesting to capture this result.
  
  By default, get_result() is a blocking call.  If there are no completed job results available, main application processing will stop here and wait.
  
    my $href = $bw->get_result();
  
  If you want nonblocking behavior:
  
    my $href = $bw->get_result( blocking => 0 );
    -OR-
    my $href = $bw->get_result_nb();
  
  In this case, if the call would block, because there is no result to retrieve, it returns immediately, returning undef.
  
  =head2 B<shut_down()>
  
  Tells the Boss and all Workers to exit.  All results should have been retrieved via get_result() prior to calling shut_down().  If shut_down() is called earlier, the queue *will* be processed, but depending on timing the subsequent calls to get_result() may fail if the boss has already written all result data into the socket buffer and exited.
  
    $bw->shut_down();
  
  If you just want the Boss and Workers to go away, and don't care about work in progress, use:
  
    $bw->shut_down( force => 1 );
  
  =head1 Error handling
  
  Errors generated by your work_handler do not cause the worker process to die. These are stuffed in the result hash with a key of 'ERROR'. The value is $@.
  
  If global_timeout is set, and a timeout occurs, the worker returns:
    { ERROR => 'BossWorkerAsync: timed out' }
  
  =head1 BUGS
  
  Please report bugs to jvann.cpan@gmail.com.
  
  This module will probably not work on Windows due to its reliance on UNIX IPC mechanisms.
  
  The Boss and Worker processes are long-lived. There is no restart mechanism for processes that exit prematurely. If it's the Boss, you're dead anyway, but if it's one or more Workers, the app will continue running, but throughput will suck. 
  
  The code should in some way overcome the tiny socket buffer limitations of BSD operating systems. Unbuffered reads are limited to 8192 byte chunks. If you pass megabytes of data with each job, the processing will not fail, but it will seem to be hung -- it can get VERY slow! This is not an issue on Linux, and will not be a problem on BSD if you pass less then say, 64k, between processes. If you know how to force an unbuffered socket read to use an arbitrarily large buffer (1 megabyte, for example), please shoot me an email.
  
  =head1 CREDITS
  
  I'd like to thank everyone who has reported a bug, asked a question, or offered a suggestion.
  
  Jeff Rodriguez: wrote the module Parallel::Fork::BossWorker, which inspired this module.
  
  Rob Navarro: reported -- and fixed! -- errors in fork() error handling, and in the reaping of dead child processes.
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2009-2013 by joe vannucci, E<lt>jvann.cpan@gmail.comE<gt>
  
  All rights reserved.  This library is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  =cut
PARALLEL_FORK_BOSSWORKERASYNC

$fatpacked{"Params/Check.pm"} = <<'PARAMS_CHECK';
  package Params::Check;
  
  use strict;
  
  use Carp                        qw[carp croak];
  use Locale::Maketext::Simple    Style => 'gettext';
  
  BEGIN {
      use Exporter    ();
      use vars        qw[ @ISA $VERSION @EXPORT_OK $VERBOSE $ALLOW_UNKNOWN
                          $STRICT_TYPE $STRIP_LEADING_DASHES $NO_DUPLICATES
                          $PRESERVE_CASE $ONLY_ALLOW_DEFINED $WARNINGS_FATAL
                          $SANITY_CHECK_TEMPLATE $CALLER_DEPTH $_ERROR_STRING
                      ];
  
      @ISA        =   qw[ Exporter ];
      @EXPORT_OK  =   qw[check allow last_error];
  
      $VERSION                = '0.38';
      $VERBOSE                = $^W ? 1 : 0;
      $NO_DUPLICATES          = 0;
      $STRIP_LEADING_DASHES   = 0;
      $STRICT_TYPE            = 0;
      $ALLOW_UNKNOWN          = 0;
      $PRESERVE_CASE          = 0;
      $ONLY_ALLOW_DEFINED     = 0;
      $SANITY_CHECK_TEMPLATE  = 1;
      $WARNINGS_FATAL         = 0;
      $CALLER_DEPTH           = 0;
  }
  
  my %known_keys = map { $_ => 1 }
                      qw| required allow default strict_type no_override
                          store defined |;
  
  =pod
  
  =head1 NAME
  
  Params::Check - A generic input parsing/checking mechanism.
  
  =head1 SYNOPSIS
  
      use Params::Check qw[check allow last_error];
  
      sub fill_personal_info {
          my %hash = @_;
          my $x;
  
          my $tmpl = {
              firstname   => { required   => 1, defined => 1 },
              lastname    => { required   => 1, store => \$x },
              gender      => { required   => 1,
                               allow      => [qr/M/i, qr/F/i],
                             },
              married     => { allow      => [0,1] },
              age         => { default    => 21,
                               allow      => qr/^\d+$/,
                             },
  
              phone       => { allow => [ sub { return 1 if /$valid_re/ },
                                          '1-800-PERL' ]
                             },
              id_list     => { default        => [],
                               strict_type    => 1
                             },
              employer    => { default => 'NSA', no_override => 1 },
          };
  
          ### check() returns a hashref of parsed args on success ###
          my $parsed_args = check( $tmpl, \%hash, $VERBOSE )
                              or die qw[Could not parse arguments!];
  
          ... other code here ...
      }
  
      my $ok = allow( $colour, [qw|blue green yellow|] );
  
      my $error = Params::Check::last_error();
  
  
  =head1 DESCRIPTION
  
  Params::Check is a generic input parsing/checking mechanism.
  
  It allows you to validate input via a template. The only requirement
  is that the arguments must be named.
  
  Params::Check can do the following things for you:
  
  =over 4
  
  =item *
  
  Convert all keys to lowercase
  
  =item *
  
  Check if all required arguments have been provided
  
  =item *
  
  Set arguments that have not been provided to the default
  
  =item *
  
  Weed out arguments that are not supported and warn about them to the
  user
  
  =item *
  
  Validate the arguments given by the user based on strings, regexes,
  lists or even subroutines
  
  =item *
  
  Enforce type integrity if required
  
  =back
  
  Most of Params::Check's power comes from its template, which we'll
  discuss below:
  
  =head1 Template
  
  As you can see in the synopsis, based on your template, the arguments
  provided will be validated.
  
  The template can take a different set of rules per key that is used.
  
  The following rules are available:
  
  =over 4
  
  =item default
  
  This is the default value if none was provided by the user.
  This is also the type C<strict_type> will look at when checking type
  integrity (see below).
  
  =item required
  
  A boolean flag that indicates if this argument was a required
  argument. If marked as required and not provided, check() will fail.
  
  =item strict_type
  
  This does a C<ref()> check on the argument provided. The C<ref> of the
  argument must be the same as the C<ref> of the default value for this
  check to pass.
  
  This is very useful if you insist on taking an array reference as
  argument for example.
  
  =item defined
  
  If this template key is true, enforces that if this key is provided by
  user input, its value is C<defined>. This just means that the user is
  not allowed to pass C<undef> as a value for this key and is equivalent
  to:
      allow => sub { defined $_[0] && OTHER TESTS }
  
  =item no_override
  
  This allows you to specify C<constants> in your template. ie, they
  keys that are not allowed to be altered by the user. It pretty much
  allows you to keep all your C<configurable> data in one place; the
  C<Params::Check> template.
  
  =item store
  
  This allows you to pass a reference to a scalar, in which the data
  will be stored:
  
      my $x;
      my $args = check(foo => { default => 1, store => \$x }, $input);
  
  This is basically shorthand for saying:
  
      my $args = check( { foo => { default => 1 }, $input );
      my $x    = $args->{foo};
  
  You can alter the global variable $Params::Check::NO_DUPLICATES to
  control whether the C<store>'d key will still be present in your
  result set. See the L<Global Variables> section below.
  
  =item allow
  
  A set of criteria used to validate a particular piece of data if it
  has to adhere to particular rules.
  
  See the C<allow()> function for details.
  
  =back
  
  =head1 Functions
  
  =head2 check( \%tmpl, \%args, [$verbose] );
  
  This function is not exported by default, so you'll have to ask for it
  via:
  
      use Params::Check qw[check];
  
  or use its fully qualified name instead.
  
  C<check> takes a list of arguments, as follows:
  
  =over 4
  
  =item Template
  
  This is a hash reference which contains a template as explained in the
  C<SYNOPSIS> and C<Template> section.
  
  =item Arguments
  
  This is a reference to a hash of named arguments which need checking.
  
  =item Verbose
  
  A boolean to indicate whether C<check> should be verbose and warn
  about what went wrong in a check or not.
  
  You can enable this program wide by setting the package variable
  C<$Params::Check::VERBOSE> to a true value. For details, see the
  section on C<Global Variables> below.
  
  =back
  
  C<check> will return when it fails, or a hashref with lowercase
  keys of parsed arguments when it succeeds.
  
  So a typical call to check would look like this:
  
      my $parsed = check( \%template, \%arguments, $VERBOSE )
                      or warn q[Arguments could not be parsed!];
  
  A lot of the behaviour of C<check()> can be altered by setting
  package variables. See the section on C<Global Variables> for details
  on this.
  
  =cut
  
  sub check {
      my ($utmpl, $href, $verbose) = @_;
  
      ### clear the current error string ###
      _clear_error();
  
      ### did we get the arguments we need? ###
      if ( !$utmpl or !$href ) {
        _store_error(loc('check() expects two arguments'));
        return unless $WARNINGS_FATAL;
        croak(__PACKAGE__->last_error);
      }
  
      ### sensible defaults ###
      $verbose ||= $VERBOSE || 0;
  
      ### XXX what type of template is it? ###
      ### { key => { } } ?
      #if (ref $args eq 'HASH') {
      #    1;
      #}
  
      ### clean up the template ###
      my $args;
  
      ### don't even bother to loop, if there's nothing to clean up ###
      if( $PRESERVE_CASE and !$STRIP_LEADING_DASHES ) {
          $args = $href;
      } else {
          ### keys are not aliased ###
          for my $key (keys %$href) {
              my $org = $key;
              $key = lc $key unless $PRESERVE_CASE;
              $key =~ s/^-// if $STRIP_LEADING_DASHES;
              $args->{$key} = $href->{$org};
          }
      }
  
      my %defs;
  
      ### which template entries have a 'store' member
      my @want_store;
  
      ### sanity check + defaults + required keys set? ###
      my $fail;
      for my $key (keys %$utmpl) {
          my $tmpl = $utmpl->{$key};
  
          ### check if required keys are provided
          ### keys are now lower cased, unless preserve case was enabled
          ### at which point, the utmpl keys must match, but that's the users
          ### problem.
          if( $tmpl->{'required'} and not exists $args->{$key} ) {
              _store_error(
                  loc(q|Required option '%1' is not provided for %2 by %3|,
                      $key, _who_was_it(), _who_was_it(1)), $verbose );
  
              ### mark the error ###
              $fail++;
              next;
          }
  
          ### next, set the default, make sure the key exists in %defs ###
          $defs{$key} = $tmpl->{'default'}
                          if exists $tmpl->{'default'};
  
          if( $SANITY_CHECK_TEMPLATE ) {
              ### last, check if they provided any weird template keys
              ### -- do this last so we don't always execute this code.
              ### just a small optimization.
              map {   _store_error(
                          loc(q|Template type '%1' not supported [at key '%2']|,
                          $_, $key), 1, 0 );
              } grep {
                  not $known_keys{$_}
              } keys %$tmpl;
  
              ### make sure you passed a ref, otherwise, complain about it!
              if ( exists $tmpl->{'store'} ) {
                  _store_error( loc(
                      q|Store variable for '%1' is not a reference!|, $key
                  ), 1, 0 ) unless ref $tmpl->{'store'};
              }
          }
  
          push @want_store, $key if $tmpl->{'store'};
      }
  
      ### errors found ###
      return if $fail;
  
      ### flag to see if anything went wrong ###
      my $wrong;
  
      ### flag to see if we warned for anything, needed for warnings_fatal
      my $warned;
  
      for my $key (keys %$args) {
          my $arg = $args->{$key};
  
          ### you gave us this key, but it's not in the template ###
          unless( $utmpl->{$key} ) {
  
              ### but we'll allow it anyway ###
              if( $ALLOW_UNKNOWN ) {
                  $defs{$key} = $arg;
  
              ### warn about the error ###
              } else {
                  _store_error(
                      loc("Key '%1' is not a valid key for %2 provided by %3",
                          $key, _who_was_it(), _who_was_it(1)), $verbose);
                  $warned ||= 1;
              }
              next;
          }
  
          ### copy of this keys template instructions, to save derefs ###
          my %tmpl = %{$utmpl->{$key}};
  
          ### check if you're even allowed to override this key ###
          if( $tmpl{'no_override'} ) {
              _store_error(
                  loc(q[You are not allowed to override key '%1'].
                      q[for %2 from %3], $key, _who_was_it(), _who_was_it(1)),
                  $verbose
              );
              $warned ||= 1;
              next;
          }
  
          ### check if you were supposed to provide defined() values ###
          if( ($tmpl{'defined'} || $ONLY_ALLOW_DEFINED) and not defined $arg ) {
              _store_error(loc(q|Key '%1' must be defined when passed|, $key),
                  $verbose );
              $wrong ||= 1;
              next;
          }
  
          ### check if they should be of a strict type, and if it is ###
          if( ($tmpl{'strict_type'} || $STRICT_TYPE) and
              (ref $arg ne ref $tmpl{'default'})
          ) {
              _store_error(loc(q|Key '%1' needs to be of type '%2'|,
                          $key, ref $tmpl{'default'} || 'SCALAR'), $verbose );
              $wrong ||= 1;
              next;
          }
  
          ### check if we have an allow handler, to validate against ###
          ### allow() will report its own errors ###
          if( exists $tmpl{'allow'} and not do {
                  local $_ERROR_STRING;
                  allow( $arg, $tmpl{'allow'} )
              }
          ) {
              ### stringify the value in the error report -- we don't want dumps
              ### of objects, but we do want to see *roughly* what we passed
              _store_error(loc(q|Key '%1' (%2) is of invalid type for '%3' |.
                               q|provided by %4|,
                              $key, "$arg", _who_was_it(),
                              _who_was_it(1)), $verbose);
              $wrong ||= 1;
              next;
          }
  
          ### we got here, then all must be OK ###
          $defs{$key} = $arg;
  
      }
  
      ### croak with the collected errors if there were errors and
      ### we have the fatal flag toggled.
      croak(__PACKAGE__->last_error) if ($wrong || $warned) && $WARNINGS_FATAL;
  
      ### done with our loop... if $wrong is set, something went wrong
      ### and the user is already informed, just return...
      return if $wrong;
  
      ### check if we need to store any of the keys ###
      ### can't do it before, because something may go wrong later,
      ### leaving the user with a few set variables
      for my $key (@want_store) {
          next unless exists $defs{$key};
          my $ref = $utmpl->{$key}{'store'};
          $$ref = $NO_DUPLICATES ? delete $defs{$key} : $defs{$key};
      }
  
      return \%defs;
  }
  
  =head2 allow( $test_me, \@criteria );
  
  The function that handles the C<allow> key in the template is also
  available for independent use.
  
  The function takes as first argument a key to test against, and
  as second argument any form of criteria that are also allowed by
  the C<allow> key in the template.
  
  You can use the following types of values for allow:
  
  =over 4
  
  =item string
  
  The provided argument MUST be equal to the string for the validation
  to pass.
  
  =item regexp
  
  The provided argument MUST match the regular expression for the
  validation to pass.
  
  =item subroutine
  
  The provided subroutine MUST return true in order for the validation
  to pass and the argument accepted.
  
  (This is particularly useful for more complicated data).
  
  =item array ref
  
  The provided argument MUST equal one of the elements of the array
  ref for the validation to pass. An array ref can hold all the above
  values.
  
  =back
  
  It returns true if the key matched the criteria, or false otherwise.
  
  =cut
  
  sub allow {
      ### use $_[0] and $_[1] since this is hot code... ###
      #my ($val, $ref) = @_;
  
      ### it's a regexp ###
      if( ref $_[1] eq 'Regexp' ) {
          local $^W;  # silence warnings if $val is undef #
          return if $_[0] !~ /$_[1]/;
  
      ### it's a sub ###
      } elsif ( ref $_[1] eq 'CODE' ) {
          return unless $_[1]->( $_[0] );
  
      ### it's an array ###
      } elsif ( ref $_[1] eq 'ARRAY' ) {
  
          ### loop over the elements, see if one of them says the
          ### value is OK
          ### also, short-circuit when possible
          for ( @{$_[1]} ) {
              return 1 if allow( $_[0], $_ );
          }
  
          return;
  
      ### fall back to a simple, but safe 'eq' ###
      } else {
          return unless _safe_eq( $_[0], $_[1] );
      }
  
      ### we got here, no failures ###
      return 1;
  }
  
  ### helper functions ###
  
  sub _safe_eq {
      ### only do a straight 'eq' if they're both defined ###
      return defined($_[0]) && defined($_[1])
                  ? $_[0] eq $_[1]
                  : defined($_[0]) eq defined($_[1]);
  }
  
  sub _who_was_it {
      my $level = $_[0] || 0;
  
      return (caller(2 + $CALLER_DEPTH + $level))[3] || 'ANON'
  }
  
  =head2 last_error()
  
  Returns a string containing all warnings and errors reported during
  the last time C<check> was called.
  
  This is useful if you want to report then some other way than
  C<carp>'ing when the verbose flag is on.
  
  It is exported upon request.
  
  =cut
  
  {   $_ERROR_STRING = '';
  
      sub _store_error {
          my($err, $verbose, $offset) = @_[0..2];
          $verbose ||= 0;
          $offset  ||= 0;
          my $level   = 1 + $offset;
  
          local $Carp::CarpLevel = $level;
  
          carp $err if $verbose;
  
          $_ERROR_STRING .= $err . "\n";
      }
  
      sub _clear_error {
          $_ERROR_STRING = '';
      }
  
      sub last_error { $_ERROR_STRING }
  }
  
  1;
  
  =head1 Global Variables
  
  The behaviour of Params::Check can be altered by changing the
  following global variables:
  
  =head2 $Params::Check::VERBOSE
  
  This controls whether Params::Check will issue warnings and
  explanations as to why certain things may have failed.
  If you set it to 0, Params::Check will not output any warnings.
  
  The default is 1 when L<warnings> are enabled, 0 otherwise;
  
  =head2 $Params::Check::STRICT_TYPE
  
  This works like the C<strict_type> option you can pass to C<check>,
  which will turn on C<strict_type> globally for all calls to C<check>.
  
  The default is 0;
  
  =head2 $Params::Check::ALLOW_UNKNOWN
  
  If you set this flag, unknown options will still be present in the
  return value, rather than filtered out. This is useful if your
  subroutine is only interested in a few arguments, and wants to pass
  the rest on blindly to perhaps another subroutine.
  
  The default is 0;
  
  =head2 $Params::Check::STRIP_LEADING_DASHES
  
  If you set this flag, all keys passed in the following manner:
  
      function( -key => 'val' );
  
  will have their leading dashes stripped.
  
  =head2 $Params::Check::NO_DUPLICATES
  
  If set to true, all keys in the template that are marked as to be
  stored in a scalar, will also be removed from the result set.
  
  Default is false, meaning that when you use C<store> as a template
  key, C<check> will put it both in the scalar you supplied, as well as
  in the hashref it returns.
  
  =head2 $Params::Check::PRESERVE_CASE
  
  If set to true, L<Params::Check> will no longer convert all keys from
  the user input to lowercase, but instead expect them to be in the
  case the template provided. This is useful when you want to use
  similar keys with different casing in your templates.
  
  Understand that this removes the case-insensitivity feature of this
  module.
  
  Default is 0;
  
  =head2 $Params::Check::ONLY_ALLOW_DEFINED
  
  If set to true, L<Params::Check> will require all values passed to be
  C<defined>. If you wish to enable this on a 'per key' basis, use the
  template option C<defined> instead.
  
  Default is 0;
  
  =head2 $Params::Check::SANITY_CHECK_TEMPLATE
  
  If set to true, L<Params::Check> will sanity check templates, validating
  for errors and unknown keys. Although very useful for debugging, this
  can be somewhat slow in hot-code and large loops.
  
  To disable this check, set this variable to C<false>.
  
  Default is 1;
  
  =head2 $Params::Check::WARNINGS_FATAL
  
  If set to true, L<Params::Check> will C<croak> when an error during
  template validation occurs, rather than return C<false>.
  
  Default is 0;
  
  =head2 $Params::Check::CALLER_DEPTH
  
  This global modifies the argument given to C<caller()> by
  C<Params::Check::check()> and is useful if you have a custom wrapper
  function around C<Params::Check::check()>. The value must be an
  integer, indicating the number of wrapper functions inserted between
  the real function call and C<Params::Check::check()>.
  
  Example wrapper function, using a custom stacktrace:
  
      sub check {
          my ($template, $args_in) = @_;
  
          local $Params::Check::WARNINGS_FATAL = 1;
          local $Params::Check::CALLER_DEPTH = $Params::Check::CALLER_DEPTH + 1;
          my $args_out = Params::Check::check($template, $args_in);
  
          my_stacktrace(Params::Check::last_error) unless $args_out;
  
          return $args_out;
      }
  
  Default is 0;
  
  =head1 Acknowledgements
  
  Thanks to Richard Soderberg for his performance improvements.
  
  =head1 BUG REPORTS
  
  Please report bugs or other issues to E<lt>bug-params-check@rt.cpan.orgE<gt>.
  
  =head1 AUTHOR
  
  This module by Jos Boumans E<lt>kane@cpan.orgE<gt>.
  
  =head1 COPYRIGHT
  
  This library is free software; you may redistribute and/or modify it
  under the same terms as Perl itself.
  
  
  =cut
  
  # Local variables:
  # c-indentation-style: bsd
  # c-basic-offset: 4
  # indent-tabs-mode: nil
  # End:
  # vim: expandtab shiftwidth=4:
PARAMS_CHECK

$fatpacked{"Perl6/Junction.pm"} = <<'PERL6_JUNCTION';
  package Perl6::Junction;
  use strict;
  
  use Perl6::Junction::All;
  use Perl6::Junction::Any;
  use Perl6::Junction::None;
  use Perl6::Junction::One;
  
  require Exporter;
  our $VERSION = '1.50000';
  
  our @ISA = qw/ Exporter /;
  my @routines = qw/ all any none one /;
  our @EXPORT_OK = @routines;
  our %EXPORT_TAGS = ( ALL => [@routines] );
  
  sub all {
      return Perl6::Junction::All->new(@_);
  }
  
  sub any {
      return Perl6::Junction::Any->new(@_);
  }
  
  sub none {
      return Perl6::Junction::None->new(@_);
  }
  
  sub one {
      return Perl6::Junction::One->new(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Perl6::Junction - Perl6 style Junction operators in Perl5.
  
  =head1 SYNOPSIS
  
    use Perl6::Junction qw/ all any none one /;
    
    if (any(@grant) eq 'su') {
      ...
    }
    
    if (all($foo, $bar) >= 10) {
      ...
    }
    
    if (qr/^\d+$/ == all(@answers)) {
      ...
    }
    
    if (all(@input) <= @limits) {
      ...
    }
    
    if (none(@pass) eq 'password') {
      ...
    }
    
    if (one(@answer) == 42) {
      ...
    }
  
  =head1 DESCRIPTION
  
  This is a lightweight module which provides 'Junction' operators, the most 
  commonly used being C<any> and C<all>.
  
  Inspired by the Perl6 design docs, 
  L<http://dev.perl.org/perl6/doc/design/exe/E06.html>.
  
  Provides a limited subset of the functionality of L<Quantum::Superpositions>, 
  see L</"SEE ALSO"> for comment.
  
  Notice in the L</SYNOPSIS> above, that if you want to match against a 
  regular expression, you must use C<==> or C<!=>. B<Not> C<=~> or C<!~>. You 
  must also use a regex object, such as C<qr/\d/>, not a plain regex such as 
  C</\d/>.
  
  
  =head1 SUBROUTINES
  
  =head2 all()
  
  Returns an object which overloads the following operators:
  
    '<',  '<=', '>',  '>=', '==', '!=', 
    'lt', 'le', 'gt', 'ge', 'eq', 'ne', 
    '~~'
  
  Returns true only if B<all> arguments test true according to the operator 
  used.
  
  =head2 any()
  
  Returns an object which overloads the following operators:
  
    '<',  '<=', '>',  '>=', '==', '!=', 
    'lt', 'le', 'gt', 'ge', 'eq', 'ne', 
    '~~'
  
  Returns true if B<any> argument tests true according to the operator used.
  
  =head2 none()
  
  Returns an object which overloads the following operators:
  
    '<',  '<=', '>',  '>=', '==', '!=', 
    'lt', 'le', 'gt', 'ge', 'eq', 'ne', 
    '~~'
  
  Returns true only if B<no> argument tests true according to the operator 
  used.
  
  =head2 one()
  
  Returns an object which overloads the following operators:
  
    '<',  '<=', '>',  '>=', '==', '!=', 
    'lt', 'le', 'gt', 'ge', 'eq', 'ne', 
    '~~'
  
  Returns true only if B<one and only one> argument tests true according to 
  the operator used.
  
  =head1 ALTERING JUNCTIONS
  
  You cannot alter junctions.  Instead, you can create new junctions out of old
  junctions.  You can do this by calling the C<values> method on a junction.
  
   my $numbers = any(qw/1 2 3 4 5/);
   print $numbers == 3 ? 'Yes' : 'No';   # Yes
  
   $numbers = any( grep { $_ != 3 } $numbers->values );
   print $numbers == 3 ? 'Yes' : 'No';   # No
  
  =head1 EXPORT
  
  'all', 'any', 'none', 'one', as requested.
  
  All subroutines can be called by its fully qualified name, if you don't 
  want to export them.
  
    use Perl6::Junction;
    
    if (Perl6::Junction::any( @questions )) {
      ...
    }
  
  =head1 WARNING
  
  When comparing against a regular expression, you must remember to use a 
  regular expression object: C<qr/\d/> B<Not> C</d/>. You must also use either 
  C<==> or C<!=>. This is because C<=~> and C<!~> cannot be overriden.
  
  =head1 TO DO
  
  Add overloading for arithmetic operators, such that this works:
  
    $result = any(2,3,4) * 2;
    
    if ($result == 8) {...}
  
  =head1 SUPPORT / BUGS
  
  Submit to the CPAN bugtracker L<http://rt.cpan.org>
  
  =head1 SEE ALSO
  
  L<Quantum::Superpositions> provides the same functionality as this, and 
  more. However, this module provides this limited functionality at a much 
  greater runtime speed, with my benchmarks showing between 500% and 6000% 
  improvment.
  
  L<http://dev.perl.org/perl6/doc/design/exe/E06.html> - "The Wonderful World 
  of Junctions".
  
  =head1 AUTHOR
  
  Carl Franks
  
  =head1 ACKNOWLEDGEMENTS
  
  Thanks to C<Curtis "Ovid" Poe> for the L</"ALTERING JUNCTIONS"> changes in
  release C<0.40000>.
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2005, Carl Franks.  All rights reserved.  
  
  This library is free software; you can redistribute it and/or modify it under 
  the same terms as Perl itself (L<perlgpl>, L<perlartistic>).
  
  =cut
  
PERL6_JUNCTION

$fatpacked{"Perl6/Junction/All.pm"} = <<'PERL6_JUNCTION_ALL';
  package Perl6::Junction::All;
  use strict;
  our $VERSION = '1.50000';
  
  use base 'Perl6::Junction::Base';
  
  BEGIN {
    if ($] >= 5.010001) {
      eval q<
  sub match {
      my ( $self, $other, $is_rhs ) = @_;
  
      if ($is_rhs) {
          for (@$self) {
              return unless $other ~~ $_;
          }
  
          return 1;
      }
  
      for (@$self) {
          return unless $_ ~~ $other;
      }
  
      return 1;
  }
  >
    }
  }
  
  sub num_eq {
      return regex_eq(@_) if ref( $_[1] ) eq 'Regexp';
  
      my ( $self, $test ) = @_;
  
      for (@$self) {
          return unless $_ == $test;
      }
  
      return 1;
  }
  
  sub num_ne {
      return regex_ne(@_) if ref( $_[1] ) eq 'Regexp';
  
      my ( $self, $test ) = @_;
  
      for (@$self) {
          return unless $_ != $test;
      }
  
      return 1;
  }
  
  sub num_ge {
      my ( $self, $test, $switch ) = @_;
  
      return num_le( $self, $test ) if $switch;
  
      for (@$self) {
          return unless $_ >= $test;
      }
  
      return 1;
  }
  
  sub num_gt {
      my ( $self, $test, $switch ) = @_;
  
      return num_lt( $self, $test ) if $switch;
  
      for (@$self) {
          return unless $_ > $test;
      }
  
      return 1;
  }
  
  sub num_le {
      my ( $self, $test, $switch ) = @_;
  
      return num_ge( $self, $test ) if $switch;
  
      for (@$self) {
          return unless $_ <= $test;
      }
  
      return 1;
  }
  
  sub num_lt {
      my ( $self, $test, $switch ) = @_;
  
      return num_gt( $self, $test ) if $switch;
  
      for (@$self) {
          return unless $_ < $test;
      }
  
      return 1;
  }
  
  sub str_eq {
      my ( $self, $test ) = @_;
  
      for (@$self) {
          return unless $_ eq $test;
      }
  
      return 1;
  }
  
  sub str_ne {
      my ( $self, $test ) = @_;
  
      for (@$self) {
          return unless $_ ne $test;
      }
  
      return 1;
  }
  
  sub str_ge {
      my ( $self, $test, $switch ) = @_;
  
      return str_le( $self, $test ) if $switch;
  
      for (@$self) {
          return unless $_ ge $test;
      }
  
      return 1;
  }
  
  sub str_gt {
      my ( $self, $test, $switch ) = @_;
  
      return str_lt( $self, $test ) if $switch;
  
      for (@$self) {
          return unless $_ gt $test;
      }
  
      return 1;
  }
  
  sub str_le {
      my ( $self, $test, $switch ) = @_;
  
      return str_ge( $self, $test ) if $switch;
  
      for (@$self) {
          return unless $_ le $test;
      }
  
      return 1;
  }
  
  sub str_lt {
      my ( $self, $test, $switch ) = @_;
  
      return str_gt( $self, $test ) if $switch;
  
      for (@$self) {
          return unless $_ lt $test;
      }
  
      return 1;
  }
  
  sub regex_eq {
      my ( $self, $test, $switch ) = @_;
  
      for (@$self) {
          return unless $_ =~ $test;
      }
  
      return 1;
  }
  
  sub regex_ne {
      my ( $self, $test, $switch ) = @_;
  
      for (@$self) {
          return unless $_ !~ $test;
      }
  
      return 1;
  }
  
  sub bool {
      my ($self) = @_;
  
      for (@$self) {
          return unless $_;
      }
  
      return 1;
  }
  
  1;
  
PERL6_JUNCTION_ALL

$fatpacked{"Perl6/Junction/Any.pm"} = <<'PERL6_JUNCTION_ANY';
  package Perl6::Junction::Any;
  use strict;
  our $VERSION = '1.50000';
  
  use base 'Perl6::Junction::Base';
  
  BEGIN {
    if ($] >= 5.010001) {
      eval q<
  sub match {
      my ( $self, $other, $is_rhs ) = @_;
  
      if ($is_rhs) {
          for (@$self) {
              return 1 if $other ~~ $_;
          }
  
          return;
      }
  
      for (@$self) {
          return 1 if $_ ~~ $other;
      }
  
      return;
  }
  >
    }
  }
  
  sub num_eq {
      return regex_eq(@_) if ref( $_[1] ) eq 'Regexp';
  
      my ( $self, $test ) = @_;
  
      for (@$self) {
          return 1 if $_ == $test;
      }
  
      return;
  }
  
  sub num_ne {
      return regex_ne(@_) if ref( $_[1] ) eq 'Regexp';
  
      my ( $self, $test ) = @_;
  
      for (@$self) {
          return 1 if $_ != $test;
      }
  
      return;
  }
  
  sub num_ge {
      my ( $self, $test, $switch ) = @_;
  
      return num_le( $self, $test ) if $switch;
  
      for (@$self) {
          return 1 if $_ >= $test;
      }
  
      return;
  }
  
  sub num_gt {
      my ( $self, $test, $switch ) = @_;
  
      return num_lt( $self, $test ) if $switch;
  
      for (@$self) {
          return 1 if $_ > $test;
      }
  
      return;
  }
  
  sub num_le {
      my ( $self, $test, $switch ) = @_;
  
      return num_ge( $self, $test ) if $switch;
  
      for (@$self) {
          return 1 if $_ <= $test;
      }
  
      return;
  }
  
  sub num_lt {
      my ( $self, $test, $switch ) = @_;
  
      return num_gt( $self, $test ) if $switch;
  
      for (@$self) {
          return 1 if $_ < $test;
      }
  
      return;
  }
  
  sub str_eq {
      my ( $self, $test ) = @_;
  
      for (@$self) {
          return 1 if $_ eq $test;
      }
  
      return;
  }
  
  sub str_ne {
      my ( $self, $test ) = @_;
  
      for (@$self) {
          return 1 if $_ ne $test;
      }
  
      return;
  }
  
  sub str_ge {
      my ( $self, $test, $switch ) = @_;
  
      return str_le( $self, $test ) if $switch;
  
      for (@$self) {
          return 1 if $_ ge $test;
      }
  
      return;
  }
  
  sub str_gt {
      my ( $self, $test, $switch ) = @_;
  
      return str_lt( $self, $test ) if $switch;
  
      for (@$self) {
          return 1 if $_ gt $test;
      }
  
      return;
  }
  
  sub str_le {
      my ( $self, $test, $switch ) = @_;
  
      return str_ge( $self, $test ) if $switch;
  
      for (@$self) {
          return 1 if $_ le $test;
      }
  
      return;
  }
  
  sub str_lt {
      my ( $self, $test, $switch ) = @_;
  
      return str_gt( $self, $test ) if $switch;
  
      for (@$self) {
          return 1 if $_ lt $test;
      }
  
      return;
  }
  
  sub regex_eq {
      my ( $self, $test, $switch ) = @_;
  
      for (@$self) {
          return 1 if $_ =~ $test;
      }
  
      return;
  }
  
  sub regex_ne {
      my ( $self, $test, $switch ) = @_;
  
      for (@$self) {
          return 1 if $_ !~ $test;
      }
  
      return;
  }
  
  sub bool {
      my ($self) = @_;
  
      for (@$self) {
          return 1 if $_;
      }
  
      return;
  }
  
  1;
  
PERL6_JUNCTION_ANY

$fatpacked{"Perl6/Junction/Base.pm"} = <<'PERL6_JUNCTION_BASE';
  package Perl6::Junction::Base;
  use strict;
  our $VERSION = '1.50000';
  
  use overload(
      '=='   => "num_eq",
      '!='   => "num_ne",
      '>='   => "num_ge",
      '>'    => "num_gt",
      '<='   => "num_le",
      '<'    => "num_lt",
      'eq'   => "str_eq",
      'ne'   => "str_ne",
      'ge'   => "str_ge",
      'gt'   => "str_gt",
      'le'   => "str_le",
      'lt'   => "str_lt",
      'bool' => "bool",
      '""'   => sub {shift},
  );
  
  use if ($] >= 5.010001), overload => '~~' => 'match';
  
  sub new {
      my ( $class, @param ) = @_;
      return bless \@param, $class;
  }
  
  sub values {
      my $self = shift;
      return wantarray ? @$self : [ @$self ];
  }
  
  1;
  
PERL6_JUNCTION_BASE

$fatpacked{"Perl6/Junction/None.pm"} = <<'PERL6_JUNCTION_NONE';
  package Perl6::Junction::None;
  use strict;
  our $VERSION = '1.50000';
  
  use base 'Perl6::Junction::Base';
  
  BEGIN {
    if ($] >= 5.010001) {
      eval q<
  sub match {
      my ( $self, $other, $is_rhs ) = @_;
  
      if ($is_rhs) {
          for (@$self) {
              return if $other ~~ $_;
          }
  
          return 1;
      }
  
      for (@$self) {
          return if $_ ~~ $other;
      }
  
      return 1;
  }
  >
    }
  }
  
  sub num_eq {
      return regex_eq(@_) if ref( $_[1] ) eq 'Regexp';
  
      my ( $self, $test ) = @_;
  
      for (@$self) {
          return if $_ == $test;
      }
  
      return 1;
  }
  
  sub num_ne {
      return regex_ne(@_) if ref( $_[1] ) eq 'Regexp';
  
      my ( $self, $test ) = @_;
  
      for (@$self) {
          return if $_ != $test;
      }
  
      return 1;
  }
  
  sub num_ge {
      my ( $self, $test, $switch ) = @_;
  
      return num_le( $self, $test ) if $switch;
  
      for (@$self) {
          return if $_ >= $test;
      }
  
      return 1;
  }
  
  sub num_gt {
      my ( $self, $test, $switch ) = @_;
  
      return num_lt( $self, $test ) if $switch;
  
      for (@$self) {
          return if $_ > $test;
      }
  
      return 1;
  }
  
  sub num_le {
      my ( $self, $test, $switch ) = @_;
  
      return num_ge( $self, $test ) if $switch;
  
      for (@$self) {
          return if $_ <= $test;
      }
  
      return 1;
  }
  
  sub num_lt {
      my ( $self, $test, $switch ) = @_;
  
      return num_gt( $self, $test ) if $switch;
  
      for (@$self) {
          return if $_ < $test;
      }
  
      return 1;
  }
  
  sub str_eq {
      my ( $self, $test ) = @_;
  
      for (@$self) {
          return if $_ eq $test;
      }
  
      return 1;
  }
  
  sub str_ne {
      my ( $self, $test ) = @_;
  
      for (@$self) {
          return if $_ ne $test;
      }
  
      return 1;
  }
  
  sub str_ge {
      my ( $self, $test, $switch ) = @_;
  
      return str_le( $self, $test ) if $switch;
  
      for (@$self) {
          return if $_ ge $test;
      }
  
      return 1;
  }
  
  sub str_gt {
      my ( $self, $test, $switch ) = @_;
  
      return str_lt( $self, $test ) if $switch;
  
      for (@$self) {
          return if $_ gt $test;
      }
  
      return 1;
  }
  
  sub str_le {
      my ( $self, $test, $switch ) = @_;
  
      return str_ge( $self, $test ) if $switch;
  
      for (@$self) {
          return if $_ le $test;
      }
  
      return 1;
  }
  
  sub str_lt {
      my ( $self, $test, $switch ) = @_;
  
      return str_gt( $self, $test ) if $switch;
  
      for (@$self) {
          return if $_ lt $test;
      }
  
      return 1;
  }
  
  sub regex_eq {
      my ( $self, $test, $switch ) = @_;
  
      for (@$self) {
          return if $_ =~ $test;
      }
  
      return 1;
  }
  
  sub regex_ne {
      my ( $self, $test, $switch ) = @_;
  
      for (@$self) {
          return if $_ !~ $test;
      }
  
      return 1;
  }
  
  sub bool {
      my ($self) = @_;
  
      for (@$self) {
          return if $_;
      }
  
      return 1;
  }
  
  1;
  
PERL6_JUNCTION_NONE

$fatpacked{"Perl6/Junction/One.pm"} = <<'PERL6_JUNCTION_ONE';
  package Perl6::Junction::One;
  use strict;
  our $VERSION = '1.50000';
  
  use base 'Perl6::Junction::Base';
  
  BEGIN {
    if ($] >= 5.010001) {
      eval q<
  sub match {
      my ( $self, $other, $is_rhs ) = @_;
  
      my $count = 0;
  
      if ($is_rhs) {
  
          for (@$self) {
              if ($other ~~ $_) {
                return if $count;
                $count = 1;
              }
          }
  
          return($count == 1);
      }
  
      for (@$self) {
          if ($_ ~~ $other) {
              return if $count;
              $count = 1;
          }
      }
  
      return($count == 1);
  }
  >
    }
  }
  
  sub num_eq {
      return regex_eq(@_) if ref( $_[1] ) eq 'Regexp';
  
      my ( $self, $test ) = @_;
      my $count = 0;
  
      for (@$self) {
          if ( $_ == $test ) {
              return if $count;
              $count = 1;
          }
      }
  
      return 1 if $count;
  }
  
  sub num_ne {
      return regex_ne(@_) if ref( $_[1] ) eq 'Regexp';
  
      my ( $self, $test ) = @_;
      my $count = 0;
  
      for (@$self) {
          if ( $_ != $test ) {
              return if $count;
              $count = 1;
          }
      }
  
      return 1 if $count;
  }
  
  sub num_ge {
      my ( $self, $test, $switch ) = @_;
  
      return num_le( $self, $test ) if $switch;
  
      my $count = 0;
  
      for (@$self) {
          if ( $_ >= $test ) {
              return if $count;
              $count = 1;
          }
      }
  
      return 1 if $count;
  }
  
  sub num_gt {
      my ( $self, $test, $switch ) = @_;
  
      return num_lt( $self, $test ) if $switch;
  
      my $count = 0;
  
      for (@$self) {
          if ( $_ > $test ) {
              return if $count;
              $count = 1;
          }
      }
  
      return 1 if $count;
  }
  
  sub num_le {
      my ( $self, $test, $switch ) = @_;
  
      return num_ge( $self, $test ) if $switch;
  
      my $count = 0;
  
      for (@$self) {
          if ( $_ <= $test ) {
              return if $count;
              $count = 1;
          }
      }
  
      return 1 if $count;
  }
  
  sub num_lt {
      my ( $self, $test, $switch ) = @_;
  
      return num_gt( $self, $test ) if $switch;
  
      my $count = 0;
  
      for (@$self) {
          if ( $_ < $test ) {
              return if $count;
              $count = 1;
          }
      }
  
      return 1 if $count;
  }
  
  sub str_eq {
      my ( $self, $test ) = @_;
      my $count = 0;
  
      for (@$self) {
          if ( $_ eq $test ) {
              return if $count;
              $count = 1;
          }
      }
  
      return 1 if $count;
  }
  
  sub str_ne {
      my ( $self, $test ) = @_;
      my $count = 0;
  
      for (@$self) {
          if ( $_ ne $test ) {
              return if $count;
              $count = 1;
          }
      }
  
      return 1 if $count;
  }
  
  sub str_ge {
      my ( $self, $test, $switch ) = @_;
  
      return str_le( $self, $test ) if $switch;
  
      my $count = 0;
  
      for (@$self) {
          if ( $_ ge $test ) {
              return if $count;
              $count = 1;
          }
      }
  
      return 1 if $count;
  }
  
  sub str_gt {
      my ( $self, $test, $switch ) = @_;
  
      return str_lt( $self, $test ) if $switch;
  
      my $count = 0;
  
      for (@$self) {
          if ( $_ gt $test ) {
              return if $count;
              $count = 1;
          }
      }
  
      return 1 if $count;
  }
  
  sub str_le {
      my ( $self, $test, $switch ) = @_;
  
      return str_ge( $self, $test ) if $switch;
  
      my $count = 0;
  
      for (@$self) {
          if ( $_ le $test ) {
              return if $count;
              $count = 1;
          }
      }
  
      return 1 if $count;
  }
  
  sub str_lt {
      my ( $self, $test, $switch ) = @_;
  
      return str_gt( $self, $test ) if $switch;
  
      my $count = 0;
  
      for (@$self) {
          if ( $_ lt $test ) {
              return if $count;
              $count = 1;
          }
      }
  
      return 1 if $count;
  }
  
  sub regex_eq {
      my ( $self, $test, $switch ) = @_;
  
      my $count = 0;
  
      for (@$self) {
          if ( $_ =~ $test ) {
              return if $count;
              $count = 1;
          }
      }
  
      return 1 if $count;
  }
  
  sub regex_ne {
      my ( $self, $test, $switch ) = @_;
  
      my $count = 0;
  
      for (@$self) {
          if ( $_ !~ $test ) {
              return if $count;
              $count = 1;
          }
      }
  
      return 1 if $count;
  }
  
  sub bool {
      my ($self) = @_;
      my $count = 0;
  
      for (@$self) {
          if ($_) {
              return if $count;
              $count = 1;
          }
      }
  
      return 1 if $count;
  }
  
  1;
  
PERL6_JUNCTION_ONE

$fatpacked{"Try/Tiny.pm"} = <<'TRY_TINY';
  package Try::Tiny;
  
  use strict;
  #use warnings;
  
  use vars qw(@EXPORT @EXPORT_OK $VERSION @ISA);
  
  BEGIN {
  	require Exporter;
  	@ISA = qw(Exporter);
  }
  
  $VERSION = "0.12";
  
  $VERSION = eval $VERSION;
  
  @EXPORT = @EXPORT_OK = qw(try catch finally);
  
  $Carp::Internal{+__PACKAGE__}++;
  
  # Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
  # Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
  # context & not a scalar one
  
  sub try (&;@) {
  	my ( $try, @code_refs ) = @_;
  
  	# we need to save this here, the eval block will be in scalar context due
  	# to $failed
  	my $wantarray = wantarray;
  
  	my ( $catch, @finally );
  
  	# find labeled blocks in the argument list.
  	# catch and finally tag the blocks by blessing a scalar reference to them.
  	foreach my $code_ref (@code_refs) {
  		next unless $code_ref;
  
  		my $ref = ref($code_ref);
  
  		if ( $ref eq 'Try::Tiny::Catch' ) {
  			$catch = ${$code_ref};
  		} elsif ( $ref eq 'Try::Tiny::Finally' ) {
  			push @finally, ${$code_ref};
  		} else {
  			use Carp;
  			confess("Unknown code ref type given '${ref}'. Check your usage & try again");
  		}
  	}
  
  	# save the value of $@ so we can set $@ back to it in the beginning of the eval
  	my $prev_error = $@;
  
  	my ( @ret, $error, $failed );
  
  	# FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
  	# not perfect, but we could provide a list of additional errors for
  	# $catch->();
  
  	{
  		# localize $@ to prevent clobbering of previous value by a successful
  		# eval.
  		local $@;
  
  		# failed will be true if the eval dies, because 1 will not be returned
  		# from the eval body
  		$failed = not eval {
  			$@ = $prev_error;
  
  			# evaluate the try block in the correct context
  			if ( $wantarray ) {
  				@ret = $try->();
  			} elsif ( defined $wantarray ) {
  				$ret[0] = $try->();
  			} else {
  				$try->();
  			};
  
  			return 1; # properly set $fail to false
  		};
  
  		# copy $@ to $error; when we leave this scope, local $@ will revert $@
  		# back to its previous value
  		$error = $@;
  	}
  
  	# set up a scope guard to invoke the finally block at the end
  	my @guards =
      map { Try::Tiny::ScopeGuard->_new($_, $failed ? $error : ()) }
      @finally;
  
  	# at this point $failed contains a true value if the eval died, even if some
  	# destructor overwrote $@ as the eval was unwinding.
  	if ( $failed ) {
  		# if we got an error, invoke the catch block.
  		if ( $catch ) {
  			# This works like given($error), but is backwards compatible and
  			# sets $_ in the dynamic scope for the body of C<$catch>
  			for ($error) {
  				return $catch->($error);
  			}
  
  			# in case when() was used without an explicit return, the C<for>
  			# loop will be aborted and there's no useful return value
  		}
  
  		return;
  	} else {
  		# no failure, $@ is back to what it was, everything is fine
  		return $wantarray ? @ret : $ret[0];
  	}
  }
  
  sub catch (&;@) {
  	my ( $block, @rest ) = @_;
  
  	return (
  		bless(\$block, 'Try::Tiny::Catch'),
  		@rest,
  	);
  }
  
  sub finally (&;@) {
  	my ( $block, @rest ) = @_;
  
  	return (
  		bless(\$block, 'Try::Tiny::Finally'),
  		@rest,
  	);
  }
  
  {
    package # hide from PAUSE
      Try::Tiny::ScopeGuard;
  
    sub _new {
      shift;
      bless [ @_ ];
    }
  
    sub DESTROY {
      my @guts = @{ shift() };
      my $code = shift @guts;
      $code->(@guts);
    }
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Try::Tiny - minimal try/catch with proper localization of $@
  
  =head1 SYNOPSIS
  
  You can use Try::Tiny's C<try> and C<catch> to expect and handle exceptional
  conditions, avoiding quirks in Perl and common mistakes:
  
  	# handle errors with a catch handler
  	try {
  		die "foo";
  	} catch {
  		warn "caught error: $_"; # not $@
  	};
  
  You can also use it like a standalone C<eval> to catch and ignore any error
  conditions.  Obviously, this is an extreme measure not to be undertaken
  lightly:
  
  	# just silence errors
  	try {
  		die "foo";
  	};
  
  =head1 DESCRIPTION
  
  This module provides bare bones C<try>/C<catch>/C<finally> statements that are designed to
  minimize common mistakes with eval blocks, and NOTHING else.
  
  This is unlike L<TryCatch> which provides a nice syntax and avoids adding
  another call stack layer, and supports calling C<return> from the C<try> block to
  return from the parent subroutine. These extra features come at a cost of a few
  dependencies, namely L<Devel::Declare> and L<Scope::Upper> which are
  occasionally problematic, and the additional catch filtering uses L<Moose>
  type constraints which may not be desirable either.
  
  The main focus of this module is to provide simple and reliable error handling
  for those having a hard time installing L<TryCatch>, but who still want to
  write correct C<eval> blocks without 5 lines of boilerplate each time.
  
  It's designed to work as correctly as possible in light of the various
  pathological edge cases (see L</BACKGROUND>) and to be compatible with any style
  of error values (simple strings, references, objects, overloaded objects, etc).
  
  If the C<try> block dies, it returns the value of the last statement executed in
  the C<catch> block, if there is one. Otherwise, it returns C<undef> in scalar
  context or the empty list in list context. The following examples all
  assign C<"bar"> to C<$x>:
  
  	my $x = try { die "foo" } catch { "bar" };
  	my $x = try { die "foo" } || { "bar" };
  	my $x = (try { die "foo" }) // { "bar" };
  
  	my $x = eval { die "foo" } || "bar";
  
  You can add C<finally> blocks, yielding the following:
  
  	my $x;
  	try { die 'foo' } finally { $x = 'bar' };
  	try { die 'foo' } catch { warn "Got a die: $_" } finally { $x = 'bar' };
  
  C<finally> blocks are always executed making them suitable for cleanup code
  which cannot be handled using local.  You can add as many C<finally> blocks to a
  given C<try> block as you like.
  
  =head1 EXPORTS
  
  All functions are exported by default using L<Exporter>.
  
  If you need to rename the C<try>, C<catch> or C<finally> keyword consider using
  L<Sub::Import> to get L<Sub::Exporter>'s flexibility.
  
  =over 4
  
  =item try (&;@)
  
  Takes one mandatory C<try> subroutine, an optional C<catch> subroutine and C<finally>
  subroutine.
  
  The mandatory subroutine is evaluated in the context of an C<eval> block.
  
  If no error occurred the value from the first block is returned, preserving
  list/scalar context.
  
  If there was an error and the second subroutine was given it will be invoked
  with the error in C<$_> (localized) and as that block's first and only
  argument.
  
  C<$@> does B<not> contain the error. Inside the C<catch> block it has the same
  value it had before the C<try> block was executed.
  
  Note that the error may be false, but if that happens the C<catch> block will
  still be invoked.
  
  Once all execution is finished then the C<finally> block, if given, will execute.
  
  =item catch (&;$)
  
  Intended to be used in the second argument position of C<try>.
  
  Returns a reference to the subroutine it was given but blessed as
  C<Try::Tiny::Catch> which allows try to decode correctly what to do
  with this code reference.
  
  	catch { ... }
  
  Inside the C<catch> block the caught error is stored in C<$_>, while previous
  value of C<$@> is still available for use.  This value may or may not be
  meaningful depending on what happened before the C<try>, but it might be a good
  idea to preserve it in an error stack.
  
  For code that captures C<$@> when throwing new errors (i.e.
  L<Class::Throwable>), you'll need to do:
  
  	local $@ = $_;
  
  =item finally (&;$)
  
    try     { ... }
    catch   { ... }
    finally { ... };
  
  Or
  
    try     { ... }
    finally { ... };
  
  Or even
  
    try     { ... }
    finally { ... }
    catch   { ... };
  
  Intended to be the second or third element of C<try>. C<finally> blocks are always
  executed in the event of a successful C<try> or if C<catch> is run. This allows
  you to locate cleanup code which cannot be done via C<local()> e.g. closing a file
  handle.
  
  When invoked, the C<finally> block is passed the error that was caught.  If no
  error was caught, it is passed nothing.  (Note that the C<finally> block does not
  localize C<$_> with the error, since unlike in a C<catch> block, there is no way
  to know if C<$_ == undef> implies that there were no errors.) In other words,
  the following code does just what you would expect:
  
    try {
      die_sometimes();
    } catch {
      # ...code run in case of error
    } finally {
      if (@_) {
        print "The try block died with: @_\n";
      } else {
        print "The try block ran without error.\n";
      }
    };
  
  B<You must always do your own error handling in the C<finally> block>. C<Try::Tiny> will
  not do anything about handling possible errors coming from code located in these
  blocks.
  
  In the same way C<catch()> blesses the code reference this subroutine does the same
  except it bless them as C<Try::Tiny::Finally>.
  
  =back
  
  =head1 BACKGROUND
  
  There are a number of issues with C<eval>.
  
  =head2 Clobbering $@
  
  When you run an C<eval> block and it succeeds, C<$@> will be cleared, potentially
  clobbering an error that is currently being caught.
  
  This causes action at a distance, clearing previous errors your caller may have
  not yet handled.
  
  C<$@> must be properly localized before invoking C<eval> in order to avoid this
  issue.
  
  More specifically, C<$@> is clobbered at the beginning of the C<eval>, which
  also makes it impossible to capture the previous error before you die (for
  instance when making exception objects with error stacks).
  
  For this reason C<try> will actually set C<$@> to its previous value (before
  the localization) in the beginning of the C<eval> block.
  
  =head2 Localizing $@ silently masks errors
  
  Inside an C<eval> block, C<die> behaves sort of like:
  
  	sub die {
  		$@ = $_[0];
  		return_undef_from_eval();
  	}
  
  This means that if you were polite and localized C<$@> you can't die in that
  scope, or your error will be discarded (printing "Something's wrong" instead).
  
  The workaround is very ugly:
  
  	my $error = do {
  		local $@;
  		eval { ... };
  		$@;
  	};
  
  	...
  	die $error;
  
  =head2 $@ might not be a true value
  
  This code is wrong:
  
  	if ( $@ ) {
  		...
  	}
  
  because due to the previous caveats it may have been unset.
  
  C<$@> could also be an overloaded error object that evaluates to false, but
  that's asking for trouble anyway.
  
  The classic failure mode is:
  
  	sub Object::DESTROY {
  		eval { ... }
  	}
  
  	eval {
  		my $obj = Object->new;
  
  		die "foo";
  	};
  
  	if ( $@ ) {
  
  	}
  
  In this case since C<Object::DESTROY> is not localizing C<$@> but still uses
  C<eval>, it will set C<$@> to C<"">.
  
  The destructor is called when the stack is unwound, after C<die> sets C<$@> to
  C<"foo at Foo.pm line 42\n">, so by the time C<if ( $@ )> is evaluated it has
  been cleared by C<eval> in the destructor.
  
  The workaround for this is even uglier than the previous ones. Even though we
  can't save the value of C<$@> from code that doesn't localize, we can at least
  be sure the C<eval> was aborted due to an error:
  
  	my $failed = not eval {
  		...
  
  		return 1;
  	};
  
  This is because an C<eval> that caught a C<die> will always return a false
  value.
  
  =head1 SHINY SYNTAX
  
  Using Perl 5.10 you can use L<perlsyn/"Switch statements">.
  
  The C<catch> block is invoked in a topicalizer context (like a C<given> block),
  but note that you can't return a useful value from C<catch> using the C<when>
  blocks without an explicit C<return>.
  
  This is somewhat similar to Perl 6's C<CATCH> blocks. You can use it to
  concisely match errors:
  
  	try {
  		require Foo;
  	} catch {
  		when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
  		default { die $_ }
  	};
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  C<@_> is not available within the C<try> block, so you need to copy your
  arglist. In case you want to work with argument values directly via C<@_>
  aliasing (i.e. allow C<$_[1] = "foo">), you need to pass C<@_> by reference:
  
  	sub foo {
  		my ( $self, @args ) = @_;
  		try { $self->bar(@args) }
  	}
  
  or
  
  	sub bar_in_place {
  		my $self = shift;
  		my $args = \@_;
  		try { $_ = $self->bar($_) for @$args }
  	}
  
  =item *
  
  C<return> returns from the C<try> block, not from the parent sub (note that
  this is also how C<eval> works, but not how L<TryCatch> works):
  
    sub parent_sub {
        try {
            die;
        }
        catch {
            return;
        };
  
        say "this text WILL be displayed, even though an exception is thrown";
    }
  
  Instead, you should capture the return value:
  
    sub parent_sub {
        my $success = try {
            die;
            1;
        }
        return unless $success;
  
        say "This text WILL NEVER appear!";
    }
  
  Note that if you have a C<catch> block, it must return C<undef> for this to work,
  since if a C<catch> block exists, its return value is returned in place of C<undef>
  when an exception is thrown.
  
  =item *
  
  C<try> introduces another caller stack frame. L<Sub::Uplevel> is not used. L<Carp>
  will not report this when using full stack traces, though, because
  C<%Carp::Internal> is used. This lack of magic is considered a feature.
  
  =item *
  
  The value of C<$_> in the C<catch> block is not guaranteed to be the value of
  the exception thrown (C<$@>) in the C<try> block.  There is no safe way to
  ensure this, since C<eval> may be used unhygenically in destructors.  The only
  guarantee is that the C<catch> will be called if an exception is thrown.
  
  =item *
  
  The return value of the C<catch> block is not ignored, so if testing the result
  of the expression for truth on success, be sure to return a false value from
  the C<catch> block:
  
  	my $obj = try {
  		MightFail->new;
  	} catch {
  		...
  
  		return; # avoid returning a true value;
  	};
  
  	return unless $obj;
  
  =item *
  
  C<$SIG{__DIE__}> is still in effect.
  
  Though it can be argued that C<$SIG{__DIE__}> should be disabled inside of
  C<eval> blocks, since it isn't people have grown to rely on it. Therefore in
  the interests of compatibility, C<try> does not disable C<$SIG{__DIE__}> for
  the scope of the error throwing code.
  
  =item *
  
  Lexical C<$_> may override the one set by C<catch>.
  
  For example Perl 5.10's C<given> form uses a lexical C<$_>, creating some
  confusing behavior:
  
  	given ($foo) {
  		when (...) {
  			try {
  				...
  			} catch {
  				warn $_; # will print $foo, not the error
  				warn $_[0]; # instead, get the error like this
  			}
  		}
  	}
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<TryCatch>
  
  Much more feature complete, more convenient semantics, but at the cost of
  implementation complexity.
  
  =item L<autodie>
  
  Automatic error throwing for builtin functions and more. Also designed to
  work well with C<given>/C<when>.
  
  =item L<Throwable>
  
  A lightweight role for rolling your own exception classes.
  
  =item L<Error>
  
  Exception object implementation with a C<try> statement. Does not localize
  C<$@>.
  
  =item L<Exception::Class::TryCatch>
  
  Provides a C<catch> statement, but properly calling C<eval> is your
  responsibility.
  
  The C<try> keyword pushes C<$@> onto an error stack, avoiding some of the
  issues with C<$@>, but you still need to localize to prevent clobbering.
  
  =back
  
  =head1 LIGHTNING TALK
  
  I gave a lightning talk about this module, you can see the slides (Firefox
  only):
  
  L<http://nothingmuch.woobling.org/talks/takahashi.xul?data=yapc_asia_2009/try_tiny.txt>
  
  Or read the source:
  
  L<http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
  
  =head1 VERSION CONTROL
  
  L<http://github.com/nothingmuch/try-tiny/>
  
  =head1 AUTHOR
  
  Yuval Kogman E<lt>nothingmuch@woobling.orgE<gt>
  
  =head1 COPYRIGHT
  
  	Copyright (c) 2009 Yuval Kogman. All rights reserved.
  	This program is free software; you can redistribute
  	it and/or modify it under the terms of the MIT license.
  
  =cut
  
TRY_TINY

$fatpacked{"URI.pm"} = <<'URI';
  package URI;
  
  use strict;
  use vars qw($VERSION);
  $VERSION = "1.60";
  
  use vars qw($ABS_REMOTE_LEADING_DOTS $ABS_ALLOW_RELATIVE_SCHEME $DEFAULT_QUERY_FORM_DELIMITER);
  
  my %implements;  # mapping from scheme to implementor class
  
  # Some "official" character classes
  
  use vars qw($reserved $mark $unreserved $uric $scheme_re);
  $reserved   = q(;/?:@&=+$,[]);
  $mark       = q(-_.!~*'());                                    #'; emacs
  $unreserved = "A-Za-z0-9\Q$mark\E";
  $uric       = quotemeta($reserved) . $unreserved . "%";
  
  $scheme_re  = '[a-zA-Z][a-zA-Z0-9.+\-]*';
  
  use Carp ();
  use URI::Escape ();
  
  use overload ('""'     => sub { ${$_[0]} },
                '=='     => sub { _obj_eq(@_) },
                '!='     => sub { !_obj_eq(@_) },
                fallback => 1,
               );
  
  # Check if two objects are the same object
  sub _obj_eq {
      return overload::StrVal($_[0]) eq overload::StrVal($_[1]);
  }
  
  sub new
  {
      my($class, $uri, $scheme) = @_;
  
      $uri = defined ($uri) ? "$uri" : "";   # stringify
      # Get rid of potential wrapping
      $uri =~ s/^<(?:URL:)?(.*)>$/$1/;  # 
      $uri =~ s/^"(.*)"$/$1/;
      $uri =~ s/^\s+//;
      $uri =~ s/\s+$//;
  
      my $impclass;
      if ($uri =~ m/^($scheme_re):/so) {
  	$scheme = $1;
      }
      else {
  	if (($impclass = ref($scheme))) {
  	    $scheme = $scheme->scheme;
  	}
  	elsif ($scheme && $scheme =~ m/^($scheme_re)(?::|$)/o) {
  	    $scheme = $1;
          }
      }
      $impclass ||= implementor($scheme) ||
  	do {
  	    require URI::_foreign;
  	    $impclass = 'URI::_foreign';
  	};
  
      return $impclass->_init($uri, $scheme);
  }
  
  
  sub new_abs
  {
      my($class, $uri, $base) = @_;
      $uri = $class->new($uri, $base);
      $uri->abs($base);
  }
  
  
  sub _init
  {
      my $class = shift;
      my($str, $scheme) = @_;
      # find all funny characters and encode the bytes.
      $str = $class->_uric_escape($str);
      $str = "$scheme:$str" unless $str =~ /^$scheme_re:/o ||
                                   $class->_no_scheme_ok;
      my $self = bless \$str, $class;
      $self;
  }
  
  
  sub _uric_escape
  {
      my($class, $str) = @_;
      $str =~ s*([^$uric\#])* URI::Escape::escape_char($1) *ego;
      utf8::downgrade($str);
      return $str;
  }
  
  
  sub implementor
  {
      my($scheme, $impclass) = @_;
      if (!$scheme || $scheme !~ /\A$scheme_re\z/o) {
  	require URI::_generic;
  	return "URI::_generic";
      }
  
      $scheme = lc($scheme);
  
      if ($impclass) {
  	# Set the implementor class for a given scheme
          my $old = $implements{$scheme};
          $impclass->_init_implementor($scheme);
          $implements{$scheme} = $impclass;
          return $old;
      }
  
      my $ic = $implements{$scheme};
      return $ic if $ic;
  
      # scheme not yet known, look for internal or
      # preloaded (with 'use') implementation
      $ic = "URI::$scheme";  # default location
  
      # turn scheme into a valid perl identifier by a simple transformation...
      $ic =~ s/\+/_P/g;
      $ic =~ s/\./_O/g;
      $ic =~ s/\-/_/g;
  
      no strict 'refs';
      # check we actually have one for the scheme:
      unless (@{"${ic}::ISA"}) {
          # Try to load it
          eval "require $ic";
          die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;
          return unless @{"${ic}::ISA"};
      }
  
      $ic->_init_implementor($scheme);
      $implements{$scheme} = $ic;
      $ic;
  }
  
  
  sub _init_implementor
  {
      my($class, $scheme) = @_;
      # Remember that one implementor class may actually
      # serve to implement several URI schemes.
  }
  
  
  sub clone
  {
      my $self = shift;
      my $other = $$self;
      bless \$other, ref $self;
  }
  
  
  sub _no_scheme_ok { 0 }
  
  sub _scheme
  {
      my $self = shift;
  
      unless (@_) {
  	return unless $$self =~ /^($scheme_re):/o;
  	return $1;
      }
  
      my $old;
      my $new = shift;
      if (defined($new) && length($new)) {
  	Carp::croak("Bad scheme '$new'") unless $new =~ /^$scheme_re$/o;
  	$old = $1 if $$self =~ s/^($scheme_re)://o;
  	my $newself = URI->new("$new:$$self");
  	$$self = $$newself; 
  	bless $self, ref($newself);
      }
      else {
  	if ($self->_no_scheme_ok) {
  	    $old = $1 if $$self =~ s/^($scheme_re)://o;
  	    Carp::carp("Oops, opaque part now look like scheme")
  		if $^W && $$self =~ m/^$scheme_re:/o
  	}
  	else {
  	    $old = $1 if $$self =~ m/^($scheme_re):/o;
  	}
      }
  
      return $old;
  }
  
  sub scheme
  {
      my $scheme = shift->_scheme(@_);
      return unless defined $scheme;
      lc($scheme);
  }
  
  
  sub opaque
  {
      my $self = shift;
  
      unless (@_) {
  	$$self =~ /^(?:$scheme_re:)?([^\#]*)/o or die;
  	return $1;
      }
  
      $$self =~ /^($scheme_re:)?    # optional scheme
  	        ([^\#]*)          # opaque
                  (\#.*)?           # optional fragment
                $/sx or die;
  
      my $old_scheme = $1;
      my $old_opaque = $2;
      my $old_frag   = $3;
  
      my $new_opaque = shift;
      $new_opaque = "" unless defined $new_opaque;
      $new_opaque =~ s/([^$uric])/ URI::Escape::escape_char($1)/ego;
      utf8::downgrade($new_opaque);
  
      $$self = defined($old_scheme) ? $old_scheme : "";
      $$self .= $new_opaque;
      $$self .= $old_frag if defined $old_frag;
  
      $old_opaque;
  }
  
  *path = \&opaque;  # alias
  
  
  sub fragment
  {
      my $self = shift;
      unless (@_) {
  	return unless $$self =~ /\#(.*)/s;
  	return $1;
      }
  
      my $old;
      $old = $1 if $$self =~ s/\#(.*)//s;
  
      my $new_frag = shift;
      if (defined $new_frag) {
  	$new_frag =~ s/([^$uric])/ URI::Escape::escape_char($1) /ego;
  	utf8::downgrade($new_frag);
  	$$self .= "#$new_frag";
      }
      $old;
  }
  
  
  sub as_string
  {
      my $self = shift;
      $$self;
  }
  
  
  sub as_iri
  {
      my $self = shift;
      my $str = $$self;
      if ($str =~ s/%([89a-fA-F][0-9a-fA-F])/chr(hex($1))/eg) {
  	# All this crap because the more obvious:
  	#
  	#   Encode::decode("UTF-8", $str, sub { sprintf "%%%02X", shift })
  	#
  	# doesn't work before Encode 2.39.  Wait for a standard release
  	# to bundle that version.
  
  	require Encode;
  	my $enc = Encode::find_encoding("UTF-8");
  	my $u = "";
  	while (length $str) {
  	    $u .= $enc->decode($str, Encode::FB_QUIET());
  	    if (length $str) {
  		# escape next char
  		$u .= URI::Escape::escape_char(substr($str, 0, 1, ""));
  	    }
  	}
  	$str = $u;
      }
      return $str;
  }
  
  
  sub canonical
  {
      # Make sure scheme is lowercased, that we don't escape unreserved chars,
      # and that we use upcase escape sequences.
  
      my $self = shift;
      my $scheme = $self->_scheme || "";
      my $uc_scheme = $scheme =~ /[A-Z]/;
      my $esc = $$self =~ /%[a-fA-F0-9]{2}/;
      return $self unless $uc_scheme || $esc;
  
      my $other = $self->clone;
      if ($uc_scheme) {
  	$other->_scheme(lc $scheme);
      }
      if ($esc) {
  	$$other =~ s{%([0-9a-fA-F]{2})}
  	            { my $a = chr(hex($1));
                        $a =~ /^[$unreserved]\z/o ? $a : "%\U$1"
                      }ge;
      }
      return $other;
  }
  
  # Compare two URIs, subclasses will provide a more correct implementation
  sub eq {
      my($self, $other) = @_;
      $self  = URI->new($self, $other) unless ref $self;
      $other = URI->new($other, $self) unless ref $other;
      ref($self) eq ref($other) &&                # same class
  	$self->canonical->as_string eq $other->canonical->as_string;
  }
  
  # generic-URI transformation methods
  sub abs { $_[0]; }
  sub rel { $_[0]; }
  
  sub secure { 0 }
  
  # help out Storable
  sub STORABLE_freeze {
         my($self, $cloning) = @_;
         return $$self;
  }
  
  sub STORABLE_thaw {
         my($self, $cloning, $str) = @_;
         $$self = $str;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI - Uniform Resource Identifiers (absolute and relative)
  
  =head1 SYNOPSIS
  
   $u1 = URI->new("http://www.perl.com");
   $u2 = URI->new("foo", "http");
   $u3 = $u2->abs($u1);
   $u4 = $u3->clone;
   $u5 = URI->new("HTTP://WWW.perl.com:80")->canonical;
  
   $str = $u->as_string;
   $str = "$u";
  
   $scheme = $u->scheme;
   $opaque = $u->opaque;
   $path   = $u->path;
   $frag   = $u->fragment;
  
   $u->scheme("ftp");
   $u->host("ftp.perl.com");
   $u->path("cpan/");
  
  =head1 DESCRIPTION
  
  This module implements the C<URI> class.  Objects of this class
  represent "Uniform Resource Identifier references" as specified in RFC
  2396 (and updated by RFC 2732).
  
  A Uniform Resource Identifier is a compact string of characters that
  identifies an abstract or physical resource.  A Uniform Resource
  Identifier can be further classified as either a Uniform Resource Locator
  (URL) or a Uniform Resource Name (URN).  The distinction between URL
  and URN does not matter to the C<URI> class interface. A
  "URI-reference" is a URI that may have additional information attached
  in the form of a fragment identifier.
  
  An absolute URI reference consists of three parts:  a I<scheme>, a
  I<scheme-specific part> and a I<fragment> identifier.  A subset of URI
  references share a common syntax for hierarchical namespaces.  For
  these, the scheme-specific part is further broken down into
  I<authority>, I<path> and I<query> components.  These URIs can also
  take the form of relative URI references, where the scheme (and
  usually also the authority) component is missing, but implied by the
  context of the URI reference.  The three forms of URI reference
  syntax are summarized as follows:
  
    <scheme>:<scheme-specific-part>#<fragment>
    <scheme>://<authority><path>?<query>#<fragment>
    <path>?<query>#<fragment>
  
  The components into which a URI reference can be divided depend on the
  I<scheme>.  The C<URI> class provides methods to get and set the
  individual components.  The methods available for a specific
  C<URI> object depend on the scheme.
  
  =head1 CONSTRUCTORS
  
  The following methods construct new C<URI> objects:
  
  =over 4
  
  =item $uri = URI->new( $str )
  
  =item $uri = URI->new( $str, $scheme )
  
  Constructs a new URI object.  The string
  representation of a URI is given as argument, together with an optional
  scheme specification.  Common URI wrappers like "" and <>, as well as
  leading and trailing white space, are automatically removed from
  the $str argument before it is processed further.
  
  The constructor determines the scheme, maps this to an appropriate
  URI subclass, constructs a new object of that class and returns it.
  
  The $scheme argument is only used when $str is a
  relative URI.  It can be either a simple string that
  denotes the scheme, a string containing an absolute URI reference, or
  an absolute C<URI> object.  If no $scheme is specified for a relative
  URI $str, then $str is simply treated as a generic URI (no scheme-specific
  methods available).
  
  The set of characters available for building URI references is
  restricted (see L<URI::Escape>).  Characters outside this set are
  automatically escaped by the URI constructor.
  
  =item $uri = URI->new_abs( $str, $base_uri )
  
  Constructs a new absolute URI object.  The $str argument can
  denote a relative or absolute URI.  If relative, then it is
  absolutized using $base_uri as base. The $base_uri must be an absolute
  URI.
  
  =item $uri = URI::file->new( $filename )
  
  =item $uri = URI::file->new( $filename, $os )
  
  Constructs a new I<file> URI from a file name.  See L<URI::file>.
  
  =item $uri = URI::file->new_abs( $filename )
  
  =item $uri = URI::file->new_abs( $filename, $os )
  
  Constructs a new absolute I<file> URI from a file name.  See
  L<URI::file>.
  
  =item $uri = URI::file->cwd
  
  Returns the current working directory as a I<file> URI.  See
  L<URI::file>.
  
  =item $uri->clone
  
  Returns a copy of the $uri.
  
  =back
  
  =head1 COMMON METHODS
  
  The methods described in this section are available for all C<URI>
  objects.
  
  Methods that give access to components of a URI always return the
  old value of the component.  The value returned is C<undef> if the
  component was not present.  There is generally a difference between a
  component that is empty (represented as C<"">) and a component that is
  missing (represented as C<undef>).  If an accessor method is given an
  argument, it updates the corresponding component in addition to
  returning the old value of the component.  Passing an undefined
  argument removes the component (if possible).  The description of
  each accessor method indicates whether the component is passed as
  an escaped (percent-encoded) or an unescaped string.  A component that can be further
  divided into sub-parts are usually passed escaped, as unescaping might
  change its semantics.
  
  The common methods available for all URI are:
  
  =over 4
  
  =item $uri->scheme
  
  =item $uri->scheme( $new_scheme )
  
  Sets and returns the scheme part of the $uri.  If the $uri is
  relative, then $uri->scheme returns C<undef>.  If called with an
  argument, it updates the scheme of $uri, possibly changing the
  class of $uri, and returns the old scheme value.  The method croaks
  if the new scheme name is illegal; a scheme name must begin with a
  letter and must consist of only US-ASCII letters, numbers, and a few
  special marks: ".", "+", "-".  This restriction effectively means
  that the scheme must be passed unescaped.  Passing an undefined
  argument to the scheme method makes the URI relative (if possible).
  
  Letter case does not matter for scheme names.  The string
  returned by $uri->scheme is always lowercase.  If you want the scheme
  just as it was written in the URI in its original case,
  you can use the $uri->_scheme method instead.
  
  =item $uri->opaque
  
  =item $uri->opaque( $new_opaque )
  
  Sets and returns the scheme-specific part of the $uri
  (everything between the scheme and the fragment)
  as an escaped string.
  
  =item $uri->path
  
  =item $uri->path( $new_path )
  
  Sets and returns the same value as $uri->opaque unless the URI
  supports the generic syntax for hierarchical namespaces.
  In that case the generic method is overridden to set and return
  the part of the URI between the I<host name> and the I<fragment>.
  
  =item $uri->fragment
  
  =item $uri->fragment( $new_frag )
  
  Returns the fragment identifier of a URI reference
  as an escaped string.
  
  =item $uri->as_string
  
  Returns a URI object to a plain ASCII string.  URI objects are
  also converted to plain strings automatically by overloading.  This
  means that $uri objects can be used as plain strings in most Perl
  constructs.
  
  =item $uri->as_iri
  
  Returns a Unicode string representing the URI.  Escaped UTF-8 sequences
  representing non-ASCII characters are turned into their corresponding Unicode
  code point.
  
  =item $uri->canonical
  
  Returns a normalized version of the URI.  The rules
  for normalization are scheme-dependent.  They usually involve
  lowercasing the scheme and Internet host name components,
  removing the explicit port specification if it matches the default port,
  uppercasing all escape sequences, and unescaping octets that can be
  better represented as plain characters.
  
  For efficiency reasons, if the $uri is already in normalized form,
  then a reference to it is returned instead of a copy.
  
  =item $uri->eq( $other_uri )
  
  =item URI::eq( $first_uri, $other_uri )
  
  Tests whether two URI references are equal.  URI references
  that normalize to the same string are considered equal.  The method
  can also be used as a plain function which can also test two string
  arguments.
  
  If you need to test whether two C<URI> object references denote the
  same object, use the '==' operator.
  
  =item $uri->abs( $base_uri )
  
  Returns an absolute URI reference.  If $uri is already
  absolute, then a reference to it is simply returned.  If the $uri
  is relative, then a new absolute URI is constructed by combining the
  $uri and the $base_uri, and returned.
  
  =item $uri->rel( $base_uri )
  
  Returns a relative URI reference if it is possible to
  make one that denotes the same resource relative to $base_uri.
  If not, then $uri is simply returned.
  
  =item $uri->secure
  
  Returns a TRUE value if the URI is considered to point to a resource on
  a secure channel, such as an SSL or TLS encrypted one.
  
  =back
  
  =head1 GENERIC METHODS
  
  The following methods are available to schemes that use the
  common/generic syntax for hierarchical namespaces.  The descriptions of
  schemes below indicate which these are.  Unknown schemes are
  assumed to support the generic syntax, and therefore the following
  methods:
  
  =over 4
  
  =item $uri->authority
  
  =item $uri->authority( $new_authority )
  
  Sets and returns the escaped authority component
  of the $uri.
  
  =item $uri->path
  
  =item $uri->path( $new_path )
  
  Sets and returns the escaped path component of
  the $uri (the part between the host name and the query or fragment).
  The path can never be undefined, but it can be the empty string.
  
  =item $uri->path_query
  
  =item $uri->path_query( $new_path_query )
  
  Sets and returns the escaped path and query
  components as a single entity.  The path and the query are
  separated by a "?" character, but the query can itself contain "?".
  
  =item $uri->path_segments
  
  =item $uri->path_segments( $segment, ... )
  
  Sets and returns the path.  In a scalar context, it returns
  the same value as $uri->path.  In a list context, it returns the
  unescaped path segments that make up the path.  Path segments that
  have parameters are returned as an anonymous array.  The first element
  is the unescaped path segment proper;  subsequent elements are escaped
  parameter strings.  Such an anonymous array uses overloading so it can
  be treated as a string too, but this string does not include the
  parameters.
  
  Note that absolute paths have the empty string as their first
  I<path_segment>, i.e. the I<path> C</foo/bar> have 3
  I<path_segments>; "", "foo" and "bar".
  
  =item $uri->query
  
  =item $uri->query( $new_query )
  
  Sets and returns the escaped query component of
  the $uri.
  
  =item $uri->query_form
  
  =item $uri->query_form( $key1 => $val1, $key2 => $val2, ... )
  
  =item $uri->query_form( $key1 => $val1, $key2 => $val2, ..., $delim )
  
  =item $uri->query_form( \@key_value_pairs )
  
  =item $uri->query_form( \@key_value_pairs, $delim )
  
  =item $uri->query_form( \%hash )
  
  =item $uri->query_form( \%hash, $delim )
  
  Sets and returns query components that use the
  I<application/x-www-form-urlencoded> format.  Key/value pairs are
  separated by "&", and the key is separated from the value by a "="
  character.
  
  The form can be set either by passing separate key/value pairs, or via
  an array or hash reference.  Passing an empty array or an empty hash
  removes the query component, whereas passing no arguments at all leaves
  the component unchanged.  The order of keys is undefined if a hash
  reference is passed.  The old value is always returned as a list of
  separate key/value pairs.  Assigning this list to a hash is unwise as
  the keys returned might repeat.
  
  The values passed when setting the form can be plain strings or
  references to arrays of strings.  Passing an array of values has the
  same effect as passing the key repeatedly with one value at a time.
  All the following statements have the same effect:
  
      $uri->query_form(foo => 1, foo => 2);
      $uri->query_form(foo => [1, 2]);
      $uri->query_form([ foo => 1, foo => 2 ]);
      $uri->query_form([ foo => [1, 2] ]);
      $uri->query_form({ foo => [1, 2] });
  
  The $delim parameter can be passed as ";" to force the key/value pairs
  to be delimited by ";" instead of "&" in the query string.  This
  practice is often recommended for URLs embedded in HTML or XML
  documents as this avoids the trouble of escaping the "&" character.
  You might also set the $URI::DEFAULT_QUERY_FORM_DELIMITER variable to
  ";" for the same global effect.
  
  The C<URI::QueryParam> module can be loaded to add further methods to
  manipulate the form of a URI.  See L<URI::QueryParam> for details.
  
  =item $uri->query_keywords
  
  =item $uri->query_keywords( $keywords, ... )
  
  =item $uri->query_keywords( \@keywords )
  
  Sets and returns query components that use the
  keywords separated by "+" format.
  
  The keywords can be set either by passing separate keywords directly
  or by passing a reference to an array of keywords.  Passing an empty
  array removes the query component, whereas passing no arguments at
  all leaves the component unchanged.  The old value is always returned
  as a list of separate words.
  
  =back
  
  =head1 SERVER METHODS
  
  For schemes where the I<authority> component denotes an Internet host,
  the following methods are available in addition to the generic
  methods.
  
  =over 4
  
  =item $uri->userinfo
  
  =item $uri->userinfo( $new_userinfo )
  
  Sets and returns the escaped userinfo part of the
  authority component.
  
  For some schemes this is a user name and a password separated by
  a colon.  This practice is not recommended. Embedding passwords in
  clear text (such as URI) has proven to be a security risk in almost
  every case where it has been used.
  
  =item $uri->host
  
  =item $uri->host( $new_host )
  
  Sets and returns the unescaped hostname.
  
  If the $new_host string ends with a colon and a number, then this
  number also sets the port.
  
  For IPv6 addresses the brackets around the raw address is removed in the return
  value from $uri->host.  When setting the host attribute to an IPv6 address you
  can use a raw address or one enclosed in brackets.  The address needs to be
  enclosed in brackets if you want to pass in a new port value as well.
  
  =item $uri->ihost
  
  Returns the host in Unicode form.  Any IDNA A-labels are turned into U-labels.
  
  =item $uri->port
  
  =item $uri->port( $new_port )
  
  Sets and returns the port.  The port is a simple integer
  that should be greater than 0.
  
  If a port is not specified explicitly in the URI, then the URI scheme's default port
  is returned. If you don't want the default port
  substituted, then you can use the $uri->_port method instead.
  
  =item $uri->host_port
  
  =item $uri->host_port( $new_host_port )
  
  Sets and returns the host and port as a single
  unit.  The returned value includes a port, even if it matches the
  default port.  The host part and the port part are separated by a
  colon: ":".
  
  For IPv6 addresses the bracketing is preserved; thus
  URI->new("http://[::1]/")->host_port returns "[::1]:80".  Contrast this with
  $uri->host which will remove the brackets.
  
  =item $uri->default_port
  
  Returns the default port of the URI scheme to which $uri
  belongs.  For I<http> this is the number 80, for I<ftp> this
  is the number 21, etc.  The default port for a scheme can not be
  changed.
  
  =back
  
  =head1 SCHEME-SPECIFIC SUPPORT
  
  Scheme-specific support is provided for the following URI schemes.  For C<URI>
  objects that do not belong to one of these, you can only use the common and
  generic methods.
  
  =over 4
  
  =item B<data>:
  
  The I<data> URI scheme is specified in RFC 2397.  It allows inclusion
  of small data items as "immediate" data, as if it had been included
  externally.
  
  C<URI> objects belonging to the data scheme support the common methods
  and two new methods to access their scheme-specific components:
  $uri->media_type and $uri->data.  See L<URI::data> for details.
  
  =item B<file>:
  
  An old specification of the I<file> URI scheme is found in RFC 1738.
  A new RFC 2396 based specification in not available yet, but file URI
  references are in common use.
  
  C<URI> objects belonging to the file scheme support the common and
  generic methods.  In addition, they provide two methods for mapping file URIs
  back to local file names; $uri->file and $uri->dir.  See L<URI::file>
  for details.
  
  =item B<ftp>:
  
  An old specification of the I<ftp> URI scheme is found in RFC 1738.  A
  new RFC 2396 based specification in not available yet, but ftp URI
  references are in common use.
  
  C<URI> objects belonging to the ftp scheme support the common,
  generic and server methods.  In addition, they provide two methods for
  accessing the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<gopher>:
  
  The I<gopher> URI scheme is specified in
  <draft-murali-url-gopher-1996-12-04> and will hopefully be available
  as a RFC 2396 based specification.
  
  C<URI> objects belonging to the gopher scheme support the common,
  generic and server methods. In addition, they support some methods for
  accessing gopher-specific path components: $uri->gopher_type,
  $uri->selector, $uri->search, $uri->string.
  
  =item B<http>:
  
  The I<http> URI scheme is specified in RFC 2616.
  The scheme is used to reference resources hosted by HTTP servers.
  
  C<URI> objects belonging to the http scheme support the common,
  generic and server methods.
  
  =item B<https>:
  
  The I<https> URI scheme is a Netscape invention which is commonly
  implemented.  The scheme is used to reference HTTP servers through SSL
  connections.  Its syntax is the same as http, but the default
  port is different.
  
  =item B<ldap>:
  
  The I<ldap> URI scheme is specified in RFC 2255.  LDAP is the
  Lightweight Directory Access Protocol.  An ldap URI describes an LDAP
  search operation to perform to retrieve information from an LDAP
  directory.
  
  C<URI> objects belonging to the ldap scheme support the common,
  generic and server methods as well as ldap-specific methods: $uri->dn,
  $uri->attributes, $uri->scope, $uri->filter, $uri->extensions.  See
  L<URI::ldap> for details.
  
  =item B<ldapi>:
  
  Like the I<ldap> URI scheme, but uses a UNIX domain socket.  The
  server methods are not supported, and the local socket path is
  available as $uri->un_path.  The I<ldapi> scheme is used by the
  OpenLDAP package.  There is no real specification for it, but it is
  mentioned in various OpenLDAP manual pages.
  
  =item B<ldaps>:
  
  Like the I<ldap> URI scheme, but uses an SSL connection.  This
  scheme is deprecated, as the preferred way is to use the I<start_tls>
  mechanism.
  
  =item B<mailto>:
  
  The I<mailto> URI scheme is specified in RFC 2368.  The scheme was
  originally used to designate the Internet mailing address of an
  individual or service.  It has (in RFC 2368) been extended to allow
  setting of other mail header fields and the message body.
  
  C<URI> objects belonging to the mailto scheme support the common
  methods and the generic query methods.  In addition, they support the
  following mailto-specific methods: $uri->to, $uri->headers.
  
  Note that the "foo@example.com" part of a mailto is I<not> the
  C<userinfo> and C<host> but instead the C<path>.  This allows a
  mailto URI to contain multiple comma separated email addresses.
  
  =item B<mms>:
  
  The I<mms> URL specification can be found at L<http://sdp.ppona.com/>.
  C<URI> objects belonging to the mms scheme support the common,
  generic, and server methods, with the exception of userinfo and
  query-related sub-components.
  
  =item B<news>:
  
  The I<news>, I<nntp> and I<snews> URI schemes are specified in
  <draft-gilman-news-url-01> and will hopefully be available as an RFC
  2396 based specification soon.
  
  C<URI> objects belonging to the news scheme support the common,
  generic and server methods.  In addition, they provide some methods to
  access the path: $uri->group and $uri->message.
  
  =item B<nntp>:
  
  See I<news> scheme.
  
  =item B<pop>:
  
  The I<pop> URI scheme is specified in RFC 2384. The scheme is used to
  reference a POP3 mailbox.
  
  C<URI> objects belonging to the pop scheme support the common, generic
  and server methods.  In addition, they provide two methods to access the
  userinfo components: $uri->user and $uri->auth
  
  =item B<rlogin>:
  
  An old specification of the I<rlogin> URI scheme is found in RFC
  1738. C<URI> objects belonging to the rlogin scheme support the
  common, generic and server methods.
  
  =item B<rtsp>:
  
  The I<rtsp> URL specification can be found in section 3.2 of RFC 2326.
  C<URI> objects belonging to the rtsp scheme support the common,
  generic, and server methods, with the exception of userinfo and
  query-related sub-components.
  
  =item B<rtspu>:
  
  The I<rtspu> URI scheme is used to talk to RTSP servers over UDP
  instead of TCP.  The syntax is the same as rtsp.
  
  =item B<rsync>:
  
  Information about rsync is available from L<http://rsync.samba.org/>.
  C<URI> objects belonging to the rsync scheme support the common,
  generic and server methods.  In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<sip>:
  
  The I<sip> URI specification is described in sections 19.1 and 25
  of RFC 3261.  C<URI> objects belonging to the sip scheme support the
  common, generic, and server methods with the exception of path related
  sub-components.  In addition, they provide two methods to get and set
  I<sip> parameters: $uri->params_form and $uri->params.
  
  =item B<sips>:
  
  See I<sip> scheme.  Its syntax is the same as sip, but the default
  port is different.
  
  =item B<snews>:
  
  See I<news> scheme.  Its syntax is the same as news, but the default
  port is different.
  
  =item B<telnet>:
  
  An old specification of the I<telnet> URI scheme is found in RFC
  1738. C<URI> objects belonging to the telnet scheme support the
  common, generic and server methods.
  
  =item B<tn3270>:
  
  These URIs are used like I<telnet> URIs but for connections to IBM
  mainframes.  C<URI> objects belonging to the tn3270 scheme support the
  common, generic and server methods.
  
  =item B<ssh>:
  
  Information about ssh is available at L<http://www.openssh.com/>.
  C<URI> objects belonging to the ssh scheme support the common,
  generic and server methods. In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<urn>:
  
  The syntax of Uniform Resource Names is specified in RFC 2141.  C<URI>
  objects belonging to the urn scheme provide the common methods, and also the
  methods $uri->nid and $uri->nss, which return the Namespace Identifier
  and the Namespace-Specific String respectively.
  
  The Namespace Identifier basically works like the Scheme identifier of
  URIs, and further divides the URN namespace.  Namespace Identifier
  assignments are maintained at
  L<http://www.iana.org/assignments/urn-namespaces>.
  
  Letter case is not significant for the Namespace Identifier.  It is
  always returned in lower case by the $uri->nid method.  The $uri->_nid
  method can be used if you want it in its original case.
  
  =item B<urn>:B<isbn>:
  
  The C<urn:isbn:> namespace contains International Standard Book
  Numbers (ISBNs) and is described in RFC 3187.  A C<URI> object belonging
  to this namespace has the following extra methods (if the
  Business::ISBN module is available): $uri->isbn,
  $uri->isbn_publisher_code, $uri->isbn_group_code (formerly isbn_country_code,
  which is still supported by issues a deprecation warning), $uri->isbn_as_ean.
  
  =item B<urn>:B<oid>:
  
  The C<urn:oid:> namespace contains Object Identifiers (OIDs) and is
  described in RFC 3061.  An object identifier consists of sequences of digits
  separated by dots.  A C<URI> object belonging to this namespace has an
  additional method called $uri->oid that can be used to get/set the oid
  value.  In a list context, oid numbers are returned as separate elements.
  
  =back
  
  =head1 CONFIGURATION VARIABLES
  
  The following configuration variables influence how the class and its
  methods behave:
  
  =over 4
  
  =item $URI::ABS_ALLOW_RELATIVE_SCHEME
  
  Some older parsers used to allow the scheme name to be present in the
  relative URL if it was the same as the base URL scheme.  RFC 2396 says
  that this should be avoided, but you can enable this old behaviour by
  setting the $URI::ABS_ALLOW_RELATIVE_SCHEME variable to a TRUE value.
  The difference is demonstrated by the following examples:
  
    URI->new("http:foo")->abs("http://host/a/b")
        ==>  "http:foo"
  
    local $URI::ABS_ALLOW_RELATIVE_SCHEME = 1;
    URI->new("http:foo")->abs("http://host/a/b")
        ==>  "http:/host/a/foo"
  
  
  =item $URI::ABS_REMOTE_LEADING_DOTS
  
  You can also have the abs() method ignore excess ".."
  segments in the relative URI by setting $URI::ABS_REMOTE_LEADING_DOTS
  to a TRUE value.  The difference is demonstrated by the following
  examples:
  
    URI->new("../../../foo")->abs("http://host/a/b")
        ==> "http://host/../../foo"
  
    local $URI::ABS_REMOTE_LEADING_DOTS = 1;
    URI->new("../../../foo")->abs("http://host/a/b")
        ==> "http://host/foo"
  
  =item $URI::DEFAULT_QUERY_FORM_DELIMITER
  
  This value can be set to ";" to have the query form C<key=value> pairs
  delimited by ";" instead of "&" which is the default.
  
  =back
  
  =head1 BUGS
  
  There are some things that are not quite right:
  
  =over
  
  =item *
  
  Using regexp variables like $1 directly as arguments to the URI accessor methods
  does not work too well with current perl implementations.  I would argue
  that this is actually a bug in perl.  The workaround is to quote
  them. Example:
  
     /(...)/ || die;
     $u->query("$1");
  
  
  =item *
  
  The escaping (percent encoding) of chars in the 128 .. 255 range passed to the
  URI constructor or when setting URI parts using the accessor methods depend on
  the state of the internal UTF8 flag (see utf8::is_utf8) of the string passed.
  If the UTF8 flag is set the UTF-8 encoded version of the character is percent
  encoded.  If the UTF8 flag isn't set the Latin-1 version (byte) of the
  character is percent encoded.  This basically exposes the internal encoding of
  Perl strings.
  
  =back
  
  =head1 PARSING URIs WITH REGEXP
  
  As an alternative to this module, the following (official) regular
  expression can be used to decode a URI:
  
    my($scheme, $authority, $path, $query, $fragment) =
    $uri =~ m|(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?|;
  
  The C<URI::Split> module provides the function uri_split() as a
  readable alternative.
  
  =head1 SEE ALSO
  
  L<URI::file>, L<URI::WithBase>, L<URI::QueryParam>, L<URI::Escape>,
  L<URI::Split>, L<URI::Heuristic>
  
  RFC 2396: "Uniform Resource Identifiers (URI): Generic Syntax",
  Berners-Lee, Fielding, Masinter, August 1998.
  
  L<http://www.iana.org/assignments/uri-schemes>
  
  L<http://www.iana.org/assignments/urn-namespaces>
  
  L<http://www.w3.org/Addressing/>
  
  =head1 COPYRIGHT
  
  Copyright 1995-2009 Gisle Aas.
  
  Copyright 1995 Martijn Koster.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHORS / ACKNOWLEDGMENTS
  
  This module is based on the C<URI::URL> module, which in turn was
  (distantly) based on the C<wwwurl.pl> code in the libwww-perl for
  perl4 developed by Roy Fielding, as part of the Arcadia project at the
  University of California, Irvine, with contributions from Brooks
  Cutter.
  
  C<URI::URL> was developed by Gisle Aas, Tim Bunce, Roy Fielding and
  Martijn Koster with input from other people on the libwww-perl mailing
  list.
  
  C<URI> and related subclasses was developed by Gisle Aas.
  
  =cut
URI

$fatpacked{"URI/Escape.pm"} = <<'URI_ESCAPE';
  package URI::Escape;
  use strict;
  
  =head1 NAME
  
  URI::Escape - Percent-encode and percent-decode unsafe characters
  
  =head1 SYNOPSIS
  
   use URI::Escape;
   $safe = uri_escape("10% is enough\n");
   $verysafe = uri_escape("foo", "\0-\377");
   $str  = uri_unescape($safe);
  
  =head1 DESCRIPTION
  
  This module provides functions to percent-encode and percent-decode URI strings as
  defined by RFC 3986. Percent-encoding URI's is informally called "URI escaping".
  This is the terminology used by this module, which predates the formalization of the
  terms by the RFC by several years.
  
  A URI consists of a restricted set of characters.  The restricted set
  of characters consists of digits, letters, and a few graphic symbols
  chosen from those common to most of the character encodings and input
  facilities available to Internet users.  They are made up of the
  "unreserved" and "reserved" character sets as defined in RFC 3986.
  
     unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
     reserved      = ":" / "/" / "?" / "#" / "[" / "]" / "@"
                     "!" / "$" / "&" / "'" / "(" / ")"
                   / "*" / "+" / "," / ";" / "="
  
  In addition, any byte (octet) can be represented in a URI by an escape
  sequence: a triplet consisting of the character "%" followed by two
  hexadecimal digits.  A byte can also be represented directly by a
  character, using the US-ASCII character for that octet.
  
  Some of the characters are I<reserved> for use as delimiters or as
  part of certain URI components.  These must be escaped if they are to
  be treated as ordinary data.  Read RFC 3986 for further details.
  
  The functions provided (and exported by default) from this module are:
  
  =over 4
  
  =item uri_escape( $string )
  
  =item uri_escape( $string, $unsafe )
  
  Replaces each unsafe character in the $string with the corresponding
  escape sequence and returns the result.  The $string argument should
  be a string of bytes.  The uri_escape() function will croak if given a
  characters with code above 255.  Use uri_escape_utf8() if you know you
  have such chars or/and want chars in the 128 .. 255 range treated as
  UTF-8.
  
  The uri_escape() function takes an optional second argument that
  overrides the set of characters that are to be escaped.  The set is
  specified as a string that can be used in a regular expression
  character class (between [ ]).  E.g.:
  
    "\x00-\x1f\x7f-\xff"          # all control and hi-bit characters
    "a-z"                         # all lower case characters
    "^A-Za-z"                     # everything not a letter
  
  The default set of characters to be escaped is all those which are
  I<not> part of the C<unreserved> character class shown above as well
  as the reserved characters.  I.e. the default is:
  
      "^A-Za-z0-9\-\._~"
  
  =item uri_escape_utf8( $string )
  
  =item uri_escape_utf8( $string, $unsafe )
  
  Works like uri_escape(), but will encode chars as UTF-8 before
  escaping them.  This makes this function able to deal with characters
  with code above 255 in $string.  Note that chars in the 128 .. 255
  range will be escaped differently by this function compared to what
  uri_escape() would.  For chars in the 0 .. 127 range there is no
  difference.
  
  Equivalent to:
  
      utf8::encode($string);
      my $uri = uri_escape($string);
  
  Note: JavaScript has a function called escape() that produces the
  sequence "%uXXXX" for chars in the 256 .. 65535 range.  This function
  has really nothing to do with URI escaping but some folks got confused
  since it "does the right thing" in the 0 .. 255 range.  Because of
  this you sometimes see "URIs" with these kind of escapes.  The
  JavaScript encodeURIComponent() function is similar to uri_escape_utf8().
  
  =item uri_unescape($string,...)
  
  Returns a string with each %XX sequence replaced with the actual byte
  (octet).
  
  This does the same as:
  
     $string =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
  
  but does not modify the string in-place as this RE would.  Using the
  uri_unescape() function instead of the RE might make the code look
  cleaner and is a few characters less to type.
  
  In a simple benchmark test I did,
  calling the function (instead of the inline RE above) if a few chars
  were unescaped was something like 40% slower, and something like 700% slower if none were.  If
  you are going to unescape a lot of times it might be a good idea to
  inline the RE.
  
  If the uri_unescape() function is passed multiple strings, then each
  one is returned unescaped.
  
  =back
  
  The module can also export the C<%escapes> hash, which contains the
  mapping from all 256 bytes to the corresponding escape codes.  Lookup
  in this hash is faster than evaluating C<sprintf("%%%02X", ord($byte))>
  each time.
  
  =head1 SEE ALSO
  
  L<URI>
  
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  require Exporter;
  our @ISA = qw(Exporter);
  our %escapes;
  our @EXPORT = qw(uri_escape uri_unescape uri_escape_utf8);
  our @EXPORT_OK = qw(%escapes);
  our $VERSION = "3.31";
  
  use Carp ();
  
  # Build a char->hex map
  for (0..255) {
      $escapes{chr($_)} = sprintf("%%%02X", $_);
  }
  
  my %subst;  # compiled patterns
  
  my %Unsafe = (
      RFC2732 => qr/[^A-Za-z0-9\-_.!~*'()]/,
      RFC3986 => qr/[^A-Za-z0-9\-\._~]/,
  );
  
  sub uri_escape {
      my($text, $patn) = @_;
      return undef unless defined $text;
      if (defined $patn){
          unless (exists  $subst{$patn}) {
              # Because we can't compile the regex we fake it with a cached sub
              (my $tmp = $patn) =~ s,/,\\/,g;
              eval "\$subst{\$patn} = sub {\$_[0] =~ s/([$tmp])/\$escapes{\$1} || _fail_hi(\$1)/ge; }";
              Carp::croak("uri_escape: $@") if $@;
          }
          &{$subst{$patn}}($text);
      } else {
          $text =~ s/($Unsafe{RFC3986})/$escapes{$1} || _fail_hi($1)/ge;
      }
      $text;
  }
  
  sub _fail_hi {
      my $chr = shift;
      Carp::croak(sprintf "Can't escape \\x{%04X}, try uri_escape_utf8() instead", ord($chr));
  }
  
  sub uri_escape_utf8 {
      my $text = shift;
      utf8::encode($text);
      return uri_escape($text, @_);
  }
  
  sub uri_unescape {
      # Note from RFC1630:  "Sequences which start with a percent sign
      # but are not followed by two hexadecimal characters are reserved
      # for future extension"
      my $str = shift;
      if (@_ && wantarray) {
          # not executed for the common case of a single argument
          my @str = ($str, @_);  # need to copy
          for (@str) {
              s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
          }
          return @str;
      }
      $str =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg if defined $str;
      $str;
  }
  
  sub escape_char {
      return join '', @URI::Escape::escapes{$_[0] =~ /(\C)/g};
  }
  
  1;
URI_ESCAPE

$fatpacked{"URI/Find.pm"} = <<'URI_FIND';
  # Copyright (c) 2000, 2009 Michael G. Schwern.  All rights reserved.
  # This program is free software; you can redistribute it and/or modify
  # it under the same terms as Perl itself.
  
  package URI::Find;
  
  require 5.006;
  
  use strict;
  use base qw(Exporter);
  use vars qw($VERSION @EXPORT);
  
  $VERSION        = 20111103;
  @EXPORT         = qw(find_uris);
  
  use constant YES => (1==1);
  use constant NO  => !YES;
  
  use Carp        qw(croak);
  use URI::URL;
  
  require URI;
  
  # URI scheme pattern without the non-alpha numerics.
  # Those are extremely uncommon and interfere with the match.
  my($schemeRe) = qr/[a-zA-Z][a-zA-Z0-9]*/;
  my($uricSet)  = $URI::uric;
  
  # We need to avoid picking up 'HTTP::Request::Common' so we have a
  # subset of uric without a colon ("I have no colon and yet I must poop")
  my($uricCheat) = __PACKAGE__->uric_set;
  $uricCheat =~ tr/://d;
  
  # Identifying characters accidentally picked up with a URI.
  my($cruftSet) = q{]),.'";}; #'#
  
  
  =head1 NAME
  
  URI::Find - Find URIs in arbitrary text
  
  =head1 SYNOPSIS
  
    require URI::Find;
  
    my $finder = URI::Find->new(\&callback);
  
    $how_many_found = $finder->find(\$text);
  
  =head1 DESCRIPTION
  
  This module does one thing: Finds URIs and URLs in plain text.  It finds
  them quickly and it finds them B<all> (or what URI::URL considers a URI
  to be.)  It only finds URIs which include a scheme (http:// or the
  like), for something a bit less strict have a look at
  L<URI::Find::Schemeless|URI::Find::Schemeless>.
  
  For a command-line interface, L<urifind> is provided.
  
  =head2 Public Methods
  
  =over 4
  
  =item B<new>
  
    my $finder = URI::Find->new(\&callback);
  
  Creates a new URI::Find object.
  
  &callback is a function which is called on each URI found.  It is
  passed two arguments, the first is a URI::URL object representing the
  URI found.  The second is the original text of the URI found.  The
  return value of the callback will replace the original URI in the
  text.
  
  =cut
  
  sub new {
      @_ == 2 || __PACKAGE__->badinvo;
      my($proto, $callback) = @_;
      my($class) = ref $proto || $proto;
      my $self = bless {}, $class;
  
      $self->{callback} = $callback;
  
      return $self;
  }
  
  =item B<find>
  
    my $how_many_found = $finder->find(\$text);
  
  $text is a string to search and possibly modify with your callback.
  
  Alternatively, C<find> can be called with a replacement function for
  the rest of the text:
  
    use CGI qw(escapeHTML);
    # ...
    my $how_many_found = $finder->find(\$text, \&escapeHTML);
  
  will not only call the callback function for every URL found (and
  perform the replacement instructions therein), but also run the rest
  of the text through C<escapeHTML()>. This makes it easier to turn
  plain text which contains URLs into HTML (see example below).
  
  =cut
  
  sub find {
      @_ == 2 || @_ == 3 || __PACKAGE__->badinvo;
      my($self, $r_text, $escape_func) = @_;
  
      # Might be slower, but it makes the code simpler
      $escape_func ||= sub { return $_[0] };
  
      # Store the escape func in the object temporarily for use
      # by other methods.
      local $self->{escape_func} = $escape_func;
  
      $self->{_uris_found} = 0;
  
      # Yes, evil.  Basically, look for something vaguely resembling a URL,
      # then hand it off to URI::URL for examination.  If it passes, throw
      # it to a callback and put the result in its place.
      local $SIG{__DIE__} = 'DEFAULT';
      my $uri_cand;
      my $uri;
  
      my $uriRe = sprintf '(?:%s|%s)', $self->uri_re, $self->schemeless_uri_re;
  
      $$r_text =~ s{ (.*?) (?:(<(?:URL:)?)(.+?)(>)|($uriRe)) | (.+?)$ }{
          my $replace = '';
          if( defined $6 ) {
              $replace = $escape_func->($6);
          }
          else {
              my $maybe_uri = '';
  
              $replace = $escape_func->($1) if length $1;
  
              if( defined $2 ) {
                  $maybe_uri = $3;
                  my $is_uri = do {  # Don't alter $1...
                      $maybe_uri =~ s/\s+//g;
                      $maybe_uri =~ /^$uriRe/;
                  };
  
                  if( $is_uri ) {
                      $replace .= $escape_func->($2);
                      $replace .= $self->_uri_filter($maybe_uri);
                      $replace .= $escape_func->($4);
                  }
                  else {
                      # the whole text inside of the <...> was not a url, but
                      # maybe it has a url (like an HTML <a> link)
                      my $has_uri = do { # Don't alter $1...
                          $maybe_uri = $3;
                          $maybe_uri =~ /$uriRe/;
                      };
                      if( $has_uri ) {
                          my $pre = $2;
                          my $post = $4;
                          do { $self->find(\$maybe_uri, $escape_func) };
                          $replace .= $escape_func->($pre);
                          $replace .= $maybe_uri;  # already escaped by find()
                          $replace .= $escape_func->($post);
                      }
                      else {
                          $replace .= $escape_func->($2.$3.$4);
                      }
                  }
              }
              else {
                  $replace .= $self->_uri_filter($5);
              }
          }
  
          $replace;
      }gsex;
  
      return $self->{_uris_found};
  }
  
  
  sub _uri_filter {
      my($self, $orig_match) = @_;
  
      # A heuristic.  Often you'll see things like:
      # "I saw this site, http://www.foo.com, and its really neat!"
      # or "Foo Industries (at http://www.foo.com)"
      # We want to avoid picking up the trailing paren, period or comma.
      # Of course, this might wreck a perfectly valid URI, more often than
      # not it corrects a parse mistake.
      $orig_match = $self->decruft($orig_match);
  
      my $replacement = '';
      if( my $uri = $self->_is_uri(\$orig_match) ) {
          # It's a URI
          $self->{_uris_found}++;
          $replacement = $self->{callback}->($uri, $orig_match);
      }
      else {
          # False alarm
          $replacement = $self->{escape_func}->($orig_match);
      }
  
      # Return recrufted replacement
      return $self->recruft($replacement);
  }
  
  
  =back
  
  =head2 Protected Methods
  
  I got a bunch of mail from people asking if I'd add certain features
  to URI::Find.  Most wanted the search to be less restrictive, do more
  heuristics, etc...  Since many of the requests were contradictory, I'm
  letting people create their own custom subclasses to do what they
  want.
  
  The following are methods internal to URI::Find which a subclass can
  override to change the way URI::Find acts.  They are only to be called
  B<inside> a URI::Find subclass.  Users of this module are NOT to use
  these methods.
  
  =over
  
  =item B<uri_re>
  
    my $uri_re = $self->uri_re;
  
  Returns the regex for finding absolute, schemed URIs
  (http://www.foo.com and such).  This, combined with
  schemeless_uri_re() is what finds candidate URIs.
  
  Usually this method does not have to be overridden.
  
  =cut
  
  sub uri_re {
      @_ == 1 || __PACKAGE__->badinvo;
      my($self) = shift;
      return sprintf '%s:[%s][%s#]*', $schemeRe,
                                      $uricCheat,
                                      $self->uric_set;
  }
  
  =item B<schemeless_uri_re>
  
    my $schemeless_re = $self->schemeless_uri_re;
  
  Returns the regex for finding schemeless URIs (www.foo.com and such) and
  other things which might be URIs.  By default this will match nothing
  (though it used to try to find schemeless URIs which started with C<www>
  and C<ftp>).
  
  Many people will want to override this method.  See L<URI::Find::Schemeless>
  for a subclass does a reasonable job of finding URIs which might be missing
  the scheme.
  
  =cut
  
  sub schemeless_uri_re {
      @_ == 1 || __PACKAGE__->badinvo;
      my($self) = shift;
      return qr/\b\B/; # match nothing
  }
  
  =item B<uric_set>
  
    my $uric_set = $self->uric_set;
  
  Returns a set matching the 'uric' set defined in RFC 2396 suitable for
  putting into a character set ([]) in a regex.
  
  You almost never have to override this.
  
  =cut
  
  sub uric_set {
      @_ == 1 || __PACKAGE__->badinvo;
      return $uricSet;
  }
  
  =item B<cruft_set>
  
    my $cruft_set = $self->cruft_set;
  
  Returns a set of characters which are considered garbage.  Used by
  decruft().
  
  =cut
  
  sub cruft_set {
      @_ == 1 || __PACKAGE__->badinvo;
      return $cruftSet;
  }
  
  =item B<decruft>
  
    my $uri = $self->decruft($uri);
  
  Sometimes garbage characters like periods and parenthesis get
  accidentally matched along with the URI.  In order for the URI to be
  properly identified, it must sometimes be "decrufted", the garbage
  characters stripped.
  
  This method takes a candidate URI and strips off any cruft it finds.
  
  =cut
  
  sub decruft {
      @_ == 2 || __PACKAGE__->badinvo;
      my($self, $orig_match) = @_;
  
      $self->{start_cruft} = '';
      $self->{end_cruft} = '';
  
      if( $orig_match =~ s/([\Q$cruftSet\E]+)$// ) {
          # urls can end with HTML entities if found in HTML so let's put back semicolons
          # if this looks like the case
          my $cruft = $1;
          if( $cruft =~ /^;/ && $orig_match =~ /\&(\#[1-9]\d{1,3}|[a-zA-Z]{2,8})$/) {
              $orig_match .= ';';
              $cruft =~ s/^;//;
          }
  
          my $opening = $orig_match =~ tr/(/(/;
          my $closing = $orig_match =~ tr/)/)/;
          if ( $cruft =~ /\)$/ && $opening == ( $closing + 1 ) ) {
              $orig_match .= ')';
              $cruft =~ s/\)$//;
          }
  
          $self->{end_cruft} = $cruft if $cruft;
      }
  
      return $orig_match;
  }
  
  =item B<recruft>
  
    my $uri = $self->recruft($uri);
  
  This method puts back the cruft taken off with decruft().  This is necessary
  because the cruft is destructively removed from the string before invoking
  the user's callback, so it has to be put back afterwards.
  
  =cut
  
  #'#
  
  sub recruft {
      @_ == 2 || __PACKAGE__->badinvo;
      my($self, $uri) = @_;
  
      return $self->{start_cruft} . $uri . $self->{end_cruft};
  }
  
  =item B<schemeless_to_schemed>
  
    my $schemed_uri = $self->schemeless_to_schemed($schemeless_uri);
  
  This takes a schemeless URI and returns an absolute, schemed URI.  The
  standard implementation supplies ftp:// for URIs which start with ftp.,
  and http:// otherwise.
  
  =cut
  
  sub schemeless_to_schemed {
      @_ == 2 || __PACKAGE__->badinvo;
      my($self, $uri_cand) = @_;
  
      $uri_cand =~ s|^(<?)ftp\.|$1ftp://ftp\.|
          or $uri_cand =~ s|^(<?)|${1}http://|;
  
      return $uri_cand;
  }
  
  =item B<is_schemed>
  
    $obj->is_schemed($uri);
  
  Returns whether or not the given URI is schemed or schemeless.  True for
  schemed, false for schemeless.
  
  =cut
  
  sub is_schemed {
      @_ == 2 || __PACKAGE__->badinvo;
      my($self, $uri) = @_;
      return scalar $uri =~ /^<?$schemeRe:/;
  }
  
  =item I<badinvo>
  
    __PACKAGE__->badinvo($extra_levels, $msg)
  
  This is used to complain about bogus subroutine/method invocations.
  The args are optional.
  
  =cut
  
  sub badinvo {
      my $package = shift;
      my $level   = @_ ? shift : 0;
      my $msg     = @_ ? " (" . shift() . ")" : '';
      my $subname = (caller $level + 1)[3];
      croak "Bogus invocation of $subname$msg";
  }
  
  =back
  
  =head2 Old Functions
  
  The old find_uri() function is still around and it works, but its
  deprecated.
  
  =cut
  
  # Old interface.
  sub find_uris (\$&) {
      @_ == 2 || __PACKAGE__->badinvo;
      my($r_text, $callback) = @_;
  
      my $self = __PACKAGE__->new($callback);
      return $self->find($r_text);
  }
  
  
  =head1 EXAMPLES
  
  Store a list of all URIs (normalized) in the document.
  
    my @uris;
    my $finder = URI::Find->new(sub {
        my($uri) = shift;
        push @uris, $uri;
    });
    $finder->find(\$text);
  
  Print the original URI text found and the normalized representation.
  
    my $finder = URI::Find->new(sub {
        my($uri, $orig_uri) = @_;
        print "The text '$orig_uri' represents '$uri'\n";
        return $orig_uri;
    });
    $finder->find(\$text);
  
  Check each URI in document to see if it exists.
  
    use LWP::Simple;
  
    my $finder = URI::Find->new(sub {
        my($uri, $orig_uri) = @_;
        if( head $uri ) {
            print "$orig_uri is okay\n";
        }
        else {
            print "$orig_uri cannot be found\n";
        }
        return $orig_uri;
    });
    $finder->find(\$text);
  
  
  Turn plain text into HTML, with each URI found wrapped in an HTML anchor.
  
    use CGI qw(escapeHTML);
    use URI::Find;
  
    my $finder = URI::Find->new(sub {
        my($uri, $orig_uri) = @_;
        return qq|<a href="$uri">$orig_uri</a>|;
    });
    $finder->find(\$text, \&escapeHTML);
    print "<pre>$text</pre>";
  
  =cut
  
  
  sub _is_uri {
      @_ == 2 || __PACKAGE__->badinvo;
      my($self, $r_uri_cand) = @_;
  
      my $uri = $$r_uri_cand;
  
      # Translate schemeless to schemed if necessary.
      $uri = $self->schemeless_to_schemed($uri) if
        $uri =~ $self->schemeless_uri_re   and
        $uri !~ /^<?$schemeRe:/;
  
      # Set strict to avoid bogus schemes
      my $old_strict = URI::URL::strict(1);
  
      eval {
          $uri = URI::URL->new($uri);
      };
  
      # And restore it
      URI::URL::strict($old_strict);
  
      if($@ || !defined $uri) {   # leave everything untouched, its not a URI.
          return NO;
      }
      else {                      # Its a URI.
          return $uri;
      }
  }
  
  
  =head1 NOTES
  
  Will not find URLs with Internationalized Domain Names or pretty much
  any non-ascii stuff in them.  See
  L<http://rt.cpan.org/Ticket/Display.html?id=44226>
  
  
  =head1 AUTHOR
  
  Michael G Schwern <schwern@pobox.com> with insight from Uri Gutman,
  Greg Bacon, Jeff Pinyan, Roderick Schertler and others.
  
  Roderick Schertler <roderick@argon.org> maintained versions 0.11 to 0.16.
  
  Darren Chamberlain wrote urifind.
  
  
  =head1 LICENSE
  
  Copyright 2000, 2009-2010 by Michael G Schwern E<lt>schwern@pobox.comE<gt>.
  
  This program is free software; you can redistribute it and/or 
  modify it under the same terms as Perl itself.
  
  See F<http://www.perlfoundation.org/artistic_license_1_0>
  
  =head1 SEE ALSO
  
  L<urifind>, L<URI::Find::Schemeless>, L<URI::URL>, L<URI>,
  RFC 3986 Appendix C
  
  =cut
  
  1;
URI_FIND

$fatpacked{"URI/Find/Schemeless.pm"} = <<'URI_FIND_SCHEMELESS';
  # Copyright (c) 2000, 2009 Michael G. Schwern.  All rights reserved.
  # This program is free software; you can redistribute it and/or modify
  # it under the same terms as Perl itself.
  
  package URI::Find::Schemeless;
  
  use strict;
  use base qw(URI::Find);
  
  # base.pm error in 5.005_03 prevents it from loading URI::Find if I'm
  # required first.
  use URI::Find ();
  
  use vars qw($VERSION);
  $VERSION = 20111103;
  
  my($dnsSet) = 'A-Za-z0-9-';
  
  my($cruftSet) = __PACKAGE__->cruft_set . '<>?}';
  
  my($tldRe) = __PACKAGE__->top_level_domain_re;
  
  my($uricSet) = __PACKAGE__->uric_set;
  
  =head1 NAME
  
  URI::Find::Schemeless - Find schemeless URIs in arbitrary text.
  
  
  =head1 SYNOPSIS
  
    require URI::Find::Schemeless;
  
    my $finder = URI::Find::Schemeless->new(\&callback);
  
    The rest is the same as URI::Find.
  
  
  =head1 DESCRIPTION
  
  URI::Find finds absolute URIs in plain text with some weak heuristics
  for finding schemeless URIs.  This subclass is for finding things
  which might be URIs in free text.  Things like "www.foo.com" and
  "lifes.a.bitch.if.you.aint.got.net".
  
  The heuristics are such that it hopefully finds a minimum of false
  positives, but there's no easy way for it know if "COMMAND.COM" refers
  to a web site or a file.
  
  =cut
  
  sub schemeless_uri_re {
      @_ == 1 || __PACKAGE__->badinvo;
      return qr{
                # Originally I constrained what couldn't be before the match
                # like this:  don't match email addresses, and don't start
                # anywhere but at the beginning of a host name
                #    (?<![\@.$dnsSet])
                # but I switched to saying what can be there after seeing a
                # false match of "Lite.pm" via "MIME/Lite.pm".
                (?: ^ | (?<=[\s<>()\{\}\[\]]) )
                # hostname
                (?: [$dnsSet]+(?:\.[$dnsSet]+)*\.$tldRe
                    | (?:\d{1,3}\.){3}\d{1,3} ) # not inet_aton() complete
                (?:
                    (?=[\s\Q$cruftSet\E]) # followed by unrelated thing
                    (?!\.\w)              #   but don't stop mid foo.xx.bar
                        (?<!\.p[ml])      #   but exclude Foo.pm and Foo.pl
                    |$                    # or end of line
                        (?<!\.p[ml])      #   but exclude Foo.pm and Foo.pl
                    |/[$uricSet#]*        # or slash and URI chars
                )
             }x;
  }
  
  =head3 top_level_domain_re
  
    my $tld_re = $self->top_level_domain_re;
  
  Returns the regex for matching top level DNS domains.  The regex shouldn't
  be anchored, it shouldn't do any capturing matches, and it should make
  itself ignore case.
  
  =cut
  
  sub top_level_domain_re {
      @_ == 1 || __PACKAGE__->badinvo;
      my($self) = shift;
  
      # Updated from http://www.iana.org/domains/root/db/
      my $plain = join '|', qw(
          AERO
          ARPA
          ASIA
          BIZ
          CAT
          COM
          COOP
          EDU
          GOV
          INFO
          INT
          JOBS
          MIL
          MOBI
          MUSEUM
          NAME
          NET
          ORG
          PRO
          TEL
          TRAVEL
      );
  
      return qr/(?:[a-z]{2}|$plain)/i;
  }
  
  =head1 AUTHOR
  
  Original code by Roderick Schertler <roderick@argon.org>, adapted by
  Michael G Schwern <schwern@pobox.com>.
  
  Currently maintained by Roderick Schertler <roderick@argon.org>.
  
  =head1 SEE ALSO
  
    L<URI::Find>
  
  =cut
  
  1;
URI_FIND_SCHEMELESS

$fatpacked{"URI/FromHash.pm"} = <<'URI_FROMHASH';
  package URI::FromHash;
  
  use strict;
  use warnings;
  
  use base 'Exporter';
  
  use vars qw( $VERSION @EXPORT_OK );
  
  $VERSION = '0.03';
  @EXPORT_OK = qw( uri uri_object );
  
  use Params::Validate qw( validate SCALAR ARRAYREF HASHREF );
  
  use URI;
  use URI::QueryParam;
  
  
  my %BaseParams =
      ( scheme   => { type => SCALAR, optional => 1 },
        username => { type => SCALAR, optional => 1 },
        password => { type => SCALAR, default  => '' },
        host     => { type => SCALAR, optional => 1 },
        port     => { type => SCALAR, optional => 1 },
        path     => { type => SCALAR | ARRAYREF, optional => 1 },
        query    => { type => HASHREF, default => {} },
        fragment => { type => SCALAR,  optional => 1 },
      );
  
  sub uri_object
  {
      my %p = validate( @_, \%BaseParams );
      _check_required(\%p);
  
      my $uri = URI->new();
  
      $uri->scheme( $p{scheme} )
          if grep { defined && length } $p{scheme};
  
      if ( grep { defined && length } $p{username}, $p{password} )
      {
          $p{username} ||= '';
          $p{password} ||= '';
          if ( $uri->can('user') && $uri->can('password') )
          {
              $uri->user( $p{username} );
              $uri->password( $p{password} );
          }
          else
          {
              $uri->userinfo( "$p{username}:$p{password}" );
          }
      }
  
      for my $k ( qw( host port ) )
      {
          $uri->$k( $p{$k} )
              if grep { defined && length } $p{$k};
      }
  
      if ( $p{path} )
      {
          if ( ref $p{path} )
          {
              $uri->path( join '/', grep { defined } @{ $p{path} } );
          }
          else
          {
              $uri->path( $p{path} );
          }
      }
  
      while ( my ( $k, $v ) = each %{ $p{query} } )
      {
          $uri->query_param( $k => $v );
      }
  
      $uri->fragment( $p{fragment} )
          if grep { defined && length } $p{fragment};
  
      return $uri;
  }
  
  sub uri
  {
      my %p = validate( @_,
                        { %BaseParams,
                          query_separator => { type => SCALAR, default => ';' },
                        },
                      );
      _check_required(\%p);
  
      my $sep = delete $p{query_separator};
      my $uri = uri_object(%p);
  
      if ( $sep ne '&' && $uri->query() )
      {
          my $query = $uri->query();
          $query =~ s/&/$sep/g;
          $uri->query($query);
      }
  
      # force stringification
      return $uri->canonical() . '';
  }
  
  sub _check_required
  {
      my $p = shift;
  
      return if
          ( grep { defined and length }
            map { $p->{$_} }
            qw( host fragment )
          );
  
      return if
          ref $p->{path}
          ? @{ $p->{path} }
          : defined $p->{path} && length $p->{path};
  
      return if keys %{ $p->{query} };
  
      require Carp;
      local $Carp::CarpLevel = 1;
      Carp::croak( 'None of the required parameters '
                   . '(host, path, fragment, or query) were given' );
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::FromHash - Build a URI from a set of named parameters
  
  =head1 SYNOPSIS
  
    use URI::FromHash qw( uri );
  
    my $uri = uri( path  => '/some/path',
                   query => { foo => 1, bar => 2 },
                 );
  
  =head1 DESCRIPTION
  
  This module provides a simple one-subroutine "named parameters" style
  interface for creating URIs. Underneath the hood it uses C<URI.pm>,
  though because of the simplified interface it may not support all
  possible options for all types of URIs.
  
  It was created for the common case where you simply want to have a
  simple interface for creating syntactically correct URIs from known
  components (like a path and query string). Doing this using the native
  C<URI.pm> interface is rather tedious, requiring a number of method
  calls, which is particularly ugly when done inside a templating system
  such as Mason or TT2.
  
  =head1 FUNCTIONS
  
  This module provides two functions both of which are I<optionally>
  exportable:
  
  =head2 uri( ... ) and uri_object( ... )
  
  Both of these functions accept the same set of parameters, except for
  one additional parameter allowed when calling C<uri()>.
  
  The C<uri()> function simply returns a string representing a
  canonicalized URI based on the provided parameters. The
  C<uri_object()> function returns new a C<URI.pm> object based on the
  given parameters.
  
  These parameters are:
  
  =over 4
  
  =item * scheme
  
  The URI's scheme. This is optional, and if none is given you will
  create a schemeless URI. This is useful if you want to create a URI to
  a path on the same server (as is commonly done in C<< <a> >> tags).
  
  =item * host
  
  =item * port
  
  =item * path
  
  The path can be either a string or an array reference.
  
  If an array reference is passed each I<defined> member of the array
  will be joined by a single forward slash (/).
  
  If you are building a host-less URI and want to include a leading
  slash then make the first element of the array reference an empty
  string (C<''>).
  
  You can add a trailing slash by making the last element of the array
  reference an empty string.
  
  =item * username
  
  =item * password
  
  =item * fragment
  
  All of these are optional strings which can be used to specify that
  part of the URI.
  
  =item * query
  
  This should be a hash reference of query parameters. The values for
  each key may be a scalar or array reference. Use an array reference to
  provide multiple values for one key.
  
  =item * query_separator
  
  This option is can I<only> be provided when calling C<uri()>. By
  default, it is a semi-colon (;).
  
  =back
  
  =back
  
  =head1 AUTHOR
  
  Dave Rolsky, <autarch@urth.org>
  
  =head1 BUGS
  
  Please report any bugs or feature requests to
  C<bug-uri-fromhash@rt.cpan.org>, or through the web interface at
  L<http://rt.cpan.org>.  I will be notified, and then you'll automatically be
  notified of progress on your bug as I make changes.
  
  =head1 COPYRIGHT & LICENSE
  
  Copyright 2006-2008 Dave Rolsky, All Rights Reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
URI_FROMHASH

$fatpacked{"URI/Heuristic.pm"} = <<'URI_HEURISTIC';
  package URI::Heuristic;
  
  =head1 NAME
  
  URI::Heuristic - Expand URI using heuristics
  
  =head1 SYNOPSIS
  
   use URI::Heuristic qw(uf_uristr);
   $u = uf_uristr("perl");             # http://www.perl.com
   $u = uf_uristr("www.sol.no/sol");   # http://www.sol.no/sol
   $u = uf_uristr("aas");              # http://www.aas.no
   $u = uf_uristr("ftp.funet.fi");     # ftp://ftp.funet.fi
   $u = uf_uristr("/etc/passwd");      # file:/etc/passwd
  
  =head1 DESCRIPTION
  
  This module provides functions that expand strings into real absolute
  URIs using some built-in heuristics.  Strings that already represent
  absolute URIs (i.e. that start with a C<scheme:> part) are never modified
  and are returned unchanged.  The main use of these functions is to
  allow abbreviated URIs similar to what many web browsers allow for URIs
  typed in by the user.
  
  The following functions are provided:
  
  =over 4
  
  =item uf_uristr($str)
  
  Tries to make the argument string
  into a proper absolute URI string.  The "uf_" prefix stands for "User 
  Friendly".  Under MacOS, it assumes that any string with a common URL 
  scheme (http, ftp, etc.) is a URL rather than a local path.  So don't name 
  your volumes after common URL schemes and expect uf_uristr() to construct 
  valid file: URL's on those volumes for you, because it won't.
  
  =item uf_uri($str)
  
  Works the same way as uf_uristr() but
  returns a C<URI> object.
  
  =back
  
  =head1 ENVIRONMENT
  
  If the hostname portion of a URI does not contain any dots, then
  certain qualified guesses are made.  These guesses are governed by
  the following environment variables:
  
  =over 10
  
  =item COUNTRY
  
  The two-letter country code (ISO 3166) for your location.  If
  the domain name of your host ends with two letters, then it is taken
  to be the default country. See also L<Locale::Country>.
  
  =item HTTP_ACCEPT_LANGUAGE, LC_ALL, LANG
  
  If COUNTRY is not set, these standard environment variables are
  examined and country (not language) information possibly found in them
  is used as the default country.
  
  =item URL_GUESS_PATTERN
  
  Contains a space-separated list of URL patterns to try.  The string
  "ACME" is for some reason used as a placeholder for the host name in
  the URL provided.  Example:
  
   URL_GUESS_PATTERN="www.ACME.no www.ACME.se www.ACME.com"
   export URL_GUESS_PATTERN
  
  Specifying URL_GUESS_PATTERN disables any guessing rules based on
  country.  An empty URL_GUESS_PATTERN disables any guessing that
  involves host name lookups.
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 1997-1998, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  use strict;
  
  use vars qw(@EXPORT_OK $VERSION $MY_COUNTRY %LOCAL_GUESSING $DEBUG);
  
  require Exporter;
  *import = \&Exporter::import;
  @EXPORT_OK = qw(uf_uri uf_uristr uf_url uf_urlstr);
  $VERSION = "4.20";
  
  sub MY_COUNTRY() {
      for ($MY_COUNTRY) {
  	return $_ if defined;
  
  	# First try the environment.
  	$_ = $ENV{COUNTRY};
  	return $_ if defined;
  
  	# Try the country part of LC_ALL and LANG from environment
  	my @srcs = ($ENV{LC_ALL}, $ENV{LANG});
  	# ...and HTTP_ACCEPT_LANGUAGE before those if present
  	if (my $httplang = $ENV{HTTP_ACCEPT_LANGUAGE}) {
  	    # TODO: q-value processing/ordering
  	    for $httplang (split(/\s*,\s*/, $httplang)) {
  		if ($httplang =~ /^\s*([a-zA-Z]+)[_-]([a-zA-Z]{2})\s*$/) {
  		    unshift(@srcs, "${1}_${2}");
  		    last;
  		}
  	    }
  	}
  	for (@srcs) {
  	    next unless defined;
  	    return lc($1) if /^[a-zA-Z]+_([a-zA-Z]{2})(?:[.@]|$)/;
  	}
  
  	# Last bit of domain name.  This may access the network.
  	require Net::Domain;
  	my $fqdn = Net::Domain::hostfqdn();
  	$_ = lc($1) if $fqdn =~ /\.([a-zA-Z]{2})$/;
  	return $_ if defined;
  
  	# Give up.  Defined but false.
  	return ($_ = 0);
      }
  }
  
  %LOCAL_GUESSING =
  (
   'us' => [qw(www.ACME.gov www.ACME.mil)],
   'gb' => [qw(www.ACME.co.uk www.ACME.org.uk www.ACME.ac.uk)],
   'au' => [qw(www.ACME.com.au www.ACME.org.au www.ACME.edu.au)],
   'il' => [qw(www.ACME.co.il www.ACME.org.il www.ACME.net.il)],
   # send corrections and new entries to <gisle@aas.no>
  );
  # Backwards compatibility; uk != United Kingdom in ISO 3166
  $LOCAL_GUESSING{uk} = $LOCAL_GUESSING{gb};
  
  
  sub uf_uristr ($)
  {
      local($_) = @_;
      print STDERR "uf_uristr: resolving $_\n" if $DEBUG;
      return unless defined;
  
      s/^\s+//;
      s/\s+$//;
  
      if (/^(www|web|home)[a-z0-9-]*(?:\.|$)/i) {
  	$_ = "http://$_";
  
      } elsif (/^(ftp|gopher|news|wais|https|http)[a-z0-9-]*(?:\.|$)/i) {
  	$_ = lc($1) . "://$_";
  
      } elsif ($^O ne "MacOS" && 
  	    (m,^/,      ||          # absolute file name
  	     m,^\.\.?/, ||          # relative file name
  	     m,^[a-zA-Z]:[/\\],)    # dosish file name
  	    )
      {
  	$_ = "file:$_";
  
      } elsif ($^O eq "MacOS" && m/:/) {
          # potential MacOS file name
  	unless (m/^(ftp|gopher|news|wais|http|https|mailto):/) {
  	    require URI::file;
  	    my $a = URI::file->new($_)->as_string;
  	    $_ = ($a =~ m/^file:/) ? $a : "file:$a";
  	}
      } elsif (/^\w+([\.\-]\w+)*\@(\w+\.)+\w{2,3}$/) {
  	$_ = "mailto:$_";
  
      } elsif (!/^[a-zA-Z][a-zA-Z0-9.+\-]*:/) {      # no scheme specified
  	if (s/^([-\w]+(?:\.[-\w]+)*)([\/:\?\#]|$)/$2/) {
  	    my $host = $1;
  
  	    my $scheme = "http";
  	    if (/^:(\d+)\b/) {
  		# Some more or less well known ports
  		if ($1 =~ /^[56789]?443$/) {
  		    $scheme = "https";
  		} elsif ($1 eq "21") {
  		    $scheme = "ftp";
  		}
  	    }
  
  	    if ($host !~ /\./ && $host ne "localhost") {
  		my @guess;
  		if (exists $ENV{URL_GUESS_PATTERN}) {
  		    @guess = map { s/\bACME\b/$host/; $_ }
  		             split(' ', $ENV{URL_GUESS_PATTERN});
  		} else {
  		    if (MY_COUNTRY()) {
  			my $special = $LOCAL_GUESSING{MY_COUNTRY()};
  			if ($special) {
  			    my @special = @$special;
  			    push(@guess, map { s/\bACME\b/$host/; $_ }
                                                 @special);
  			} else {
  			    push(@guess, "www.$host." . MY_COUNTRY());
  			}
  		    }
  		    push(@guess, map "www.$host.$_",
  			             "com", "org", "net", "edu", "int");
  		}
  
  
  		my $guess;
  		for $guess (@guess) {
  		    print STDERR "uf_uristr: gethostbyname('$guess.')..."
  		      if $DEBUG;
  		    if (gethostbyname("$guess.")) {
  			print STDERR "yes\n" if $DEBUG;
  			$host = $guess;
  			last;
  		    }
  		    print STDERR "no\n" if $DEBUG;
  		}
  	    }
  	    $_ = "$scheme://$host$_";
  
  	} else {
  	    # pure junk, just return it unchanged...
  
  	}
      }
      print STDERR "uf_uristr: ==> $_\n" if $DEBUG;
  
      $_;
  }
  
  sub uf_uri ($)
  {
      require URI;
      URI->new(uf_uristr($_[0]));
  }
  
  # legacy
  *uf_urlstr = \*uf_uristr;
  
  sub uf_url ($)
  {
      require URI::URL;
      URI::URL->new(uf_uristr($_[0]));
  }
  
  1;
URI_HEURISTIC

$fatpacked{"URI/IRI.pm"} = <<'URI_IRI';
  package URI::IRI;
  
  # Experimental
  
  use strict;
  use URI ();
  
  use overload '""' => sub { shift->as_string };
  
  sub new {
      my($class, $uri, $scheme) = @_;
      utf8::upgrade($uri);
      return bless {
  	uri => URI->new($uri, $scheme),
      }, $class;
  }
  
  sub clone {
      my $self = shift;
      return bless {
  	uri => $self->{uri}->clone,
      }, ref($self);
  }
  
  sub as_string {
      my $self = shift;
      return $self->{uri}->as_iri;
  }
  
  sub AUTOLOAD
  {
      use vars qw($AUTOLOAD);
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
  
      # We create the function here so that it will not need to be
      # autoloaded the next time.
      no strict 'refs';
      *$method = sub { shift->{uri}->$method(@_) };
      goto &$method;
  }
  
  sub DESTROY {}   # avoid AUTOLOADing it
  
  1;
URI_IRI

$fatpacked{"URI/QueryParam.pm"} = <<'URI_QUERYPARAM';
  package URI::QueryParam;
  
  use strict;
  
  sub URI::_query::query_param {
      my $self = shift;
      my @old = $self->query_form;
  
      if (@_ == 0) {
  	# get keys
  	my (%seen, $i);
  	return grep !($i++ % 2 || $seen{$_}++), @old;
      }
  
      my $key = shift;
      my @i = grep $_ % 2 == 0 && $old[$_] eq $key, 0 .. $#old;
  
      if (@_) {
  	my @new = @old;
  	my @new_i = @i;
  	my @vals = map { ref($_) eq 'ARRAY' ? @$_ : $_ } @_;
  
  	while (@new_i > @vals) {
  	    splice @new, pop @new_i, 2;
  	}
  	if (@vals > @new_i) {
  	    my $i = @new_i ? $new_i[-1] + 2 : @new;
  	    my @splice = splice @vals, @new_i, @vals - @new_i;
  
  	    splice @new, $i, 0, map { $key => $_ } @splice;
  	}
  	if (@vals) {
  	    #print "SET $new_i[0]\n";
  	    @new[ map $_ + 1, @new_i ] = @vals;
  	}
  
  	$self->query_form(\@new);
      }
  
      return wantarray ? @old[map $_+1, @i] : @i ? $old[$i[0]+1] : undef;
  }
  
  sub URI::_query::query_param_append {
      my $self = shift;
      my $key = shift;
      my @vals = map { ref $_ eq 'ARRAY' ? @$_ : $_ } @_;
      $self->query_form($self->query_form, $key => \@vals);  # XXX
      return;
  }
  
  sub URI::_query::query_param_delete {
      my $self = shift;
      my $key = shift;
      my @old = $self->query_form;
      my @vals;
  
      for (my $i = @old - 2; $i >= 0; $i -= 2) {
  	next if $old[$i] ne $key;
  	push(@vals, (splice(@old, $i, 2))[1]);
      }
      $self->query_form(\@old) if @vals;
      return wantarray ? reverse @vals : $vals[-1];
  }
  
  sub URI::_query::query_form_hash {
      my $self = shift;
      my @old = $self->query_form;
      if (@_) {
  	$self->query_form(@_ == 1 ? %{shift(@_)} : @_);
      }
      my %hash;
      while (my($k, $v) = splice(@old, 0, 2)) {
  	if (exists $hash{$k}) {
  	    for ($hash{$k}) {
  		$_ = [$_] unless ref($_) eq "ARRAY";
  		push(@$_, $v);
  	    }
  	}
  	else {
  	    $hash{$k} = $v;
  	}
      }
      return \%hash;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::QueryParam - Additional query methods for URIs
  
  =head1 SYNOPSIS
  
    use URI;
    use URI::QueryParam;
  
    $u = URI->new("", "http");
    $u->query_param(foo => 1, 2, 3);
    print $u->query;    # prints foo=1&foo=2&foo=3
  
    for my $key ($u->query_param) {
        print "$key: ", join(", ", $u->query_param($key)), "\n";
    }
  
  =head1 DESCRIPTION
  
  Loading the C<URI::QueryParam> module adds some extra methods to
  URIs that support query methods.  These methods provide an alternative
  interface to the $u->query_form data.
  
  The query_param_* methods have deliberately been made identical to the
  interface of the corresponding C<CGI.pm> methods.
  
  The following additional methods are made available:
  
  =over
  
  =item @keys = $u->query_param
  
  =item @values = $u->query_param( $key )
  
  =item $first_value = $u->query_param( $key )
  
  =item $u->query_param( $key, $value,... )
  
  If $u->query_param is called with no arguments, it returns all the
  distinct parameter keys of the URI.  In a scalar context it returns the
  number of distinct keys.
  
  When a $key argument is given, the method returns the parameter values with the
  given key.  In a scalar context, only the first parameter value is
  returned.
  
  If additional arguments are given, they are used to update successive
  parameters with the given key.  If any of the values provided are
  array references, then the array is dereferenced to get the actual
  values.
  
  =item $u->query_param_append($key, $value,...)
  
  Adds new parameters with the given
  key without touching any old parameters with the same key.  It
  can be explained as a more efficient version of:
  
     $u->query_param($key,
                     $u->query_param($key),
                     $value,...);
  
  One difference is that this expression would return the old values
  of $key, whereas the query_param_append() method does not.
  
  =item @values = $u->query_param_delete($key)
  
  =item $first_value = $u->query_param_delete($key)
  
  Deletes all key/value pairs with the given key.
  The old values are returned.  In a scalar context, only the first value
  is returned.
  
  Using the query_param_delete() method is slightly more efficient than
  the equivalent:
  
     $u->query_param($key, []);
  
  =item $hashref = $u->query_form_hash
  
  =item $u->query_form_hash( \%new_form )
  
  Returns a reference to a hash that represents the
  query form's key/value pairs.  If a key occurs multiple times, then the hash
  value becomes an array reference.
  
  Note that sequence information is lost.  This means that:
  
     $u->query_form_hash($u->query_form_hash);
  
  is not necessarily a no-op, as it may reorder the key/value pairs.
  The values returned by the query_param() method should stay the same
  though.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<CGI>
  
  =head1 COPYRIGHT
  
  Copyright 2002 Gisle Aas.
  
  =cut
URI_QUERYPARAM

$fatpacked{"URI/Split.pm"} = <<'URI_SPLIT';
  package URI::Split;
  
  use strict;
  
  use vars qw(@ISA @EXPORT_OK);
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT_OK = qw(uri_split uri_join);
  
  use URI::Escape ();
  
  sub uri_split {
       return $_[0] =~ m,(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?,;
  }
  
  sub uri_join {
      my($scheme, $auth, $path, $query, $frag) = @_;
      my $uri = defined($scheme) ? "$scheme:" : "";
      $path = "" unless defined $path;
      if (defined $auth) {
  	$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;
  	$uri .= "//$auth";
  	$path = "/$path" if length($path) && $path !~ m,^/,;
      }
      elsif ($path =~ m,^//,) {
  	$uri .= "//";  # XXX force empty auth
      }
      unless (length $uri) {
  	$path =~ s,(:), URI::Escape::escape_char($1),e while $path =~ m,^[^:/?\#]+:,;
      }
      $path =~ s,([?\#]), URI::Escape::escape_char($1),eg;
      $uri .= $path;
      if (defined $query) {
  	$query =~ s,(\#), URI::Escape::escape_char($1),eg;
  	$uri .= "?$query";
      }
      $uri .= "#$frag" if defined $frag;
      $uri;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::Split - Parse and compose URI strings
  
  =head1 SYNOPSIS
  
   use URI::Split qw(uri_split uri_join);
   ($scheme, $auth, $path, $query, $frag) = uri_split($uri);
   $uri = uri_join($scheme, $auth, $path, $query, $frag);
  
  =head1 DESCRIPTION
  
  Provides functions to parse and compose URI
  strings.  The following functions are provided:
  
  =over
  
  =item ($scheme, $auth, $path, $query, $frag) = uri_split($uri)
  
  Breaks up a URI string into its component
  parts.  An C<undef> value is returned for those parts that are not
  present.  The $path part is always present (but can be the empty
  string) and is thus never returned as C<undef>.
  
  No sensible value is returned if this function is called in a scalar
  context.
  
  =item $uri = uri_join($scheme, $auth, $path, $query, $frag)
  
  Puts together a URI string from its parts.
  Missing parts are signaled by passing C<undef> for the corresponding
  argument.
  
  Minimal escaping is applied to parts that contain reserved chars
  that would confuse a parser.  For instance, any occurrence of '?' or '#'
  in $path is always escaped, as it would otherwise be parsed back
  as a query or fragment.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<URI::Escape>
  
  =head1 COPYRIGHT
  
  Copyright 2003, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_SPLIT

$fatpacked{"URI/URL.pm"} = <<'URI_URL';
  package URI::URL;
  
  require URI::WithBase;
  @ISA=qw(URI::WithBase);
  
  use strict;
  use vars qw(@EXPORT $VERSION);
  
  $VERSION = "5.04";
  
  # Provide as much as possible of the old URI::URL interface for backwards
  # compatibility...
  
  require Exporter;
  *import = \&Exporter::import;
  @EXPORT = qw(url);
  
  # Easy to use constructor
  sub url ($;$) { URI::URL->new(@_); }
  
  use URI::Escape qw(uri_unescape);
  
  sub new
  {
      my $class = shift;
      my $self = $class->SUPER::new(@_);
      $self->[0] = $self->[0]->canonical;
      $self;
  }
  
  sub newlocal
  {
      my $class = shift;
      require URI::file;
      bless [URI::file->new_abs(shift)], $class;
  }
  
  {package URI::_foreign;
      sub _init  # hope it is not defined
      {
  	my $class = shift;
  	die "Unknown URI::URL scheme $_[1]:" if $URI::URL::STRICT;
  	$class->SUPER::_init(@_);
      }
  }
  
  sub strict
  {
      my $old = $URI::URL::STRICT;
      $URI::URL::STRICT = shift if @_;
      $old;
  }
  
  sub print_on
  {
      my $self = shift;
      require Data::Dumper;
      print STDERR Data::Dumper::Dumper($self);
  }
  
  sub _try
  {
      my $self = shift;
      my $method = shift;
      scalar(eval { $self->$method(@_) });
  }
  
  sub crack
  {
      # should be overridden by subclasses
      my $self = shift;
      (scalar($self->scheme),
       $self->_try("user"),
       $self->_try("password"),
       $self->_try("host"),
       $self->_try("port"),
       $self->_try("path"),
       $self->_try("params"),
       $self->_try("query"),
       scalar($self->fragment),
      )
  }
  
  sub full_path
  {
      my $self = shift;
      my $path = $self->path_query;
      $path = "/" unless length $path;
      $path;
  }
  
  sub netloc
  {
      shift->authority(@_);
  }
  
  sub epath
  {
      my $path = shift->SUPER::path(@_);
      $path =~ s/;.*//;
      $path;
  }
  
  sub eparams
  {
      my $self = shift;
      my @p = $self->path_segments;
      return unless ref($p[-1]);
      @p = @{$p[-1]};
      shift @p;
      join(";", @p);
  }
  
  sub params { shift->eparams(@_); }
  
  sub path {
      my $self = shift;
      my $old = $self->epath(@_);
      return unless defined wantarray;
      return '/' if !defined($old) || !length($old);
      Carp::croak("Path components contain '/' (you must call epath)")
  	if $old =~ /%2[fF]/ and !@_;
      $old = "/$old" if $old !~ m|^/| && defined $self->netloc;
      return uri_unescape($old);
  }
  
  sub path_components {
      shift->path_segments(@_);
  }
  
  sub query {
      my $self = shift;
      my $old = $self->equery(@_);
      if (defined(wantarray) && defined($old)) {
  	if ($old =~ /%(?:26|2[bB]|3[dD])/) {  # contains escaped '=' '&' or '+'
  	    my $mess;
  	    for ($old) {
  		$mess = "Query contains both '+' and '%2B'"
  		  if /\+/ && /%2[bB]/;
  		$mess = "Form query contains escaped '=' or '&'"
  		  if /=/  && /%(?:3[dD]|26)/;
  	    }
  	    if ($mess) {
  		Carp::croak("$mess (you must call equery)");
  	    }
  	}
  	# Now it should be safe to unescape the string without loosing
  	# information
  	return uri_unescape($old);
      }
      undef;
  
  }
  
  sub abs
  {
      my $self = shift;
      my $base = shift;
      my $allow_scheme = shift;
      $allow_scheme = $URI::URL::ABS_ALLOW_RELATIVE_SCHEME
  	unless defined $allow_scheme;
      local $URI::ABS_ALLOW_RELATIVE_SCHEME = $allow_scheme;
      local $URI::ABS_REMOTE_LEADING_DOTS = $URI::URL::ABS_REMOTE_LEADING_DOTS;
      $self->SUPER::abs($base);
  }
  
  sub frag { shift->fragment(@_); }
  sub keywords { shift->query_keywords(@_); }
  
  # file:
  sub local_path { shift->file; }
  sub unix_path  { shift->file("unix"); }
  sub dos_path   { shift->file("dos");  }
  sub mac_path   { shift->file("mac");  }
  sub vms_path   { shift->file("vms");  }
  
  # mailto:
  sub address { shift->to(@_); }
  sub encoded822addr { shift->to(@_); }
  sub URI::mailto::authority { shift->to(@_); }  # make 'netloc' method work
  
  # news:
  sub groupart { shift->_group(@_); }
  sub article  { shift->message(@_); }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::URL - Uniform Resource Locators
  
  =head1 SYNOPSIS
  
   $u1 = URI::URL->new($str, $base);
   $u2 = $u1->abs;
  
  =head1 DESCRIPTION
  
  This module is provided for backwards compatibility with modules that
  depend on the interface provided by the C<URI::URL> class that used to
  be distributed with the libwww-perl library.
  
  The following differences exist compared to the C<URI> class interface:
  
  =over 3
  
  =item *
  
  The URI::URL module exports the url() function as an alternate
  constructor interface.
  
  =item *
  
  The constructor takes an optional $base argument.  The C<URI::URL>
  class is a subclass of C<URI::WithBase>.
  
  =item *
  
  The URI::URL->newlocal class method is the same as URI::file->new_abs.
  
  =item *
  
  URI::URL::strict(1)
  
  =item *
  
  $url->print_on method
  
  =item *
  
  $url->crack method
  
  =item *
  
  $url->full_path: same as ($uri->abs_path || "/")
  
  =item *
  
  $url->netloc: same as $uri->authority
  
  =item *
  
  $url->epath, $url->equery: same as $uri->path, $uri->query
  
  =item *
  
  $url->path and $url->query pass unescaped strings.
  
  =item *
  
  $url->path_components: same as $uri->path_segments (if you don't
  consider path segment parameters)
  
  =item *
  
  $url->params and $url->eparams methods
  
  =item *
  
  $url->base method.  See L<URI::WithBase>.
  
  =item *
  
  $url->abs and $url->rel have an optional $base argument.  See
  L<URI::WithBase>.
  
  =item *
  
  $url->frag: same as $uri->fragment
  
  =item *
  
  $url->keywords: same as $uri->query_keywords
  
  =item *
  
  $url->localpath and friends map to $uri->file.
  
  =item *
  
  $url->address and $url->encoded822addr: same as $uri->to for mailto URI
  
  =item *
  
  $url->groupart method for news URI
  
  =item *
  
  $url->article: same as $uri->message
  
  =back
  
  
  
  =head1 SEE ALSO
  
  L<URI>, L<URI::WithBase>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2000 Gisle Aas.
  
  =cut
URI_URL

$fatpacked{"URI/WithBase.pm"} = <<'URI_WITHBASE';
  package URI::WithBase;
  
  use strict;
  use vars qw($AUTOLOAD $VERSION);
  use URI;
  
  $VERSION = "2.20";
  
  use overload '""' => "as_string", fallback => 1;
  
  sub as_string;  # help overload find it
  
  sub new
  {
      my($class, $uri, $base) = @_;
      my $ibase = $base;
      if ($base && ref($base) && UNIVERSAL::isa($base, __PACKAGE__)) {
  	$base = $base->abs;
  	$ibase = $base->[0];
      }
      bless [URI->new($uri, $ibase), $base], $class;
  }
  
  sub new_abs
  {
      my $class = shift;
      my $self = $class->new(@_);
      $self->abs;
  }
  
  sub _init
  {
      my $class = shift;
      my($str, $scheme) = @_;
      bless [URI->new($str, $scheme), undef], $class;
  }
  
  sub eq
  {
      my($self, $other) = @_;
      $other = $other->[0] if UNIVERSAL::isa($other, __PACKAGE__);
      $self->[0]->eq($other);
  }
  
  sub AUTOLOAD
  {
      my $self = shift;
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
      return if $method eq "DESTROY";
      $self->[0]->$method(@_);
  }
  
  sub can {                                  # override UNIVERSAL::can
      my $self = shift;
      $self->SUPER::can(@_) || (
        ref($self)
        ? $self->[0]->can(@_)
        : undef
      )
  }
  
  sub base {
      my $self = shift;
      my $base  = $self->[1];
  
      if (@_) { # set
  	my $new_base = shift;
  	# ensure absoluteness
  	$new_base = $new_base->abs if ref($new_base) && $new_base->isa(__PACKAGE__);
  	$self->[1] = $new_base;
      }
      return unless defined wantarray;
  
      # The base attribute supports 'lazy' conversion from URL strings
      # to URL objects. Strings may be stored but when a string is
      # fetched it will automatically be converted to a URL object.
      # The main benefit is to make it much cheaper to say:
      #   URI::WithBase->new($random_url_string, 'http:')
      if (defined($base) && !ref($base)) {
  	$base = ref($self)->new($base);
  	$self->[1] = $base unless @_;
      }
      $base;
  }
  
  sub clone
  {
      my $self = shift;
      my $base = $self->[1];
      $base = $base->clone if ref($base);
      bless [$self->[0]->clone, $base], ref($self);
  }
  
  sub abs
  {
      my $self = shift;
      my $base = shift || $self->base || return $self->clone;
      $base = $base->as_string if ref($base);
      bless [$self->[0]->abs($base, @_), $base], ref($self);
  }
  
  sub rel
  {
      my $self = shift;
      my $base = shift || $self->base || return $self->clone;
      $base = $base->as_string if ref($base);
      bless [$self->[0]->rel($base, @_), $base], ref($self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::WithBase - URIs which remember their base
  
  =head1 SYNOPSIS
  
   $u1 = URI::WithBase->new($str, $base);
   $u2 = $u1->abs;
  
   $base = $u1->base;
   $u1->base( $new_base )
  
  =head1 DESCRIPTION
  
  This module provides the C<URI::WithBase> class.  Objects of this class
  are like C<URI> objects, but can keep their base too.  The base
  represents the context where this URI was found and can be used to
  absolutize or relativize the URI.  All the methods described in L<URI>
  are supported for C<URI::WithBase> objects.
  
  The methods provided in addition to or modified from those of C<URI> are:
  
  =over 4
  
  =item $uri = URI::WithBase->new($str, [$base])
  
  The constructor takes an optional base URI as the second argument.
  If provided, this argument initializes the base attribute.
  
  =item $uri->base( [$new_base] )
  
  Can be used to get or set the value of the base attribute.
  The return value, which is the old value, is a URI object or C<undef>.
  
  =item $uri->abs( [$base_uri] )
  
  The $base_uri argument is now made optional as the object carries its
  base with it.  A new object is returned even if $uri is already
  absolute (while plain URI objects simply return themselves in
  that case).
  
  =item $uri->rel( [$base_uri] )
  
  The $base_uri argument is now made optional as the object carries its
  base with it.  A new object is always returned.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<URI>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2002 Gisle Aas.
  
  =cut
URI_WITHBASE

$fatpacked{"URI/_foreign.pm"} = <<'URI__FOREIGN';
  package URI::_foreign;
  
  require URI::_generic;
  @ISA=qw(URI::_generic);
  
  1;
URI__FOREIGN

$fatpacked{"URI/_generic.pm"} = <<'URI__GENERIC';
  package URI::_generic;
  require URI;
  require URI::_query;
  @ISA=qw(URI URI::_query);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  use Carp ();
  
  my $ACHAR = $URI::uric;  $ACHAR =~ s,\\[/?],,g;
  my $PCHAR = $URI::uric;  $PCHAR =~ s,\\[?],,g;
  
  sub _no_scheme_ok { 1 }
  
  sub authority
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?://([^/?\#]*))?(.*)$,os or die;
  
      if (@_) {
  	my $auth = shift;
  	$$self = $1;
  	my $rest = $3;
  	if (defined $auth) {
  	    $auth =~ s/([^$ACHAR])/ URI::Escape::escape_char($1)/ego;
  	    utf8::downgrade($auth);
  	    $$self .= "//$auth";
  	}
  	_check_path($rest, $$self);
  	$$self .= $rest;
      }
      $2;
  }
  
  sub path
  {
      my $self = shift;
      $$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^?\#]*)(.*)$,s or die;
  
      if (@_) {
  	$$self = $1;
  	my $rest = $3;
  	my $new_path = shift;
  	$new_path = "" unless defined $new_path;
  	$new_path =~ s/([^$PCHAR])/ URI::Escape::escape_char($1)/ego;
  	utf8::downgrade($new_path);
  	_check_path($new_path, $$self);
  	$$self .= $new_path . $rest;
      }
      $2;
  }
  
  sub path_query
  {
      my $self = shift;
      $$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^\#]*)(.*)$,s or die;
  
      if (@_) {
  	$$self = $1;
  	my $rest = $3;
  	my $new_path = shift;
  	$new_path = "" unless defined $new_path;
  	$new_path =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
  	utf8::downgrade($new_path);
  	_check_path($new_path, $$self);
  	$$self .= $new_path . $rest;
      }
      $2;
  }
  
  sub _check_path
  {
      my($path, $pre) = @_;
      my $prefix;
      if ($pre =~ m,/,) {  # authority present
  	$prefix = "/" if length($path) && $path !~ m,^[/?\#],;
      }
      else {
  	if ($path =~ m,^//,) {
  	    Carp::carp("Path starting with double slash is confusing")
  		if $^W;
  	}
  	elsif (!length($pre) && $path =~ m,^[^:/?\#]+:,) {
  	    Carp::carp("Path might look like scheme, './' prepended")
  		if $^W;
  	    $prefix = "./";
  	}
      }
      substr($_[0], 0, 0) = $prefix if defined $prefix;
  }
  
  sub path_segments
  {
      my $self = shift;
      my $path = $self->path;
      if (@_) {
  	my @arg = @_;  # make a copy
  	for (@arg) {
  	    if (ref($_)) {
  		my @seg = @$_;
  		$seg[0] =~ s/%/%25/g;
  		for (@seg) { s/;/%3B/g; }
  		$_ = join(";", @seg);
  	    }
  	    else {
  		 s/%/%25/g; s/;/%3B/g;
  	    }
  	    s,/,%2F,g;
  	}
  	$self->path(join("/", @arg));
      }
      return $path unless wantarray;
      map {/;/ ? $self->_split_segment($_)
               : uri_unescape($_) }
          split('/', $path, -1);
  }
  
  
  sub _split_segment
  {
      my $self = shift;
      require URI::_segment;
      URI::_segment->new(@_);
  }
  
  
  sub abs
  {
      my $self = shift;
      my $base = shift || Carp::croak("Missing base argument");
  
      if (my $scheme = $self->scheme) {
  	return $self unless $URI::ABS_ALLOW_RELATIVE_SCHEME;
  	$base = URI->new($base) unless ref $base;
  	return $self unless $scheme eq $base->scheme;
      }
  
      $base = URI->new($base) unless ref $base;
      my $abs = $self->clone;
      $abs->scheme($base->scheme);
      return $abs if $$self =~ m,^(?:$URI::scheme_re:)?//,o;
      $abs->authority($base->authority);
  
      my $path = $self->path;
      return $abs if $path =~ m,^/,;
  
      if (!length($path)) {
  	my $abs = $base->clone;
  	my $query = $self->query;
  	$abs->query($query) if defined $query;
  	$abs->fragment($self->fragment);
  	return $abs;
      }
  
      my $p = $base->path;
      $p =~ s,[^/]+$,,;
      $p .= $path;
      my @p = split('/', $p, -1);
      shift(@p) if @p && !length($p[0]);
      my $i = 1;
      while ($i < @p) {
  	#print "$i ", join("/", @p), " ($p[$i])\n";
  	if ($p[$i-1] eq ".") {
  	    splice(@p, $i-1, 1);
  	    $i-- if $i > 1;
  	}
  	elsif ($p[$i] eq ".." && $p[$i-1] ne "..") {
  	    splice(@p, $i-1, 2);
  	    if ($i > 1) {
  		$i--;
  		push(@p, "") if $i == @p;
  	    }
  	}
  	else {
  	    $i++;
  	}
      }
      $p[-1] = "" if @p && $p[-1] eq ".";  # trailing "/."
      if ($URI::ABS_REMOTE_LEADING_DOTS) {
          shift @p while @p && $p[0] =~ /^\.\.?$/;
      }
      $abs->path("/" . join("/", @p));
      $abs;
  }
  
  # The opposite of $url->abs.  Return a URI which is as relative as possible
  sub rel {
      my $self = shift;
      my $base = shift || Carp::croak("Missing base argument");
      my $rel = $self->clone;
      $base = URI->new($base) unless ref $base;
  
      #my($scheme, $auth, $path) = @{$rel}{qw(scheme authority path)};
      my $scheme = $rel->scheme;
      my $auth   = $rel->canonical->authority;
      my $path   = $rel->path;
  
      if (!defined($scheme) && !defined($auth)) {
  	# it is already relative
  	return $rel;
      }
  
      #my($bscheme, $bauth, $bpath) = @{$base}{qw(scheme authority path)};
      my $bscheme = $base->scheme;
      my $bauth   = $base->canonical->authority;
      my $bpath   = $base->path;
  
      for ($bscheme, $bauth, $auth) {
  	$_ = '' unless defined
      }
  
      unless ($scheme eq $bscheme && $auth eq $bauth) {
  	# different location, can't make it relative
  	return $rel;
      }
  
      for ($path, $bpath) {  $_ = "/$_" unless m,^/,; }
  
      # Make it relative by eliminating scheme and authority
      $rel->scheme(undef);
      $rel->authority(undef);
  
      # This loop is based on code from Nicolai Langfeldt <janl@ifi.uio.no>.
      # First we calculate common initial path components length ($li).
      my $li = 1;
      while (1) {
  	my $i = index($path, '/', $li);
  	last if $i < 0 ||
                  $i != index($bpath, '/', $li) ||
  	        substr($path,$li,$i-$li) ne substr($bpath,$li,$i-$li);
  	$li=$i+1;
      }
      # then we nuke it from both paths
      substr($path, 0,$li) = '';
      substr($bpath,0,$li) = '';
  
      if ($path eq $bpath &&
          defined($rel->fragment) &&
          !defined($rel->query)) {
          $rel->path("");
      }
      else {
          # Add one "../" for each path component left in the base path
          $path = ('../' x $bpath =~ tr|/|/|) . $path;
  	$path = "./" if $path eq "";
          $rel->path($path);
      }
  
      $rel;
  }
  
  1;
URI__GENERIC

$fatpacked{"URI/_idna.pm"} = <<'URI__IDNA';
  package URI::_idna;
  
  # This module implements the RFCs 3490 (IDNA) and 3491 (Nameprep)
  # based on Python-2.6.4/Lib/encodings/idna.py
  
  use strict;
  use URI::_punycode qw(encode_punycode decode_punycode);
  use Carp qw(croak);
  
  BEGIN {
    *URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS = $] < 5.008_003
      ? sub () { 1 }
      : sub () { 0 }
    ;
  }
  
  my $ASCII = qr/^[\x00-\x7F]*\z/;
  
  sub encode {
      my $idomain = shift;
      my @labels = split(/\./, $idomain, -1);
      my @last_empty;
      push(@last_empty, pop @labels) if @labels > 1 && $labels[-1] eq "";
      for (@labels) {
  	$_ = ToASCII($_);
      }
  
      return eval 'join(".", @labels, @last_empty)' if URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS;
      return join(".", @labels, @last_empty);
  }
  
  sub decode {
      my $domain = shift;
      return join(".", map ToUnicode($_), split(/\./, $domain, -1))
  }
  
  sub nameprep { # XXX real implementation missing
      my $label = shift;
      $label = lc($label);
      return $label;
  }
  
  sub check_size {
      my $label = shift;
      croak "Label empty" if $label eq "";
      croak "Label too long" if length($label) > 63;
      return $label;
  }
  
  sub ToASCII {
      my $label = shift;
      return check_size($label) if $label =~ $ASCII;
  
      # Step 2: nameprep
      $label = nameprep($label);
      # Step 3: UseSTD3ASCIIRules is false
      # Step 4: try ASCII again
      return check_size($label) if $label =~ $ASCII;
  
      # Step 5: Check ACE prefix
      if ($label =~ /^xn--/) {
          croak "Label starts with ACE prefix";
      }
  
      # Step 6: Encode with PUNYCODE
      $label = encode_punycode($label);
  
      # Step 7: Prepend ACE prefix
      $label = "xn--$label";
  
      # Step 8: Check size
      return check_size($label);
  }
  
  sub ToUnicode {
      my $label = shift;
      $label = nameprep($label) unless $label =~ $ASCII;
      return $label unless $label =~ /^xn--/;
      my $result = decode_punycode(substr($label, 4));
      my $label2 = ToASCII($result);
      if (lc($label) ne $label2) {
  	croak "IDNA does not round-trip: '\L$label\E' vs '$label2'";
      }
      return $result;
  }
  
  1;
URI__IDNA

$fatpacked{"URI/_ldap.pm"} = <<'URI__LDAP';
  # Copyright (c) 1998 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package URI::_ldap;
  
  use strict;
  
  use vars qw($VERSION);
  $VERSION = "1.12";
  
  use URI::Escape qw(uri_unescape);
  
  sub _ldap_elem {
    my $self  = shift;
    my $elem  = shift;
    my $query = $self->query;
    my @bits  = (split(/\?/,defined($query) ? $query : ""),("")x4);
    my $old   = $bits[$elem];
  
    if (@_) {
      my $new = shift;
      $new =~ s/\?/%3F/g;
      $bits[$elem] = $new;
      $query = join("?",@bits);
      $query =~ s/\?+$//;
      $query = undef unless length($query);
      $self->query($query);
    }
  
    $old;
  }
  
  sub dn {
    my $old = shift->path(@_);
    $old =~ s:^/::;
    uri_unescape($old);
  }
  
  sub attributes {
    my $self = shift;
    my $old = _ldap_elem($self,0, @_ ? join(",", map { my $tmp = $_; $tmp =~ s/,/%2C/g; $tmp } @_) : ());
    return $old unless wantarray;
    map { uri_unescape($_) } split(/,/,$old);
  }
  
  sub _scope {
    my $self = shift;
    my $old = _ldap_elem($self,1, @_);
    return unless defined wantarray && defined $old;
    uri_unescape($old);
  }
  
  sub scope {
    my $old = &_scope;
    $old = "base" unless length $old;
    $old;
  }
  
  sub _filter {
    my $self = shift;
    my $old = _ldap_elem($self,2, @_);
    return unless defined wantarray && defined $old;
    uri_unescape($old); # || "(objectClass=*)";
  }
  
  sub filter {
    my $old = &_filter;
    $old = "(objectClass=*)" unless length $old;
    $old;
  }
  
  sub extensions {
    my $self = shift;
    my @ext;
    while (@_) {
      my $key = shift;
      my $value = shift;
      push(@ext, join("=", map { $_="" unless defined; s/,/%2C/g; $_ } $key, $value));
    }
    @ext = join(",", @ext) if @ext;
    my $old = _ldap_elem($self,3, @ext);
    return $old unless wantarray;
    map { uri_unescape($_) } map { /^([^=]+)=(.*)$/ } split(/,/,$old);
  }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->_nonldap_canonical;
  
      # The stuff below is not as efficient as one might hope...
  
      $other = $other->clone if $other == $self;
  
      $other->dn(_normalize_dn($other->dn));
  
      # Should really know about mixed case "postalAddress", etc...
      $other->attributes(map lc, $other->attributes);
  
      # Lowercase scope, remove default
      my $old_scope = $other->scope;
      my $new_scope = lc($old_scope);
      $new_scope = "" if $new_scope eq "base";
      $other->scope($new_scope) if $new_scope ne $old_scope;
  
      # Remove filter if default
      my $old_filter = $other->filter;
      $other->filter("") if lc($old_filter) eq "(objectclass=*)" ||
  	                  lc($old_filter) eq "objectclass=*";
  
      # Lowercase extensions types and deal with known extension values
      my @ext = $other->extensions;
      for (my $i = 0; $i < @ext; $i += 2) {
  	my $etype = $ext[$i] = lc($ext[$i]);
  	if ($etype =~ /^!?bindname$/) {
  	    $ext[$i+1] = _normalize_dn($ext[$i+1]);
  	}
      }
      $other->extensions(@ext) if @ext;
      
      $other;
  }
  
  sub _normalize_dn  # RFC 2253
  {
      my $dn = shift;
  
      return $dn;
      # The code below will fail if the "+" or "," is embedding in a quoted
      # string or simply escaped...
  
      my @dn = split(/([+,])/, $dn);
      for (@dn) {
  	s/^([a-zA-Z]+=)/lc($1)/e;
      }
      join("", @dn);
  }
  
  1;
URI__LDAP

$fatpacked{"URI/_login.pm"} = <<'URI__LOGIN';
  package URI::_login;
  
  require URI::_server;
  require URI::_userpass;
  @ISA = qw(URI::_server URI::_userpass);
  
  # Generic terminal logins.  This is used as a base class for 'telnet',
  # 'tn3270', and 'rlogin' URL schemes.
  
  1;
URI__LOGIN

$fatpacked{"URI/_punycode.pm"} = <<'URI__PUNYCODE';
  package URI::_punycode;
  
  use strict;
  our $VERSION = "0.04";
  
  require Exporter;
  our @ISA    = qw(Exporter);
  our @EXPORT = qw(encode_punycode decode_punycode);
  
  use integer;
  
  our $DEBUG = 0;
  
  use constant BASE => 36;
  use constant TMIN => 1;
  use constant TMAX => 26;
  use constant SKEW => 38;
  use constant DAMP => 700;
  use constant INITIAL_BIAS => 72;
  use constant INITIAL_N => 128;
  
  my $Delimiter = chr 0x2D;
  my $BasicRE   = qr/[\x00-\x7f]/;
  
  sub _croak { require Carp; Carp::croak(@_); }
  
  sub digit_value {
      my $code = shift;
      return ord($code) - ord("A") if $code =~ /[A-Z]/;
      return ord($code) - ord("a") if $code =~ /[a-z]/;
      return ord($code) - ord("0") + 26 if $code =~ /[0-9]/;
      return;
  }
  
  sub code_point {
      my $digit = shift;
      return $digit + ord('a') if 0 <= $digit && $digit <= 25;
      return $digit + ord('0') - 26 if 26 <= $digit && $digit <= 36;
      die 'NOT COME HERE';
  }
  
  sub adapt {
      my($delta, $numpoints, $firsttime) = @_;
      $delta = $firsttime ? $delta / DAMP : $delta / 2;
      $delta += $delta / $numpoints;
      my $k = 0;
      while ($delta > ((BASE - TMIN) * TMAX) / 2) {
  	$delta /= BASE - TMIN;
  	$k += BASE;
      }
      return $k + (((BASE - TMIN + 1) * $delta) / ($delta + SKEW));
  }
  
  sub decode_punycode {
      my $code = shift;
  
      my $n      = INITIAL_N;
      my $i      = 0;
      my $bias   = INITIAL_BIAS;
      my @output;
  
      if ($code =~ s/(.*)$Delimiter//o) {
  	push @output, map ord, split //, $1;
  	return _croak('non-basic code point') unless $1 =~ /^$BasicRE*$/o;
      }
  
      while ($code) {
  	my $oldi = $i;
  	my $w    = 1;
      LOOP:
  	for (my $k = BASE; 1; $k += BASE) {
  	    my $cp = substr($code, 0, 1, '');
  	    my $digit = digit_value($cp);
  	    defined $digit or return _croak("invalid punycode input");
  	    $i += $digit * $w;
  	    my $t = ($k <= $bias) ? TMIN
  		: ($k >= $bias + TMAX) ? TMAX : $k - $bias;
  	    last LOOP if $digit < $t;
  	    $w *= (BASE - $t);
  	}
  	$bias = adapt($i - $oldi, @output + 1, $oldi == 0);
  	warn "bias becomes $bias" if $DEBUG;
  	$n += $i / (@output + 1);
  	$i = $i % (@output + 1);
  	splice(@output, $i, 0, $n);
  	warn join " ", map sprintf('%04x', $_), @output if $DEBUG;
  	$i++;
      }
      return join '', map chr, @output;
  }
  
  sub encode_punycode {
      my $input = shift;
      my @input = split //, $input;
  
      my $n     = INITIAL_N;
      my $delta = 0;
      my $bias  = INITIAL_BIAS;
  
      my @output;
      my @basic = grep /$BasicRE/, @input;
      my $h = my $b = @basic;
      push @output, @basic;
      push @output, $Delimiter if $b && $h < @input;
      warn "basic codepoints: (@output)" if $DEBUG;
  
      while ($h < @input) {
  	my $m = min(grep { $_ >= $n } map ord, @input);
  	warn sprintf "next code point to insert is %04x", $m if $DEBUG;
  	$delta += ($m - $n) * ($h + 1);
  	$n = $m;
  	for my $i (@input) {
  	    my $c = ord($i);
  	    $delta++ if $c < $n;
  	    if ($c == $n) {
  		my $q = $delta;
  	    LOOP:
  		for (my $k = BASE; 1; $k += BASE) {
  		    my $t = ($k <= $bias) ? TMIN :
  			($k >= $bias + TMAX) ? TMAX : $k - $bias;
  		    last LOOP if $q < $t;
  		    my $cp = code_point($t + (($q - $t) % (BASE - $t)));
  		    push @output, chr($cp);
  		    $q = ($q - $t) / (BASE - $t);
  		}
  		push @output, chr(code_point($q));
  		$bias = adapt($delta, $h + 1, $h == $b);
  		warn "bias becomes $bias" if $DEBUG;
  		$delta = 0;
  		$h++;
  	    }
  	}
  	$delta++;
  	$n++;
      }
      return join '', @output;
  }
  
  sub min {
      my $min = shift;
      for (@_) { $min = $_ if $_ <= $min }
      return $min;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  URI::_punycode - encodes Unicode string in Punycode
  
  =head1 SYNOPSIS
  
    use URI::_punycode;
    $punycode = encode_punycode($unicode);
    $unicode  = decode_punycode($punycode);
  
  =head1 DESCRIPTION
  
  URI::_punycode is a module to encode / decode Unicode strings into
  Punycode, an efficient encoding of Unicode for use with IDNA.
  
  This module requires Perl 5.6.0 or over to handle UTF8 flagged Unicode
  strings.
  
  =head1 FUNCTIONS
  
  This module exports following functions by default.
  
  =over 4
  
  =item encode_punycode
  
    $punycode = encode_punycode($unicode);
  
  takes Unicode string (UTF8-flagged variable) and returns Punycode
  encoding for it.
  
  =item decode_punycode
  
    $unicode = decode_punycode($punycode)
  
  takes Punycode encoding and returns original Unicode string.
  
  =back
  
  These functions throw exceptions on failure. You can catch 'em via
  C<eval>.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa E<lt>miyagawa@bulknews.netE<gt> is the author of
  IDNA::Punycode v0.02 which was the basis for this module.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<IDNA::Punycode>, RFC 3492
  
  =cut
URI__PUNYCODE

$fatpacked{"URI/_query.pm"} = <<'URI__QUERY';
  package URI::_query;
  
  use strict;
  use URI ();
  use URI::Escape qw(uri_unescape);
  
  sub query
  {
      my $self = shift;
      $$self =~ m,^([^?\#]*)(?:\?([^\#]*))?(.*)$,s or die;
  
      if (@_) {
  	my $q = shift;
  	$$self = $1;
  	if (defined $q) {
  	    $q =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
  	    utf8::downgrade($q);
  	    $$self .= "?$q";
  	}
  	$$self .= $3;
      }
      $2;
  }
  
  # Handle ...?foo=bar&bar=foo type of query
  sub query_form {
      my $self = shift;
      my $old = $self->query;
      if (@_) {
          # Try to set query string
          my $delim;
          my $r = $_[0];
          if (ref($r) eq "ARRAY") {
              $delim = $_[1];
              @_ = @$r;
          }
          elsif (ref($r) eq "HASH") {
              $delim = $_[1];
              @_ = %$r;
          }
          $delim = pop if @_ % 2;
  
          my @query;
          while (my($key,$vals) = splice(@_, 0, 2)) {
              $key = '' unless defined $key;
  	    $key =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;
  	    $key =~ s/ /+/g;
  	    $vals = [ref($vals) eq "ARRAY" ? @$vals : $vals];
              for my $val (@$vals) {
                  $val = '' unless defined $val;
  		$val =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;
                  $val =~ s/ /+/g;
                  push(@query, "$key=$val");
              }
          }
          if (@query) {
              unless ($delim) {
                  $delim = $1 if $old && $old =~ /([&;])/;
                  $delim ||= $URI::DEFAULT_QUERY_FORM_DELIMITER || "&";
              }
              $self->query(join($delim, @query));
          }
          else {
              $self->query(undef);
          }
      }
      return if !defined($old) || !length($old) || !defined(wantarray);
      return unless $old =~ /=/; # not a form
      map { s/\+/ /g; uri_unescape($_) }
           map { /=/ ? split(/=/, $_, 2) : ($_ => '')} split(/[&;]/, $old);
  }
  
  # Handle ...?dog+bones type of query
  sub query_keywords
  {
      my $self = shift;
      my $old = $self->query;
      if (@_) {
          # Try to set query string
  	my @copy = @_;
  	@copy = @{$copy[0]} if @copy == 1 && ref($copy[0]) eq "ARRAY";
  	for (@copy) { s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg; }
  	$self->query(@copy ? join('+', @copy) : undef);
      }
      return if !defined($old) || !defined(wantarray);
      return if $old =~ /=/;  # not keywords, but a form
      map { uri_unescape($_) } split(/\+/, $old, -1);
  }
  
  # Some URI::URL compatibility stuff
  *equery = \&query;
  
  1;
URI__QUERY

$fatpacked{"URI/_segment.pm"} = <<'URI__SEGMENT';
  package URI::_segment;
  
  # Represents a generic path_segment so that it can be treated as
  # a string too.
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  use overload '""' => sub { $_[0]->[0] },
               fallback => 1;
  
  sub new
  {
      my $class = shift;
      my @segment = split(';', shift, -1);
      $segment[0] = uri_unescape($segment[0]);
      bless \@segment, $class;
  }
  
  1;
URI__SEGMENT

$fatpacked{"URI/_server.pm"} = <<'URI__SERVER';
  package URI::_server;
  require URI::_generic;
  @ISA=qw(URI::_generic);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  sub _uric_escape {
      my($class, $str) = @_;
      if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os) {
  	my($scheme, $host, $rest) = ($1, $2, $3);
  	my $ui = $host =~ s/(.*@)// ? $1 : "";
  	my $port = $host =~ s/(:\d+)\z// ? $1 : "";
  	if (_host_escape($host)) {
  	    $str = "$scheme//$ui$host$port$rest";
  	}
      }
      return $class->SUPER::_uric_escape($str);
  }
  
  sub _host_escape {
      return unless $_[0] =~ /[^URI::uric]/;
      eval {
  	require URI::_idna;
  	$_[0] = URI::_idna::encode($_[0]);
      };
      return 0 if $@;
      return 1;
  }
  
  sub as_iri {
      my $self = shift;
      my $str = $self->SUPER::as_iri;
      if ($str =~ /\bxn--/) {
  	if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os) {
  	    my($scheme, $host, $rest) = ($1, $2, $3);
  	    my $ui = $host =~ s/(.*@)// ? $1 : "";
  	    my $port = $host =~ s/(:\d+)\z// ? $1 : "";
  	    require URI::_idna;
  	    $host = URI::_idna::decode($host);
  	    $str = "$scheme//$ui$host$port$rest";
  	}
      }
      return $str;
  }
  
  sub userinfo
  {
      my $self = shift;
      my $old = $self->authority;
  
      if (@_) {
  	my $new = $old;
  	$new = "" unless defined $new;
  	$new =~ s/.*@//;  # remove old stuff
  	my $ui = shift;
  	if (defined $ui) {
  	    $ui =~ s/@/%40/g;   # protect @
  	    $new = "$ui\@$new";
  	}
  	$self->authority($new);
      }
      return undef if !defined($old) || $old !~ /(.*)@/;
      return $1;
  }
  
  sub host
  {
      my $self = shift;
      my $old = $self->authority;
      if (@_) {
  	my $tmp = $old;
  	$tmp = "" unless defined $tmp;
  	my $ui = ($tmp =~ /(.*@)/) ? $1 : "";
  	my $port = ($tmp =~ /(:\d+)$/) ? $1 : "";
  	my $new = shift;
  	$new = "" unless defined $new;
  	if (length $new) {
  	    $new =~ s/[@]/%40/g;   # protect @
  	    if ($new =~ /^[^:]*:\d*\z/ || $new =~ /]:\d*\z/) {
  		$new =~ s/(:\d*)\z// || die "Assert";
  		$port = $1;
  	    }
  	    $new = "[$new]" if $new =~ /:/ && $new !~ /^\[/; # IPv6 address
  	    _host_escape($new);
  	}
  	$self->authority("$ui$new$port");
      }
      return undef unless defined $old;
      $old =~ s/.*@//;
      $old =~ s/:\d+$//;          # remove the port
      $old =~ s{^\[(.*)\]$}{$1};  # remove brackets around IPv6 (RFC 3986 3.2.2)
      return uri_unescape($old);
  }
  
  sub ihost
  {
      my $self = shift;
      my $old = $self->host(@_);
      if ($old =~ /(^|\.)xn--/) {
  	require URI::_idna;
  	$old = URI::_idna::decode($old);
      }
      return $old;
  }
  
  sub _port
  {
      my $self = shift;
      my $old = $self->authority;
      if (@_) {
  	my $new = $old;
  	$new =~ s/:\d*$//;
  	my $port = shift;
  	$new .= ":$port" if defined $port;
  	$self->authority($new);
      }
      return $1 if defined($old) && $old =~ /:(\d*)$/;
      return;
  }
  
  sub port
  {
      my $self = shift;
      my $port = $self->_port(@_);
      $port = $self->default_port if !defined($port) || $port eq "";
      $port;
  }
  
  sub host_port
  {
      my $self = shift;
      my $old = $self->authority;
      $self->host(shift) if @_;
      return undef unless defined $old;
      $old =~ s/.*@//;        # zap userinfo
      $old =~ s/:$//;         # empty port should be treated the same a no port
      $old .= ":" . $self->port unless $old =~ /:\d+$/;
      $old;
  }
  
  
  sub default_port { undef }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->SUPER::canonical;
      my $host = $other->host || "";
      my $port = $other->_port;
      my $uc_host = $host =~ /[A-Z]/;
      my $def_port = defined($port) && ($port eq "" ||
                                        $port == $self->default_port);
      if ($uc_host || $def_port) {
  	$other = $other->clone if $other == $self;
  	$other->host(lc $host) if $uc_host;
  	$other->port(undef)    if $def_port;
      }
      $other;
  }
  
  1;
URI__SERVER

$fatpacked{"URI/_userpass.pm"} = <<'URI__USERPASS';
  package URI::_userpass;
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  sub user
  {
      my $self = shift;
      my $info = $self->userinfo;
      if (@_) {
  	my $new = shift;
  	my $pass = defined($info) ? $info : "";
  	$pass =~ s/^[^:]*//;
  
  	if (!defined($new) && !length($pass)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined($new);
  	    $new =~ s/%/%25/g;
  	    $new =~ s/:/%3A/g;
  	    $self->userinfo("$new$pass");
  	}
      }
      return unless defined $info;
      $info =~ s/:.*//;
      uri_unescape($info);
  }
  
  sub password
  {
      my $self = shift;
      my $info = $self->userinfo;
      if (@_) {
  	my $new = shift;
  	my $user = defined($info) ? $info : "";
  	$user =~ s/:.*//;
  
  	if (!defined($new) && !length($user)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined($new);
  	    $new =~ s/%/%25/g;
  	    $self->userinfo("$user:$new");
  	}
      }
      return unless defined $info;
      return unless $info =~ s/^[^:]*://;
      uri_unescape($info);
  }
  
  1;
URI__USERPASS

$fatpacked{"URI/connect.pm"} = <<'URI_CONNECT';
  package URI::connect;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.09'; # VERSION
  
  use base 'URI::http';
  
  1;
  
URI_CONNECT

$fatpacked{"URI/data.pm"} = <<'URI_DATA';
  package URI::data;  # RFC 2397
  
  require URI;
  @ISA=qw(URI);
  
  use strict;
  
  use MIME::Base64 qw(encode_base64 decode_base64);
  use URI::Escape  qw(uri_unescape);
  
  sub media_type
  {
      my $self = shift;
      my $opaque = $self->opaque;
      $opaque =~ /^([^,]*),?/ or die;
      my $old = $1;
      my $base64;
      $base64 = $1 if $old =~ s/(;base64)$//i;
      if (@_) {
  	my $new = shift;
  	$new = "" unless defined $new;
  	$new =~ s/%/%25/g;
  	$new =~ s/,/%2C/g;
  	$base64 = "" unless defined $base64;
  	$opaque =~ s/^[^,]*,?/$new$base64,/;
  	$self->opaque($opaque);
      }
      return uri_unescape($old) if $old;  # media_type can't really be "0"
      "text/plain;charset=US-ASCII";      # default type
  }
  
  sub data
  {
      my $self = shift;
      my($enc, $data) = split(",", $self->opaque, 2);
      unless (defined $data) {
  	$data = "";
  	$enc  = "" unless defined $enc;
      }
      my $base64 = ($enc =~ /;base64$/i);
      if (@_) {
  	$enc =~ s/;base64$//i if $base64;
  	my $new = shift;
  	$new = "" unless defined $new;
  	my $uric_count = _uric_count($new);
  	my $urienc_len = $uric_count + (length($new) - $uric_count) * 3;
  	my $base64_len = int((length($new)+2) / 3) * 4;
  	$base64_len += 7;  # because of ";base64" marker
  	if ($base64_len < $urienc_len || $_[0]) {
  	    $enc .= ";base64";
  	    $new = encode_base64($new, "");
  	} else {
  	    $new =~ s/%/%25/g;
  	}
  	$self->opaque("$enc,$new");
      }
      return unless defined wantarray;
      $data = uri_unescape($data);
      return $base64 ? decode_base64($data) : $data;
  }
  
  # I could not find a better way to interpolate the tr/// chars from
  # a variable.
  my $ENC = $URI::uric;
  $ENC =~ s/%//;
  
  eval <<EOT; die $@ if $@;
  sub _uric_count
  {
      \$_[0] =~ tr/$ENC//;
  }
  EOT
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::data - URI that contains immediate data
  
  =head1 SYNOPSIS
  
   use URI;
  
   $u = URI->new("data:");
   $u->media_type("image/gif");
   $u->data(scalar(`cat camel.gif`));
   print "$u\n";
   open(XV, "|xv -") and print XV $u->data;
  
  =head1 DESCRIPTION
  
  The C<URI::data> class supports C<URI> objects belonging to the I<data>
  URI scheme.  The I<data> URI scheme is specified in RFC 2397.  It
  allows inclusion of small data items as "immediate" data, as if it had
  been included externally.  Examples:
  
    data:,Perl%20is%20good
  
    data:image/gif;base64,R0lGODdhIAAgAIAAAAAAAPj8+CwAAAAAI
      AAgAAAClYyPqcu9AJyCjtIKc5w5xP14xgeO2tlY3nWcajmZZdeJcG
      Kxrmimms1KMTa1Wg8UROx4MNUq1HrycMjHT9b6xKxaFLM6VRKzI+p
      KS9XtXpcbdun6uWVxJXA8pNPkdkkxhxc21LZHFOgD2KMoQXa2KMWI
      JtnE2KizVUkYJVZZ1nczBxXlFopZBtoJ2diXGdNUymmJdFMAADs=
  
  
  
  C<URI> objects belonging to the data scheme support the common methods
  (described in L<URI>) and the following two scheme-specific methods:
  
  =over 4
  
  =item $uri->media_type( [$new_media_type] )
  
  Can be used to get or set the media type specified in the
  URI.  If no media type is specified, then the default
  C<"text/plain;charset=US-ASCII"> is returned.
  
  =item $uri->data( [$new_data] )
  
  Can be used to get or set the data contained in the URI.
  The data is passed unescaped (in binary form).  The decision about
  whether to base64 encode the data in the URI is taken automatically,
  based on the encoding that produces the shorter URI string.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1998 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_DATA

$fatpacked{"URI/file.pm"} = <<'URI_FILE';
  package URI::file;
  
  use strict;
  use vars qw(@ISA $VERSION $DEFAULT_AUTHORITY %OS_CLASS);
  
  require URI::_generic;
  @ISA = qw(URI::_generic);
  $VERSION = "4.21";
  
  use URI::Escape qw(uri_unescape);
  
  $DEFAULT_AUTHORITY = "";
  
  # Map from $^O values to implementation classes.  The Unix
  # class is the default.
  %OS_CLASS = (
       os2     => "OS2",
       mac     => "Mac",
       MacOS   => "Mac",
       MSWin32 => "Win32",
       win32   => "Win32",
       msdos   => "FAT",
       dos     => "FAT",
       qnx     => "QNX",
  );
  
  sub os_class
  {
      my($OS) = shift || $^O;
  
      my $class = "URI::file::" . ($OS_CLASS{$OS} || "Unix");
      no strict 'refs';
      unless (%{"$class\::"}) {
  	eval "require $class";
  	die $@ if $@;
      }
      $class;
  }
  
  sub host { uri_unescape(shift->authority(@_)) }
  
  sub new
  {
      my($class, $path, $os) = @_;
      os_class($os)->new($path);
  }
  
  sub new_abs
  {
      my $class = shift;
      my $file = $class->new(@_);
      return $file->abs($class->cwd) unless $$file =~ /^file:/;
      $file;
  }
  
  sub cwd
  {
      my $class = shift;
      require Cwd;
      my $cwd = Cwd::cwd();
      $cwd = VMS::Filespec::unixpath($cwd) if $^O eq 'VMS';
      $cwd = $class->new($cwd);
      $cwd .= "/" unless substr($cwd, -1, 1) eq "/";
      $cwd;
  }
  
  sub canonical {
      my $self = shift;
      my $other = $self->SUPER::canonical;
  
      my $scheme = $other->scheme;
      my $auth = $other->authority;
      return $other if !defined($scheme) && !defined($auth);  # relative
  
      if (!defined($auth) ||
  	$auth eq "" ||
  	lc($auth) eq "localhost" ||
  	(defined($DEFAULT_AUTHORITY) && lc($auth) eq lc($DEFAULT_AUTHORITY))
         )
      {
  	# avoid cloning if $auth already match
  	if ((defined($auth) || defined($DEFAULT_AUTHORITY)) &&
  	    (!defined($auth) || !defined($DEFAULT_AUTHORITY) || $auth ne $DEFAULT_AUTHORITY)
  	   )
  	{
  	    $other = $other->clone if $self == $other;
  	    $other->authority($DEFAULT_AUTHORITY);
          }
      }
  
      $other;
  }
  
  sub file
  {
      my($self, $os) = @_;
      os_class($os)->file($self);
  }
  
  sub dir
  {
      my($self, $os) = @_;
      os_class($os)->dir($self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::file - URI that maps to local file names
  
  =head1 SYNOPSIS
  
   use URI::file;
   
   $u1 = URI->new("file:/foo/bar");
   $u2 = URI->new("foo/bar", "file");
   
   $u3 = URI::file->new($path);
   $u4 = URI::file->new("c:\\windows\\", "win32");
   
   $u1->file;
   $u1->file("mac");
  
  =head1 DESCRIPTION
  
  The C<URI::file> class supports C<URI> objects belonging to the I<file>
  URI scheme.  This scheme allows us to map the conventional file names
  found on various computer systems to the URI name space.  An old
  specification of the I<file> URI scheme is found in RFC 1738.  Some
  older background information is also in RFC 1630. There are no newer
  specifications as far as I know.
  
  If you simply want to construct I<file> URI objects from URI strings,
  use the normal C<URI> constructor.  If you want to construct I<file>
  URI objects from the actual file names used by various systems, then
  use one of the following C<URI::file> constructors:
  
  =over 4
  
  =item $u = URI::file->new( $filename, [$os] )
  
  Maps a file name to the I<file:> URI name space, creates a URI object
  and returns it.  The $filename is interpreted as belonging to the
  indicated operating system ($os), which defaults to the value of the
  $^O variable.  The $filename can be either absolute or relative, and
  the corresponding type of URI object for $os is returned.
  
  =item $u = URI::file->new_abs( $filename, [$os] )
  
  Same as URI::file->new, but makes sure that the URI returned
  represents an absolute file name.  If the $filename argument is
  relative, then the name is resolved relative to the current directory,
  i.e. this constructor is really the same as:
  
    URI::file->new($filename)->abs(URI::file->cwd);
  
  =item $u = URI::file->cwd
  
  Returns a I<file> URI that represents the current working directory.
  See L<Cwd>.
  
  =back
  
  The following methods are supported for I<file> URI (in addition to
  the common and generic methods described in L<URI>):
  
  =over 4
  
  =item $u->file( [$os] )
  
  Returns a file name.  It maps from the URI name space
  to the file name space of the indicated operating system.
  
  It might return C<undef> if the name can not be represented in the
  indicated file system.
  
  =item $u->dir( [$os] )
  
  Some systems use a different form for names of directories than for plain
  files.  Use this method if you know you want to use the name for
  a directory.
  
  =back
  
  The C<URI::file> module can be used to map generic file names to names
  suitable for the current system.  As such, it can work as a nice
  replacement for the C<File::Spec> module.  For instance, the following
  code translates the UNIX-style file name F<Foo/Bar.pm> to a name
  suitable for the local system:
  
    $file = URI::file->new("Foo/Bar.pm", "unix")->file;
    die "Can't map filename Foo/Bar.pm for $^O" unless defined $file;
    open(FILE, $file) || die "Can't open '$file': $!";
    # do something with FILE
  
  =head1 MAPPING NOTES
  
  Most computer systems today have hierarchically organized file systems.
  Mapping the names used in these systems to the generic URI syntax
  allows us to work with relative file URIs that behave as they should
  when resolved using the generic algorithm for URIs (specified in RFC
  2396).  Mapping a file name to the generic URI syntax involves mapping
  the path separator character to "/" and encoding any reserved
  characters that appear in the path segments of the file name.  If
  path segments consisting of the strings "." or ".." have a
  different meaning than what is specified for generic URIs, then these
  must be encoded as well.
  
  If the file system has device, volume or drive specifications as
  the root of the name space, then it makes sense to map them to the
  authority field of the generic URI syntax.  This makes sure that
  relative URIs can not be resolved "above" them, i.e. generally how
  relative file names work in those systems.
  
  Another common use of the authority field is to encode the host on which
  this file name is valid.  The host name "localhost" is special and
  generally has the same meaning as a missing or empty authority
  field.  This use is in conflict with using it as a device
  specification, but can often be resolved for device specifications
  having characters not legal in plain host names.
  
  File name to URI mapping in normally not one-to-one.  There are
  usually many URIs that map to any given file name.  For instance, an
  authority of "localhost" maps the same as a URI with a missing or empty
  authority.
  
  Example 1: The Mac classic (Mac OS 9 and earlier) used ":" as path separator,
  but not in the same way as a generic URI. ":foo" was a relative name.  "foo:bar"
  was an absolute name.  Also, path segments could contain the "/" character as well
  as the literal "." or "..".  So the mapping looks like this:
  
    Mac classic           URI
    ----------            -------------------
    :foo:bar     <==>     foo/bar
    :            <==>     ./
    ::foo:bar    <==>     ../foo/bar
    :::          <==>     ../../
    foo:bar      <==>     file:/foo/bar
    foo:bar:     <==>     file:/foo/bar/
    ..           <==>     %2E%2E
    <undef>      <==      /
    foo/         <==      file:/foo%2F
    ./foo.txt    <==      file:/.%2Ffoo.txt
  
  Note that if you want a relative URL, you *must* begin the path with a :.  Any
  path that begins with [^:] is treated as absolute.
  
  Example 2: The UNIX file system is easy to map, as it uses the same path
  separator as URIs, has a single root, and segments of "." and ".."
  have the same meaning.  URIs that have the character "\0" or "/" as
  part of any path segment can not be turned into valid UNIX file names.
  
    UNIX                  URI
    ----------            ------------------
    foo/bar      <==>     foo/bar
    /foo/bar     <==>     file:/foo/bar
    /foo/bar     <==      file://localhost/foo/bar
    file:         ==>     ./file:
    <undef>      <==      file:/fo%00/bar
    /            <==>     file:/
  
  =cut
  
  
  RFC 1630
  
     [...]
  
     There is clearly a danger of confusion that a link made to a local
     file should be followed by someone on a different system, with
     unexpected and possibly harmful results.  Therefore, the convention
     is that even a "file" URL is provided with a host part.  This allows
     a client on another system to know that it cannot access the file
     system, or perhaps to use some other local mechanism to access the
     file.
  
     The special value "localhost" is used in the host field to indicate
     that the filename should really be used on whatever host one is.
     This for example allows links to be made to files which are
     distributed on many machines, or to "your unix local password file"
     subject of course to consistency across the users of the data.
  
     A void host field is equivalent to "localhost".
  
  =head1 CONFIGURATION VARIABLES
  
  The following configuration variables influence how the class and its
  methods behave:
  
  =over
  
  =item %URI::file::OS_CLASS
  
  This hash maps OS identifiers to implementation classes.  You might
  want to add or modify this if you want to plug in your own file
  handler class.  Normally the keys should match the $^O values in use.
  
  If there is no mapping then the "Unix" implementation is used.
  
  =item $URI::file::DEFAULT_AUTHORITY
  
  This determine what "authority" string to include in absolute file
  URIs.  It defaults to "".  If you prefer verbose URIs you might set it
  to be "localhost".
  
  Setting this value to C<undef> force behaviour compatible to URI v1.31
  and earlier.  In this mode host names in UNC paths and drive letters
  are mapped to the authority component on Windows, while we produce
  authority-less URIs on Unix.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<URI>, L<File::Spec>, L<perlport>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1998,2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_FILE

$fatpacked{"URI/file/Base.pm"} = <<'URI_FILE_BASE';
  package URI::file::Base;
  
  use strict;
  use URI::Escape qw();
  
  sub new
  {
      my $class = shift;
      my $path  = shift;
      $path = "" unless defined $path;
  
      my($auth, $escaped_auth, $escaped_path);
  
      ($auth, $escaped_auth) = $class->_file_extract_authority($path);
      ($path, $escaped_path) = $class->_file_extract_path($path);
  
      if (defined $auth) {
  	$auth =~ s,%,%25,g unless $escaped_auth;
  	$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;
  	$auth = "//$auth";
  	if (defined $path) {
  	    $path = "/$path" unless substr($path, 0, 1) eq "/";
  	} else {
  	    $path = "";
  	}
      } else {
  	return undef unless defined $path;
  	$auth = "";
      }
  
      $path =~ s,([%;?]), URI::Escape::escape_char($1),eg unless $escaped_path;
      $path =~ s/\#/%23/g;
  
      my $uri = $auth . $path;
      $uri = "file:$uri" if substr($uri, 0, 1) eq "/";
  
      URI->new($uri, "file");
  }
  
  sub _file_extract_authority
  {
      my($class, $path) = @_;
      return undef unless $class->_file_is_absolute($path);
      return $URI::file::DEFAULT_AUTHORITY;
  }
  
  sub _file_extract_path
  {
      return undef;
  }
  
  sub _file_is_absolute
  {
      return 0;
  }
  
  sub _file_is_localhost
  {
      shift; # class
      my $host = lc(shift);
      return 1 if $host eq "localhost";
      eval {
  	require Net::Domain;
  	lc(Net::Domain::hostfqdn()) eq $host ||
  	lc(Net::Domain::hostname()) eq $host;
      };
  }
  
  sub file
  {
      undef;
  }
  
  sub dir
  {
      my $self = shift;
      $self->file(@_);
  }
  
  1;
URI_FILE_BASE

$fatpacked{"URI/file/FAT.pm"} = <<'URI_FILE_FAT';
  package URI::file::FAT;
  
  require URI::file::Win32;
  @ISA=qw(URI::file::Win32);
  
  sub fix_path
  {
      shift; # class
      for (@_) {
  	# turn it into 8.3 names
  	my @p = map uc, split(/\./, $_, -1);
  	return if @p > 2;     # more than 1 dot is not allowed
  	@p = ("") unless @p;  # split bug? (returns nothing when splitting "")
  	$_ = substr($p[0], 0, 8);
          if (@p > 1) {
  	    my $ext = substr($p[1], 0, 3);
  	    $_ .= ".$ext" if length $ext;
  	}
      }
      1;  # ok
  }
  
  1;
URI_FILE_FAT

$fatpacked{"URI/file/Mac.pm"} = <<'URI_FILE_MAC';
  package URI::file::Mac;
  
  require URI::file::Base;
  @ISA=qw(URI::file::Base);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  
  
  sub _file_extract_path
  {
      my $class = shift;
      my $path = shift;
  
      my @pre;
      if ($path =~ s/^(:+)//) {
  	if (length($1) == 1) {
  	    @pre = (".") unless length($path);
  	} else {
  	    @pre = ("..") x (length($1) - 1);
  	}
      } else { #absolute
  	$pre[0] = "";
      }
  
      my $isdir = ($path =~ s/:$//);
      $path =~ s,([%/;]), URI::Escape::escape_char($1),eg;
  
      my @path = split(/:/, $path, -1);
      for (@path) {
  	if ($_ eq "." || $_ eq "..") {
  	    $_ = "%2E" x length($_);
  	}
  	$_ = ".." unless length($_);
      }
      push (@path,"") if $isdir;
      (join("/", @pre, @path), 1);
  }
  
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my @path;
  
      my $auth = $uri->authority;
      if (defined $auth) {
  	if (lc($auth) ne "localhost" && $auth ne "") {
  	    my $u_auth = uri_unescape($auth);
  	    if (!$class->_file_is_localhost($u_auth)) {
  		# some other host (use it as volume name)
  		@path = ("", $auth);
  		# XXX or just return to make it illegal;
  	    }
  	}
      }
      my @ps = split("/", $uri->path, -1);
      shift @ps if @path;
      push(@path, @ps);
  
      my $pre = "";
      if (!@path) {
  	return;  # empty path; XXX return ":" instead?
      } elsif ($path[0] eq "") {
  	# absolute
  	shift(@path);
  	if (@path == 1) {
  	    return if $path[0] eq "";  # not root directory
  	    push(@path, "");           # volume only, effectively append ":"
  	}
  	@ps = @path;
  	@path = ();
          my $part;
  	for (@ps) {  #fix up "." and "..", including interior, in relatives
  	    next if $_ eq ".";
  	    $part = $_ eq ".." ? "" : $_;
  	    push(@path,$part);
  	}
  	if ($ps[-1] eq "..") {  #if this happens, we need another :
  	    push(@path,"");
  	}
  	
      } else {
  	$pre = ":";
  	@ps = @path;
  	@path = ();
          my $part;
  	for (@ps) {  #fix up "." and "..", including interior, in relatives
  	    next if $_ eq ".";
  	    $part = $_ eq ".." ? "" : $_;
  	    push(@path,$part);
  	}
  	if ($ps[-1] eq "..") {  #if this happens, we need another :
  	    push(@path,"");
  	}
  	
      }
      return unless $pre || @path;
      for (@path) {
  	s/;.*//;  # get rid of parameters
  	#return unless length; # XXX
  	$_ = uri_unescape($_);
  	return if /\0/;
  	return if /:/;  # Should we?
      }
      $pre . join(":", @path);
  }
  
  sub dir
  {
      my $class = shift;
      my $path = $class->file(@_);
      return unless defined $path;
      $path .= ":" unless $path =~ /:$/;
      $path;
  }
  
  1;
URI_FILE_MAC

$fatpacked{"URI/file/OS2.pm"} = <<'URI_FILE_OS2';
  package URI::file::OS2;
  
  require URI::file::Win32;
  @ISA=qw(URI::file::Win32);
  
  # The Win32 version translates k:/foo to file://k:/foo  (?!)
  # We add an empty host
  
  sub _file_extract_authority
  {
      my $class = shift;
      return $1 if $_[0] =~ s,^\\\\([^\\]+),,;  # UNC
      return $1 if $_[0] =~ s,^//([^/]+),,;     # UNC too?
  
      if ($_[0] =~ m#^[a-zA-Z]{1,2}:#) {	      # allow for ab: drives
  	return "";
      }
      return;
  }
  
  sub file {
    my $p = &URI::file::Win32::file;
    return unless defined $p;
    $p =~ s,\\,/,g;
    $p;
  }
  
  1;
URI_FILE_OS2

$fatpacked{"URI/file/QNX.pm"} = <<'URI_FILE_QNX';
  package URI::file::QNX;
  
  require URI::file::Unix;
  @ISA=qw(URI::file::Unix);
  
  use strict;
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
      # tidy path
      $path =~ s,(.)//+,$1/,g; # ^// is correct
      $path =~ s,(/\.)+/,/,g;
      $path = "./$path" if $path =~ m,^[^:/]+:,,; # look like "scheme:"
      $path;
  }
  
  1;
URI_FILE_QNX

$fatpacked{"URI/file/Unix.pm"} = <<'URI_FILE_UNIX';
  package URI::file::Unix;
  
  require URI::file::Base;
  @ISA=qw(URI::file::Base);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
  
      # tidy path
      $path =~ s,//+,/,g;
      $path =~ s,(/\.)+/,/,g;
      $path = "./$path" if $path =~ m,^[^:/]+:,,; # look like "scheme:"
  
      return $path;
  }
  
  sub _file_is_absolute {
      my($class, $path) = @_;
      return $path =~ m,^/,;
  }
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my @path;
  
      my $auth = $uri->authority;
      if (defined($auth)) {
  	if (lc($auth) ne "localhost" && $auth ne "") {
  	    $auth = uri_unescape($auth);
  	    unless ($class->_file_is_localhost($auth)) {
  		push(@path, "", "", $auth);
  	    }
  	}
      }
  
      my @ps = $uri->path_segments;
      shift @ps if @path;
      push(@path, @ps);
  
      for (@path) {
  	# Unix file/directory names are not allowed to contain '\0' or '/'
  	return undef if /\0/;
  	return undef if /\//;  # should we really?
      }
  
      return join("/", @path);
  }
  
  1;
URI_FILE_UNIX

$fatpacked{"URI/file/Win32.pm"} = <<'URI_FILE_WIN32';
  package URI::file::Win32;
  
  require URI::file::Base;
  @ISA=qw(URI::file::Base);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  sub _file_extract_authority
  {
      my $class = shift;
  
      return $class->SUPER::_file_extract_authority($_[0])
  	if defined $URI::file::DEFAULT_AUTHORITY;
  
      return $1 if $_[0] =~ s,^\\\\([^\\]+),,;  # UNC
      return $1 if $_[0] =~ s,^//([^/]+),,;     # UNC too?
  
      if ($_[0] =~ s,^([a-zA-Z]:),,) {
  	my $auth = $1;
  	$auth .= "relative" if $_[0] !~ m,^[\\/],;
  	return $auth;
      }
      return undef;
  }
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
      $path =~ s,\\,/,g;
      #$path =~ s,//+,/,g;
      $path =~ s,(/\.)+/,/,g;
  
      if (defined $URI::file::DEFAULT_AUTHORITY) {
  	$path =~ s,^([a-zA-Z]:),/$1,;
      }
  
      return $path;
  }
  
  sub _file_is_absolute {
      my($class, $path) = @_;
      return $path =~ m,^[a-zA-Z]:, || $path =~ m,^[/\\],;
  }
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my $auth = $uri->authority;
      my $rel; # is filename relative to drive specified in authority
      if (defined $auth) {
          $auth = uri_unescape($auth);
  	if ($auth =~ /^([a-zA-Z])[:|](relative)?/) {
  	    $auth = uc($1) . ":";
  	    $rel++ if $2;
  	} elsif (lc($auth) eq "localhost") {
  	    $auth = "";
  	} elsif (length $auth) {
  	    $auth = "\\\\" . $auth;  # UNC
  	}
      } else {
  	$auth = "";
      }
  
      my @path = $uri->path_segments;
      for (@path) {
  	return undef if /\0/;
  	return undef if /\//;
  	#return undef if /\\/;        # URLs with "\" is not uncommon
      }
      return undef unless $class->fix_path(@path);
  
      my $path = join("\\", @path);
      $path =~ s/^\\// if $rel;
      $path = $auth . $path;
      $path =~ s,^\\([a-zA-Z])[:|],\u$1:,;
  
      return $path;
  }
  
  sub fix_path { 1; }
  
  1;
URI_FILE_WIN32

$fatpacked{"URI/ftp.pm"} = <<'URI_FTP';
  package URI::ftp;
  
  require URI::_server;
  require URI::_userpass;
  @ISA=qw(URI::_server URI::_userpass);
  
  use strict;
  
  sub default_port { 21 }
  
  sub path { shift->path_query(@_) }  # XXX
  
  sub _user     { shift->SUPER::user(@_);     }
  sub _password { shift->SUPER::password(@_); }
  
  sub user
  {
      my $self = shift;
      my $user = $self->_user(@_);
      $user = "anonymous" unless defined $user;
      $user;
  }
  
  sub password
  {
      my $self = shift;
      my $pass = $self->_password(@_);
      unless (defined $pass) {
  	my $user = $self->user;
  	if ($user eq 'anonymous' || $user eq 'ftp') {
  	    # anonymous ftp login password
              # If there is no ftp anonymous password specified
              # then we'll just use 'anonymous@'
              # We don't try to send the read e-mail address because:
              # - We want to remain anonymous
              # - We want to stop SPAM
              # - We don't want to let ftp sites to discriminate by the user,
              #   host, country or ftp client being used.
  	    $pass = 'anonymous@';
  	}
      }
      $pass;
  }
  
  1;
URI_FTP

$fatpacked{"URI/gopher.pm"} = <<'URI_GOPHER';
  package URI::gopher;  # <draft-murali-url-gopher>, Dec 4, 1996
  
  require URI::_server;
  @ISA=qw(URI::_server);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  #  A Gopher URL follows the common internet scheme syntax as defined in 
  #  section 4.3 of [RFC-URL-SYNTAX]:
  #
  #        gopher://<host>[:<port>]/<gopher-path>
  #
  #  where
  #
  #        <gopher-path> :=  <gopher-type><selector> | 
  #                          <gopher-type><selector>%09<search> |
  #                          <gopher-type><selector>%09<search>%09<gopher+_string>
  #
  #        <gopher-type> := '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'
  #                         '8' | '9' | '+' | 'I' | 'g' | 'T'
  #
  #        <selector>    := *pchar     Refer to RFC 1808 [4]
  #        <search>      := *pchar
  #        <gopher+_string> := *uchar  Refer to RFC 1738 [3]
  #        
  #  If the optional port is omitted, the port defaults to 70. 
  
  sub default_port { 70 }
  
  sub _gopher_type
  {
      my $self = shift;
      my $path = $self->path_query;
      $path =~ s,^/,,;
      my $gtype = $1 if $path =~ s/^(.)//s;
      if (@_) {
  	my $new_type = shift;
  	if (defined($new_type)) {
  	    Carp::croak("Bad gopher type '$new_type'")
                 unless length($new_type) == 1;
  	    substr($path, 0, 0) = $new_type;
  	    $self->path_query($path);
  	} else {
  	    Carp::croak("Can't delete gopher type when selector is present")
  		if length($path);
  	    $self->path_query(undef);
  	}
      }
      return $gtype;
  }
  
  sub gopher_type
  {
      my $self = shift;
      my $gtype = $self->_gopher_type(@_);
      $gtype = "1" unless defined $gtype;
      $gtype;
  }
  
  *gtype = \&gopher_type;  # URI::URL compatibility
  
  sub selector { shift->_gfield(0, @_) }
  sub search   { shift->_gfield(1, @_) }
  sub string   { shift->_gfield(2, @_) }
  
  sub _gfield
  {
      my $self = shift;
      my $fno  = shift;
      my $path = $self->path_query;
  
      # not according to spec., but many popular browsers accept
      # gopher URLs with a '?' before the search string.
      $path =~ s/\?/\t/;
      $path = uri_unescape($path);
      $path =~ s,^/,,;
      my $gtype = $1 if $path =~ s,^(.),,s;
      my @path = split(/\t/, $path, 3);
      if (@_) {
  	# modify
  	my $new = shift;
  	$path[$fno] = $new;
  	pop(@path) while @path && !defined($path[-1]);
  	for (@path) { $_="" unless defined }
  	$path = $gtype;
  	$path = "1" unless defined $path;
  	$path .= join("\t", @path);
  	$self->path_query($path);
      }
      $path[$fno];
  }
  
  1;
URI_GOPHER

$fatpacked{"URI/http.pm"} = <<'URI_HTTP';
  package URI::http;
  
  require URI::_server;
  @ISA=qw(URI::_server);
  
  use strict;
  
  sub default_port { 80 }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->SUPER::canonical;
  
      my $slash_path = defined($other->authority) &&
          !length($other->path) && !defined($other->query);
  
      if ($slash_path) {
  	$other = $other->clone if $other == $self;
  	$other->path("/");
      }
      $other;
  }
  
  1;
URI_HTTP

$fatpacked{"URI/https.pm"} = <<'URI_HTTPS';
  package URI::https;
  require URI::http;
  @ISA=qw(URI::http);
  
  sub default_port { 443 }
  
  sub secure { 1 }
  
  1;
URI_HTTPS

$fatpacked{"URI/ldap.pm"} = <<'URI_LDAP';
  # Copyright (c) 1998 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package URI::ldap;
  
  use strict;
  
  use vars qw(@ISA $VERSION);
  $VERSION = "1.12";
  
  require URI::_server;
  require URI::_ldap;
  @ISA=qw(URI::_ldap URI::_server);
  
  sub default_port { 389 }
  
  sub _nonldap_canonical {
      my $self = shift;
      $self->URI::_server::canonical(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::ldap - LDAP Uniform Resource Locators
  
  =head1 SYNOPSIS
  
    use URI;
  
    $uri = URI->new("ldap:$uri_string");
    $dn     = $uri->dn;
    $filter = $uri->filter;
    @attr   = $uri->attributes;
    $scope  = $uri->scope;
    %extn   = $uri->extensions;
    
    $uri = URI->new("ldap:");  # start empty
    $uri->host("ldap.itd.umich.edu");
    $uri->dn("o=University of Michigan,c=US");
    $uri->attributes(qw(postalAddress));
    $uri->scope('sub');
    $uri->filter('(cn=Babs Jensen)');
    print $uri->as_string,"\n";
  
  =head1 DESCRIPTION
  
  C<URI::ldap> provides an interface to parse an LDAP URI into its
  constituent parts and also to build a URI as described in
  RFC 2255.
  
  =head1 METHODS
  
  C<URI::ldap> supports all the generic and server methods defined by
  L<URI>, plus the following.
  
  Each of the following methods can be used to set or get the value in
  the URI. The values are passed in unescaped form.  None of these
  return undefined values, but elements without a default can be empty.
  If arguments are given, then a new value is set for the given part
  of the URI.
  
  =over 4
  
  =item $uri->dn( [$new_dn] )
  
  Sets or gets the I<Distinguished Name> part of the URI.  The DN
  identifies the base object of the LDAP search.
  
  =item $uri->attributes( [@new_attrs] )
  
  Sets or gets the list of attribute names which are
  returned by the search.
  
  =item $uri->scope( [$new_scope] )
  
  Sets or gets the scope to be used by the search. The value can be one of
  C<"base">, C<"one"> or C<"sub">. If none is given in the URI then the
  return value defaults to C<"base">.
  
  =item $uri->_scope( [$new_scope] )
  
  Same as scope(), but does not default to anything.
  
  =item $uri->filter( [$new_filter] )
  
  Sets or gets the filter to be used by the search. If none is given in
  the URI then the return value defaults to C<"(objectClass=*)">.
  
  =item $uri->_filter( [$new_filter] )
  
  Same as filter(), but does not default to anything.
  
  =item $uri->extensions( [$etype => $evalue,...] )
  
  Sets or gets the extensions used for the search. The list passed should
  be in the form etype1 => evalue1, etype2 => evalue2,... This is also
  the form of list that is returned.
  
  =back
  
  =head1 SEE ALSO
  
  L<http://tools.ietf.org/html/rfc2255>
  
  =head1 AUTHOR
  
  Graham Barr E<lt>F<gbarr@pobox.com>E<gt>
  
  Slightly modified by Gisle Aas to fit into the URI distribution.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1998 Graham Barr. All rights reserved. This program is
  free software; you can redistribute it and/or modify it under the same
  terms as Perl itself.
  
  =cut
URI_LDAP

$fatpacked{"URI/ldapi.pm"} = <<'URI_LDAPI';
  package URI::ldapi;
  
  use strict;
  
  use vars qw(@ISA);
  
  require URI::_generic;
  require URI::_ldap;
  @ISA=qw(URI::_ldap URI::_generic);
  
  require URI::Escape;
  
  sub un_path {
      my $self = shift;
      my $old = URI::Escape::uri_unescape($self->authority);
      if (@_) {
  	my $p = shift;
  	$p =~ s/:/%3A/g;
  	$p =~ s/\@/%40/g;
  	$self->authority($p);
      }
      return $old;
  }
  
  sub _nonldap_canonical {
      my $self = shift;
      $self->URI::_generic::canonical(@_);
  }
  
  1;
URI_LDAPI

$fatpacked{"URI/ldaps.pm"} = <<'URI_LDAPS';
  package URI::ldaps;
  require URI::ldap;
  @ISA=qw(URI::ldap);
  
  sub default_port { 636 }
  
  sub secure { 1 }
  
  1;
URI_LDAPS

$fatpacked{"URI/mailto.pm"} = <<'URI_MAILTO';
  package URI::mailto;  # RFC 2368
  
  require URI;
  require URI::_query;
  @ISA=qw(URI URI::_query);
  
  use strict;
  
  sub to
  {
      my $self = shift;
      my @old = $self->headers;
      if (@_) {
  	my @new = @old;
  	# get rid of any other to: fields
  	for (my $i = 0; $i < @new; $i += 2) {
  	    if (lc($new[$i] || '') eq "to") {
  		splice(@new, $i, 2);
  		redo;
  	    }
  	}
  
  	my $to = shift;
  	$to = "" unless defined $to;
  	unshift(@new, "to" => $to);
  	$self->headers(@new);
      }
      return unless defined wantarray;
  
      my @to;
      while (@old) {
  	my $h = shift @old;
  	my $v = shift @old;
  	push(@to, $v) if lc($h) eq "to";
      }
      join(",", @to);
  }
  
  
  sub headers
  {
      my $self = shift;
  
      # The trick is to just treat everything as the query string...
      my $opaque = "to=" . $self->opaque;
      $opaque =~ s/\?/&/;
  
      if (@_) {
  	my @new = @_;
  
  	# strip out any "to" fields
  	my @to;
  	for (my $i=0; $i < @new; $i += 2) {
  	    if (lc($new[$i] || '') eq "to") {
  		push(@to, (splice(@new, $i, 2))[1]);  # remove header
  		redo;
  	    }
  	}
  
  	my $new = join(",",@to);
  	$new =~ s/%/%25/g;
  	$new =~ s/\?/%3F/g;
  	$self->opaque($new);
  	$self->query_form(@new) if @new;
      }
      return unless defined wantarray;
  
      # I am lazy today...
      URI->new("mailto:?$opaque")->query_form;
  }
  
  1;
URI_MAILTO

$fatpacked{"URI/mms.pm"} = <<'URI_MMS';
  package URI::mms;
  
  require URI::http;
  @ISA=qw(URI::http);
  
  sub default_port { 1755 }
  
  1;
URI_MMS

$fatpacked{"URI/news.pm"} = <<'URI_NEWS';
  package URI::news;  # draft-gilman-news-url-01
  
  require URI::_server;
  @ISA=qw(URI::_server);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  use Carp ();
  
  sub default_port { 119 }
  
  #   newsURL      =  scheme ":" [ news-server ] [ refbygroup | message ]
  #   scheme       =  "news" | "snews" | "nntp"
  #   news-server  =  "//" server "/"
  #   refbygroup   = group [ "/" messageno [ "-" messageno ] ]
  #   message      = local-part "@" domain
  
  sub _group
  {
      my $self = shift;
      my $old = $self->path;
      if (@_) {
  	my($group,$from,$to) = @_;
  	if ($group =~ /\@/) {
              $group =~ s/^<(.*)>$/$1/;  # "<" and ">" should not be part of it
  	}
  	$group =~ s,%,%25,g;
  	$group =~ s,/,%2F,g;
  	my $path = $group;
  	if (defined $from) {
  	    $path .= "/$from";
  	    $path .= "-$to" if defined $to;
  	}
  	$self->path($path);
      }
  
      $old =~ s,^/,,;
      if ($old !~ /\@/ && $old =~ s,/(.*),, && wantarray) {
  	my $extra = $1;
  	return (uri_unescape($old), split(/-/, $extra));
      }
      uri_unescape($old);
  }
  
  
  sub group
  {
      my $self = shift;
      if (@_) {
  	Carp::croak("Group name can't contain '\@'") if $_[0] =~ /\@/;
      }
      my @old = $self->_group(@_);
      return if $old[0] =~ /\@/;
      wantarray ? @old : $old[0];
  }
  
  sub message
  {
      my $self = shift;
      if (@_) {
  	Carp::croak("Message must contain '\@'") unless $_[0] =~ /\@/;
      }
      my $old = $self->_group(@_);
      return unless $old =~ /\@/;
      return $old;
  }
  
  1;
URI_NEWS

$fatpacked{"URI/nntp.pm"} = <<'URI_NNTP';
  package URI::nntp;  # draft-gilman-news-url-01
  
  require URI::news;
  @ISA=qw(URI::news);
  
  1;
URI_NNTP

$fatpacked{"URI/pop.pm"} = <<'URI_POP';
  package URI::pop;   # RFC 2384
  
  require URI::_server;
  @ISA=qw(URI::_server);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  sub default_port { 110 }
  
  #pop://<user>;auth=<auth>@<host>:<port>
  
  sub user
  {
      my $self = shift;
      my $old = $self->userinfo;
  
      if (@_) {
  	my $new_info = $old;
  	$new_info = "" unless defined $new_info;
  	$new_info =~ s/^[^;]*//;
  
  	my $new = shift;
  	if (!defined($new) && !length($new_info)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined $new;
  	    $new =~ s/%/%25/g;
  	    $new =~ s/;/%3B/g;
  	    $self->userinfo("$new$new_info");
  	}
      }
  
      return unless defined $old;
      $old =~ s/;.*//;
      return uri_unescape($old);
  }
  
  sub auth
  {
      my $self = shift;
      my $old = $self->userinfo;
  
      if (@_) {
  	my $new = $old;
  	$new = "" unless defined $new;
  	$new =~ s/(^[^;]*)//;
  	my $user = $1;
  	$new =~ s/;auth=[^;]*//i;
  
  	
  	my $auth = shift;
  	if (defined $auth) {
  	    $auth =~ s/%/%25/g;
  	    $auth =~ s/;/%3B/g;
  	    $new = ";AUTH=$auth$new";
  	}
  	$self->userinfo("$user$new");
  	
      }
  
      return unless defined $old;
      $old =~ s/^[^;]*//;
      return uri_unescape($1) if $old =~ /;auth=(.*)/i;
      return;
  }
  
  1;
URI_POP

$fatpacked{"URI/rlogin.pm"} = <<'URI_RLOGIN';
  package URI::rlogin;
  require URI::_login;
  @ISA = qw(URI::_login);
  
  sub default_port { 513 }
  
  1;
URI_RLOGIN

$fatpacked{"URI/rsync.pm"} = <<'URI_RSYNC';
  package URI::rsync;  # http://rsync.samba.org/
  
  # rsync://[USER@]HOST[:PORT]/SRC
  
  require URI::_server;
  require URI::_userpass;
  
  @ISA=qw(URI::_server URI::_userpass);
  
  sub default_port { 873 }
  
  1;
URI_RSYNC

$fatpacked{"URI/rtsp.pm"} = <<'URI_RTSP';
  package URI::rtsp;
  
  require URI::http;
  @ISA=qw(URI::http);
  
  sub default_port { 554 }
  
  1;
URI_RTSP

$fatpacked{"URI/rtspu.pm"} = <<'URI_RTSPU';
  package URI::rtspu;
  
  require URI::rtsp;
  @ISA=qw(URI::rtsp);
  
  sub default_port { 554 }
  
  1;
URI_RTSPU

$fatpacked{"URI/sip.pm"} = <<'URI_SIP';
  #
  # Written by Ryan Kereliuk <ryker@ryker.org>.  This file may be
  # distributed under the same terms as Perl itself.
  #
  # The RFC 3261 sip URI is <scheme>:<authority>;<params>?<query>.
  #
  
  package URI::sip;
  
  require URI::_server;
  require URI::_userpass;
  @ISA=qw(URI::_server URI::_userpass);
  
  use strict;
  use vars qw(@ISA $VERSION);
  use URI::Escape qw(uri_unescape);
  
  $VERSION = "0.11";
  
  sub default_port { 5060 }
  
  sub authority
  {
      my $self = shift;
      $$self =~ m,^($URI::scheme_re:)?([^;?]*)(.*)$,os or die;
      my $old = $2;
  
      if (@_) {
          my $auth = shift;
          $$self = defined($1) ? $1 : "";
          my $rest = $3;
          if (defined $auth) {
              $auth =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
              $$self .= "$auth";
          }
          $$self .= $rest;
      }
      $old;
  }
  
  sub params_form
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;
      my $paramstr = $3;
  
      if (@_) {
      	my @args = @_; 
          $$self = $1 . $2;
          my $rest = $4;
  	my @new;
  	for (my $i=0; $i < @args; $i += 2) {
  	    push(@new, "$args[$i]=$args[$i+1]");
  	}
  	$paramstr = join(";", @new);
  	$$self .= ";" . $paramstr . $rest;
      }
      $paramstr =~ s/^;//o;
      return split(/[;=]/, $paramstr);
  }
  
  sub params
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;
      my $paramstr = $3;
  
      if (@_) {
      	my $new = shift; 
          $$self = $1 . $2;
          my $rest = $4;
  	$$self .= $paramstr . $rest;
      }
      $paramstr =~ s/^;//o;
      return $paramstr;
  }
  
  # Inherited methods that make no sense for a SIP URI.
  sub path {}
  sub path_query {}
  sub path_segments {}
  sub abs { shift }
  sub rel { shift }
  sub query_keywords {}
  
  1;
URI_SIP

$fatpacked{"URI/sips.pm"} = <<'URI_SIPS';
  package URI::sips;
  require URI::sip;
  @ISA=qw(URI::sip);
  
  sub default_port { 5061 }
  
  sub secure { 1 }
  
  1;
URI_SIPS

$fatpacked{"URI/snews.pm"} = <<'URI_SNEWS';
  package URI::snews;  # draft-gilman-news-url-01
  
  require URI::news;
  @ISA=qw(URI::news);
  
  sub default_port { 563 }
  
  sub secure { 1 }
  
  1;
URI_SNEWS

$fatpacked{"URI/ssh.pm"} = <<'URI_SSH';
  package URI::ssh;
  require URI::_login;
  @ISA=qw(URI::_login);
  
  # ssh://[USER@]HOST[:PORT]/SRC
  
  sub default_port { 22 }
  
  sub secure { 1 }
  
  1;
URI_SSH

$fatpacked{"URI/telnet.pm"} = <<'URI_TELNET';
  package URI::telnet;
  require URI::_login;
  @ISA = qw(URI::_login);
  
  sub default_port { 23 }
  
  1;
URI_TELNET

$fatpacked{"URI/tn3270.pm"} = <<'URI_TN3270';
  package URI::tn3270;
  require URI::_login;
  @ISA = qw(URI::_login);
  
  sub default_port { 23 }
  
  1;
URI_TN3270

$fatpacked{"URI/urn.pm"} = <<'URI_URN';
  package URI::urn;  # RFC 2141
  
  require URI;
  @ISA=qw(URI);
  
  use strict;
  use Carp qw(carp);
  
  use vars qw(%implementor);
  
  sub _init {
      my $class = shift;
      my $self = $class->SUPER::_init(@_);
      my $nid = $self->nid;
  
      my $impclass = $implementor{$nid};
      return $impclass->_urn_init($self, $nid) if $impclass;
  
      $impclass = "URI::urn";
      if ($nid =~ /^[A-Za-z\d][A-Za-z\d\-]*\z/) {
  	my $id = $nid;
  	# make it a legal perl identifier
  	$id =~ s/-/_/g;
  	$id = "_$id" if $id =~ /^\d/;
  
  	$impclass = "URI::urn::$id";
  	no strict 'refs';
  	unless (@{"${impclass}::ISA"}) {
  	    # Try to load it
  	    eval "require $impclass";
  	    die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;
  	    $impclass = "URI::urn" unless @{"${impclass}::ISA"};
  	}
      }
      else {
  	carp("Illegal namespace identifier '$nid' for URN '$self'") if $^W;
      }
      $implementor{$nid} = $impclass;
  
      return $impclass->_urn_init($self, $nid);
  }
  
  sub _urn_init {
      my($class, $self, $nid) = @_;
      bless $self, $class;
  }
  
  sub _nid {
      my $self = shift;
      my $opaque = $self->opaque;
      if (@_) {
  	my $v = $opaque;
  	my $new = shift;
  	$v =~ s/[^:]*/$new/;
  	$self->opaque($v);
  	# XXX possible rebless
      }
      $opaque =~ s/:.*//s;
      return $opaque;
  }
  
  sub nid {  # namespace identifier
      my $self = shift;
      my $nid = $self->_nid(@_);
      $nid = lc($nid) if defined($nid);
      return $nid;
  }
  
  sub nss {  # namespace specific string
      my $self = shift;
      my $opaque = $self->opaque;
      if (@_) {
  	my $v = $opaque;
  	my $new = shift;
  	if (defined $new) {
  	    $v =~ s/(:|\z).*/:$new/;
  	}
  	else {
  	    $v =~ s/:.*//s;
  	}
  	$self->opaque($v);
      }
      return undef unless $opaque =~ s/^[^:]*://;
      return $opaque;
  }
  
  sub canonical {
      my $self = shift;
      my $nid = $self->_nid;
      my $new = $self->SUPER::canonical;
      return $new if $nid !~ /[A-Z]/ || $nid =~ /%/;
      $new = $new->clone if $new == $self;
      $new->nid(lc($nid));
      return $new;
  }
  
  1;
URI_URN

$fatpacked{"URI/urn/isbn.pm"} = <<'URI_URN_ISBN';
  package URI::urn::isbn;  # RFC 3187
  
  require URI::urn;
  @ISA=qw(URI::urn);
  
  use strict;
  use Carp qw(carp);
  
  BEGIN {
      require Business::ISBN;
      
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      warn "Using Business::ISBN version " . Business::ISBN->VERSION . 
          " which is deprecated.\nUpgrade to Business::ISBN version 2\n"
          if Business::ISBN->VERSION < 2;
      }
      
  sub _isbn {
      my $nss = shift;
      $nss = $nss->nss if ref($nss);
      my $isbn = Business::ISBN->new($nss);
      $isbn = undef if $isbn && !$isbn->is_valid;
      return $isbn;
  }
  
  sub _nss_isbn {
      my $self = shift;
      my $nss = $self->nss(@_);
      my $isbn = _isbn($nss);
      $isbn = $isbn->as_string if $isbn;
      return($nss, $isbn);
  }
  
  sub isbn {
      my $self = shift;
      my $isbn;
      (undef, $isbn) = $self->_nss_isbn(@_);
      return $isbn;
  }
  
  sub isbn_publisher_code {
      my $isbn = shift->_isbn || return undef;
      return $isbn->publisher_code;
  }
  
  BEGIN {
  my $group_method = do {
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      Business::ISBN->VERSION >= 2 ? 'group_code' : 'country_code';
      };
  
  sub isbn_group_code {
      my $isbn = shift->_isbn || return undef;
      return $isbn->$group_method;
  }
  }
  
  sub isbn_country_code {
      my $name = (caller(0))[3]; $name =~ s/.*:://;
      carp "$name is DEPRECATED. Use isbn_group_code instead";
      
      no strict 'refs';
      &isbn_group_code;
  }
  
  BEGIN {
  my $isbn13_method = do {
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      Business::ISBN->VERSION >= 2 ? 'as_isbn13' : 'as_ean';
      };
  
  sub isbn13 {
      my $isbn = shift->_isbn || return undef;
      
      # Business::ISBN 1.x didn't put hyphens in the EAN, and it was just a string
      # Business::ISBN 2.0 doesn't do EAN, but it does ISBN-13 objects
      #   and it uses the hyphens, so call as_string with an empty anon array
      # or, adjust the test and features to say that it comes out with hyphens.
      my $thingy = $isbn->$isbn13_method;
      return eval { $thingy->can( 'as_string' ) } ? $thingy->as_string([]) : $thingy;
  }
  }
  
  sub isbn_as_ean {
      my $name = (caller(0))[3]; $name =~ s/.*:://;
      carp "$name is DEPRECATED. Use isbn13 instead";
  
      no strict 'refs';
      &isbn13;
  }
  
  sub canonical {
      my $self = shift;
      my($nss, $isbn) = $self->_nss_isbn;
      my $new = $self->SUPER::canonical;
      return $new unless $nss && $isbn && $nss ne $isbn;
      $new = $new->clone if $new == $self;
      $new->nss($isbn);
      return $new;
  }
  
  1;
URI_URN_ISBN

$fatpacked{"URI/urn/oid.pm"} = <<'URI_URN_OID';
  package URI::urn::oid;  # RFC 2061
  
  require URI::urn;
  @ISA=qw(URI::urn);
  
  use strict;
  
  sub oid {
      my $self = shift;
      my $old = $self->nss;
      if (@_) {
  	$self->nss(join(".", @_));
      }
      return split(/\./, $old) if wantarray;
      return $old;
  }
  
  1;
URI_URN_OID

$fatpacked{"bdatum/Constants.pm"} = <<'BDATUM_CONSTANTS';
  
  package bdatum::Constants;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.01';
  
  use constant BASE_URL => $ENV{'BDATUM_BASE_URL'} || 'https://api.b-datum.com';
  use constant BASE_DIR => "$ENV{HOME}/.b-datum";
  
  use constant LIMIT_PARTS => 10000;
  
  use constant MTIME   => 0;
  use constant ETAG    => 1;
  use constant UID     => 2;
  use constant GID     => 3;
  use constant UMASK   => 4;
  use constant SYMLINK => 5;
  
  # Status code for alive
  # 1xx - Status
  # 2xx - Success
  # 3xx - Local Error
  # 4xx - Setup Error
  
  use constant ONLINE => 100;              # I'm here
  use constant BACKUP => 101;              # Doing..
  use constant TOO_MANY_TRY => 111;        # Too many times try to send something.
  
  use constant OK_ALL => 200;              # Withour problem
  use constant OK_UPDATE_CONFIG => 201;    # Configurao atualizada
  
  use constant ERR_PERM_ETC => 301;        # Please run 'chmod 0400 /configfile'
  use constant ERR_NO_PATH => 302;         # No path information
  use constant ERR_PATH_PERM => 303;       # Path without permission to backup
  use constant ERR_FILE_PERM => 304;       # No permission to a file
  use constant ERR_NO_PERL_S3 => 340;      # need to install Net::Amazon::S3
  
  use constant ERR_PART_SIZE => 401;       # part_size option need to be > 5 or < 500
  use constant ERR_PATH => 402;            # No path to backup
  
  require Exporter;
  
  our @ISA         = qw(Exporter);
  our %EXPORT_TAGS = (
    all => [
      qw/
        BASE_URL BASE_DIR LIMIT_PARTS
        MTIME ETAG UID GID UMASK SYMLINK
        /
    ]
  );
  
  our @EXPORT_OK = @{ $EXPORT_TAGS{'all'} };
  our @EXPORT    = qw();
  
  1;
  
BDATUM_CONSTANTS

$fatpacked{"bdatum/Util.pm"} = <<'BDATUM_UTIL';
  
  package bdatum::Util;
  
  use strict;
  use warnings;
  use Digest::MD5 qw(md5_hex);
  
  use bdatum::Constants ':all';
  use Module::Load::Conditional qw(can_load);
  
  # Yes, Fedora don't have any workaround for syslog.
  our $can_syslog = 0;
  if ( can_load( modules => { 'Sys::Syslog' => undef } ) ) {
    use Sys::Syslog qw(:standard :macros);
    $can_syslog = 1;
  }
  
  sub new {
    my $class = shift;
    my $self  = {
      _debug  => shift,
      _daemon => shift,
    };
    bless $self, $class;
    return $self;
  }
  
  sub disable_log {
    shift->{_disable_log} = 1;
  }
  
  sub set_debug {
    my ( $self, $value ) = @_;
    $self->{_debug} = $value;
  }
  
  sub set_daemon {
    my ( $self, $value ) = @_;
    $self->{_daemon} = $value;
  }
  
  sub set_node_key {
    my ( $self, $value ) = @_;
    $self->{node_key} = $value;
  }
  
  sub set_partner_key {
    my ( $self, $value ) = @_;
    $self->{partner_key} = $value;
  }
  
  sub set_path {
    my ( $self, $value ) = @_;
    $self->{path} = $value;
  }
  
  sub validate_key {
    my $self = shift;
    my $key  = shift || $self->log_error( "Invalid partner or node key", 64 );
    my $val  = $key =~ /^[a-zA-Z0-9]{20}$/ ? 1 : 0;
    $self->log_error("The key must be [a-zA-Z0-9]{20} -- $key") unless $val;
    return $val;
  }
  
  sub validate_path {
    my $self = shift;
    my $path = shift || return 0;
    map {
      my $path = $_;
      my $val = -d $path and -r $path;
      $self->log_error("The directory name is invalid -- $path") unless $val;
    } split /;/, $path;
  
    return $path;
  }
  
  sub validate_basedir {
    my $self = shift;
    my $path = shift || return 0;
    my $ok   = ( -d $path ) && ( -w $path );
  
    if ( !$ok ) {
      $self->log_error(
        "The directory does not exist or is not writable -- $path");
      $self->log_error( "Required option missing: --basedir", 64 );
    }
  
    return $ok;
  }
  
  sub make_control_file {
    my ( $self, $suffix ) = @_;
  
    if ( !$self->{node_key} or !$self->{partner_key} or !$self->{path} ) {
      $self->log_error(
  "Please, set the path, node_key and partner_key to make control file for $suffix",
        64
      );
      return;
    }
  
    my $base =
      md5_hex( $self->{node_key} . $self->{partner_key} . $self->{path} );
    return join( '/', BASE_DIR, "$base.$suffix" );
  }
  
  sub _log {
    my $self = shift;
    return if $self->{_disable_log};
  
    my $level = shift;
    my $msg = join( ' ', @_ );
  
    print "[$level] $msg\n" unless $self->{_daemon};
  
    return unless $can_syslog;
  
    my $syslog_level = LOG_INFO;
    $syslog_level = LOG_DEBUG   if $level eq 'debug';
    $syslog_level = LOG_WARNING if $level eq 'warn';
    $syslog_level = LOG_ERR     if $level eq 'error';
  
    openlog( $0, 'pid', LOG_USER );
    syslog( $syslog_level, "[$level] $msg" );
    closelog();
  
    return 1;
  }
  
  sub log_debug {
    my $self = shift;
    return unless $self->{_debug};
    return $self->_log( 'debug', @_ );
  }
  
  sub log_error {
    my ( $self, $msg, $exit ) = @_;
    $self->_log( 'error', $msg );
    return if $self->{_disable_log};
    exit $exit if $exit;
  }
  
  sub log_info {
    my $self = shift;
    return $self->_log( 'info', @_ );
  }
  
  sub log_warn {
    my $self = shift;
    return $self->_log( 'warn', @_ );
  }
  
  1;
BDATUM_UTIL

$fatpacked{"experimental.pm"} = <<'EXPERIMENTAL';
  package experimental;
  $experimental::VERSION = '0.008';
  use strict;
  use warnings;
  use version ();
  
  use feature ();
  use Carp qw/croak carp/;
  
  my %warnings = map { $_ => 1 } grep { /^experimental::/ } keys %warnings::Offsets;
  my %features = map { $_ => 1 } keys %feature::feature;
  
  my %min_version = (
  	array_base    => version->new('5'),
  	autoderef     => version->new('5.14.0'),
  	lexical_topic => version->new('5.10.0'),
  	regex_sets    => version->new('5.18.0'),
  	smartmatch    => version->new('5.10.1'),
  	signatures    => version->new('5.20.0'),
  );
  
  my %additional = (
  	postderef  => ['postderef_qq'],
  	switch     => ['smartmatch'],
  );
  
  sub _enable {
  	my $pragma = shift;
  	if ($warnings{"experimental::$pragma"}) {
  		warnings->unimport("experimental::$pragma");
  		feature->import($pragma) if exists $features{$pragma};
  		_enable(@{ $additional{$pragma} }) if $additional{$pragma};
  	}
  	elsif ($features{$pragma}) {
  		feature->import($pragma);
  		_enable(@{ $additional{$pragma} }) if $additional{$pragma};
  	}
  	elsif (not exists $min_version{$pragma}) {
  		croak "Can't enable unknown feature $pragma";
  	}
  	elsif ($min_version{$pragma} > $]) {
  		croak "Need perl $min_version{$pragma} or later for feature $pragma";
  	}
  }
  
  sub import {
  	my ($self, @pragmas) = @_;
  
  	for my $pragma (@pragmas) {
  		_enable($pragma);
  	}
  	return;
  }
  
  sub _disable {
  	my $pragma = shift;
  	if ($warnings{"experimental::$pragma"}) {
  		warnings->import("experimental::$pragma");
  		feature->unimport($pragma) if exists $features{$pragma};
  		_disable(@{ $additional{$pragma} }) if $additional{$pragma};
  	}
  	elsif ($features{$pragma}) {
  		feature->unimport($pragma);
  		_disable(@{ $additional{$pragma} }) if $additional{$pragma};
  	}
  	elsif (not exists $min_version{$pragma}) {
  		carp "Can't disable unknown feature $pragma, ignoring";
  	}
  }
  
  sub unimport {
  	my ($self, @pragmas) = @_;
  
  	for my $pragma (@pragmas) {
  		_disable($pragma);
  	}
  	return;
  }
  
  1;
  
  #ABSTRACT: Experimental features made easy
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  experimental - Experimental features made easy
  
  =head1 VERSION
  
  version 0.008
  
  =head1 SYNOPSIS
  
   use experimental 'lexical_subs', 'smartmatch';
   my sub foo { $_[0] ~~ 1 }
  
  =head1 DESCRIPTION
  
  This pragma provides an easy and convenient way to enable or disable
  experimental features.
  
  Every version of perl has some number of features present but considered
  "experimental."  For much of the life of Perl 5, this was only a designation
  found in the documentation.  Starting in Perl v5.10.0, and more aggressively in
  v5.18.0, experimental features were placed behind pragmata used to enable the
  feature and disable associated warnings.
  
  The C<experimental> pragma exists to combine the required incantations into a
  single interface stable across releases of perl.  For every experimental
  feature, this should enable the feature and silence warnings for the enclosing
  lexical scope:
  
    use experimental 'feature-name';
  
  To disable the feature and, if applicable, re-enable any warnings, use:
  
    no experimental 'feature-name';
  
  The supported features, documented further below, are:
  
  	array_base    - allow the use of $[ to change the starting index of @array
  	autoderef     - allow push, each, keys, and other built-ins on references
  	lexical_topic - allow the use of lexical $_ via "my $_"
  	postderef     - allow the use of postfix dereferencing expressions, including
  	                in interpolating strings
  	regex_sets    - allow extended bracketed character classes in regexps
  	signatures    - allow subroutine signatures (for named arguments)
  	smartmatch    - allow the use of ~~
  	switch        - allow the use of ~~, given, and when
  
  =head2 Disclaimer
  
  Because of the nature of the features it enables, forward compatibility can not
  be guaranteed in any way.
  
  =head1 AUTHOR
  
  Leon Timmermans <leont@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Leon Timmermans.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
EXPERIMENTAL

$fatpacked{"version.pm"} = <<'VERSION';
  #!perl -w
  package version;
  
  use 5.005_04;
  use strict;
  
  use vars qw(@ISA $VERSION $CLASS $STRICT $LAX *declare *qv);
  
  $VERSION = 0.9904;
  
  $CLASS = 'version';
  
  #--------------------------------------------------------------------------#
  # Version regexp components
  #--------------------------------------------------------------------------#
  
  # Fraction part of a decimal version number.  This is a common part of
  # both strict and lax decimal versions
  
  my $FRACTION_PART = qr/\.[0-9]+/;
  
  # First part of either decimal or dotted-decimal strict version number.
  # Unsigned integer with no leading zeroes (except for zero itself) to
  # avoid confusion with octal.
  
  my $STRICT_INTEGER_PART = qr/0|[1-9][0-9]*/;
  
  # First part of either decimal or dotted-decimal lax version number.
  # Unsigned integer, but allowing leading zeros.  Always interpreted
  # as decimal.  However, some forms of the resulting syntax give odd
  # results if used as ordinary Perl expressions, due to how perl treats
  # octals.  E.g.
  #   version->new("010" ) == 10
  #   version->new( 010  ) == 8
  #   version->new( 010.2) == 82  # "8" . "2"
  
  my $LAX_INTEGER_PART = qr/[0-9]+/;
  
  # Second and subsequent part of a strict dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.
  # Limited to three digits to avoid overflow when converting to decimal
  # form and also avoid problematic style with excessive leading zeroes.
  
  my $STRICT_DOTTED_DECIMAL_PART = qr/\.[0-9]{1,3}/;
  
  # Second and subsequent part of a lax dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.  No
  # limit on the numerical value or number of digits, so there is the
  # possibility of overflow when converting to decimal form.
  
  my $LAX_DOTTED_DECIMAL_PART = qr/\.[0-9]+/;
  
  # Alpha suffix part of lax version number syntax.  Acts like a
  # dotted-decimal part.
  
  my $LAX_ALPHA_PART = qr/_[0-9]+/;
  
  #--------------------------------------------------------------------------#
  # Strict version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Strict decimal version number.
  
  my $STRICT_DECIMAL_VERSION =
      qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;
  
  # Strict dotted-decimal version number.  Must have both leading "v" and
  # at least three parts, to avoid confusion with decimal syntax.
  
  my $STRICT_DOTTED_DECIMAL_VERSION =
      qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;
  
  # Complete strict version number syntax -- should generally be used
  # anchored: qr/ \A $STRICT \z /x
  
  $STRICT =
      qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  # Lax version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Lax decimal version number.  Just like the strict one except for
  # allowing an alpha suffix or allowing a leading or trailing
  # decimal-point
  
  my $LAX_DECIMAL_VERSION =
      qr/ $LAX_INTEGER_PART (?: \. | $FRACTION_PART $LAX_ALPHA_PART? )?
  	|
  	$FRACTION_PART $LAX_ALPHA_PART?
      /x;
  
  # Lax dotted-decimal version number.  Distinguished by having either
  # leading "v" or at least three non-alpha parts.  Alpha part is only
  # permitted if there are at least two non-alpha parts. Strangely
  # enough, without the leading "v", Perl takes .1.2 to mean v0.1.2,
  # so when there is no "v", the leading part is optional
  
  my $LAX_DOTTED_DECIMAL_VERSION =
      qr/
  	v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
  	|
  	$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
      /x;
  
  # Complete lax version number syntax -- should generally be used
  # anchored: qr/ \A $LAX \z /x
  #
  # The string 'undef' is a special case to make for easier handling
  # of return values from ExtUtils::MM->parse_version
  
  $LAX =
      qr/ undef | $LAX_DECIMAL_VERSION | $LAX_DOTTED_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  
  {
      local $SIG{'__DIE__'};
      eval "use version::vxs $VERSION";
      if ( $@ ) { # don't have the XS version installed
  	eval "use version::vpp $VERSION"; # don't tempt fate
  	die "$@" if ( $@ );
  	push @ISA, "version::vpp";
  	local $^W;
  	*version::qv = \&version::vpp::qv;
  	*version::declare = \&version::vpp::declare;
  	*version::_VERSION = \&version::vpp::_VERSION;
  	*version::vcmp = \&version::vpp::vcmp;
  	*version::new = \&version::vpp::new;
  	if ($] >= 5.009000) {
  	    no strict 'refs';
  	    *version::stringify = \&version::vpp::stringify;
  	    *{'version::(""'} = \&version::vpp::stringify;
  	    *{'version::(<=>'} = \&version::vpp::vcmp;
  	    *version::parse = \&version::vpp::parse;
  	}
      }
      else { # use XS module
  	push @ISA, "version::vxs";
  	local $^W;
  	*version::declare = \&version::vxs::declare;
  	*version::qv = \&version::vxs::qv;
  	*version::_VERSION = \&version::vxs::_VERSION;
  	*version::vcmp = \&version::vxs::VCMP;
  	*version::new = \&version::vxs::new;
  	if ($] >= 5.009000) {
  	    no strict 'refs';
  	    *version::stringify = \&version::vxs::stringify;
  	    *{'version::(""'} = \&version::vxs::stringify;
  	    *{'version::(<=>'} = \&version::vxs::VCMP;
  	    *version::parse = \&version::vxs::parse;
  	}
  
      }
  }
  
  # Preloaded methods go here.
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq 'version') {
  	local $^W;
  	*{$class.'::declare'} =  \&version::declare;
  	*{$class.'::qv'} = \&version::qv;
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
  	map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
  	%args =
  	(
  	    qv => 1,
  	    'UNIVERSAL::VERSION' => 1,
  	);
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
  	*{$callpkg.'::declare'} =
  	    sub {return $class->declare(shift) }
  	  unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
  	*{$callpkg.'::qv'} =
  	    sub {return $class->qv(shift) }
  	  unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
  	local $^W;
  	*UNIVERSAL::VERSION
  		= \&version::_VERSION;
      }
  
      if (exists($args{'VERSION'})) {
  	*{$callpkg.'::VERSION'} = \&version::_VERSION;
      }
  
      if (exists($args{'is_strict'})) {
  	*{$callpkg.'::is_strict'} = \&version::is_strict
  	  unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
  	*{$callpkg.'::is_lax'} = \&version::is_lax
  	  unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  sub is_strict	{ defined $_[0] && $_[0] =~ qr/ \A $STRICT \z /x }
  sub is_lax	{ defined $_[0] && $_[0] =~ qr/ \A $LAX \z /x }
  
  1;
VERSION

$fatpacked{"version/vpp.pm"} = <<'VERSION_VPP';
  package charstar;
  # a little helper class to emulate C char* semantics in Perl
  # so that prescan_version can use the same code as in C
  
  use overload (
      '""'	=> \&thischar,
      '0+'	=> \&thischar,
      '++'	=> \&increment,
      '--'	=> \&decrement,
      '+'		=> \&plus,
      '-'		=> \&minus,
      '*'		=> \&multiply,
      'cmp'	=> \&cmp,
      '<=>'	=> \&spaceship,
      'bool'	=> \&thischar,
      '='		=> \&clone,
  );
  
  sub new {
      my ($self, $string) = @_;
      my $class = ref($self) || $self;
  
      my $obj = {
  	string  => [split(//,$string)],
  	current => 0,
      };
      return bless $obj, $class;
  }
  
  sub thischar {
      my ($self) = @_;
      my $last = $#{$self->{string}};
      my $curr = $self->{current};
      if ($curr >= 0 && $curr <= $last) {
  	return $self->{string}->[$curr];
      }
      else {
  	return '';
      }
  }
  
  sub increment {
      my ($self) = @_;
      $self->{current}++;
  }
  
  sub decrement {
      my ($self) = @_;
      $self->{current}--;
  }
  
  sub plus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} += $offset;
      return $rself;
  }
  
  sub minus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} -= $offset;
      return $rself;
  }
  
  sub multiply {
      my ($left, $right, $swapped) = @_;
      my $char = $left->thischar();
      return $char * $right;
  }
  
  sub spaceship {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	$right = $left->new($right);
      }
      return $left->{current} <=> $right->{current};
  }
  
  sub cmp {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	if (length($right) == 1) { # comparing single character only
  	    return $left->thischar cmp $right;
  	}
  	$right = $left->new($right);
      }
      return $left->currstr cmp $right->currstr;
  }
  
  sub bool {
      my ($self) = @_;
      my $char = $self->thischar;
      return ($char ne '');
  }
  
  sub clone {
      my ($left, $right, $swapped) = @_;
      $right = {
  	string  => [@{$left->{string}}],
  	current => $left->{current},
      };
      return bless $right, ref($left);
  }
  
  sub currstr {
      my ($self, $s) = @_;
      my $curr = $self->{current};
      my $last = $#{$self->{string}};
      if (defined($s) && $s->{current} < $last) {
  	$last = $s->{current};
      }
  
      my $string = join('', @{$self->{string}}[$curr..$last]);
      return $string;
  }
  
  package version::vpp;
  use strict;
  
  use POSIX qw/locale_h/;
  use locale;
  use vars qw ($VERSION @ISA @REGEXS);
  $VERSION = 0.9904;
  
  use overload (
      '""'       => \&stringify,
      '0+'       => \&numify,
      'cmp'      => \&vcmp,
      '<=>'      => \&vcmp,
      'bool'     => \&vbool,
      '+'        => \&vnoop,
      '-'        => \&vnoop,
      '*'        => \&vnoop,
      '/'        => \&vnoop,
      '+='        => \&vnoop,
      '-='        => \&vnoop,
      '*='        => \&vnoop,
      '/='        => \&vnoop,
      'abs'      => \&vnoop,
  );
  
  eval "use warnings";
  if ($@) {
      eval '
  	package
  	warnings;
  	sub enabled {return $^W;}
  	1;
      ';
  }
  
  my $VERSION_MAX = 0x7FFFFFFF;
  
  # implement prescan_version as closely to the C version as possible
  use constant TRUE  => 1;
  use constant FALSE => 0;
  
  sub isDIGIT {
      my ($char) = shift->thischar();
      return ($char =~ /\d/);
  }
  
  sub isALPHA {
      my ($char) = shift->thischar();
      return ($char =~ /[a-zA-Z]/);
  }
  
  sub isSPACE {
      my ($char) = shift->thischar();
      return ($char =~ /\s/);
  }
  
  sub BADVERSION {
      my ($s, $errstr, $error) = @_;
      if ($errstr) {
  	$$errstr = $error;
      }
      return $s;
  }
  
  sub prescan_version {
      my ($s, $strict, $errstr, $sqv, $ssaw_decimal, $swidth, $salpha) = @_;
      my $qv          = defined $sqv          ? $$sqv          : FALSE;
      my $saw_decimal = defined $ssaw_decimal ? $$ssaw_decimal : 0;
      my $width       = defined $swidth       ? $$swidth       : 3;
      my $alpha       = defined $salpha       ? $$salpha       : FALSE;
  
      my $d = $s;
  
      if ($qv && isDIGIT($d)) {
  	goto dotted_decimal_version;
      }
  
      if ($d eq 'v') { # explicit v-string
  	$d++;
  	if (isDIGIT($d)) {
  	    $qv = TRUE;
  	}
  	else { # degenerate v-string
  	    # requires v1.2.3
  	    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	}
  
  dotted_decimal_version:
  	if ($strict && $d eq '0' && isDIGIT($d+1)) {
  	    # no leading zeros allowed
  	    return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	}
  
  	while (isDIGIT($d)) { 	# integer part
  	    $d++;
  	}
  
  	if ($d eq '.')
  	{
  	    $saw_decimal++;
  	    $d++; 		# decimal point
  	}
  	else
  	{
  	    if ($strict) {
  		# require v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	    else {
  		goto version_prescan_finish;
  	    }
  	}
  
  	{
  	    my $i = 0;
  	    my $j = 0;
  	    while (isDIGIT($d)) {	# just keep reading
  		$i++;
  		while (isDIGIT($d)) {
  		    $d++; $j++;
  		    # maximum 3 digits between decimal
  		    if ($strict && $j > 3) {
  			return BADVERSION($s,$errstr,"Invalid version format (maximum 3 digits between decimals)");
  		    }
  		}
  		if ($d eq '_') {
  		    if ($strict) {
  			return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		    }
  		    if ( $alpha ) {
  			return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		    }
  		    $d++;
  		    $alpha = TRUE;
  		}
  		elsif ($d eq '.') {
  		    if ($alpha) {
  			return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		    }
  		    $saw_decimal++;
  		    $d++;
  		}
  		elsif (!isDIGIT($d)) {
  		    last;
  		}
  		$j = 0;
  	    }
  
  	    if ($strict && $i < 2) {
  		# requires v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	}
      } 					# end if dotted-decimal
      else
      {					# decimal versions
  	my $j = 0;
  	# special $strict case for leading '.' or '0'
  	if ($strict) {
  	    if ($d eq '.') {
  		return BADVERSION($s,$errstr,"Invalid version format (0 before decimal required)");
  	    }
  	    if ($d eq '0' && isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	    }
  	}
  
  	# and we never support negative version numbers
  	if ($d eq '-') {
  	    return BADVERSION($s,$errstr,"Invalid version format (negative version number)");
  	}
  
  	# consume all of the integer part
  	while (isDIGIT($d)) {
  	    $d++;
  	}
  
  	# look for a fractional part
  	if ($d eq '.') {
  	    # we found it, so consume it
  	    $saw_decimal++;
  	    $d++;
  	}
  	elsif (!$d || $d eq ';' || isSPACE($d) || $d eq '}') {
  	    if ( $d == $s ) {
  		# found nothing
  		return BADVERSION($s,$errstr,"Invalid version format (version required)");
  	    }
  	    # found just an integer
  	    goto version_prescan_finish;
  	}
  	elsif ( $d == $s ) {
  	    # didn't find either integer or period
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  	elsif ($d eq '_') {
  	    # underscore can't come after integer part
  	    if ($strict) {
  		return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  	    }
  	    elsif (isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (alpha without decimal)");
  	    }
  	    else {
  		return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  	    }
  	}
  	elsif ($d) {
  	    # anything else after integer part is just invalid data
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  
  	# scan the fractional part after the decimal point
  	if ($d && !isDIGIT($d) && ($strict || ! ($d eq ';' || isSPACE($d) || $d eq '}') )) {
  		# $strict or lax-but-not-the-end
  		return BADVERSION($s,$errstr,"Invalid version format (fractional part required)");
  	}
  
  	while (isDIGIT($d)) {
  	    $d++; $j++;
  	    if ($d eq '.' && isDIGIT($d-1)) {
  		if ($alpha) {
  		    return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		}
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions must begin with 'v')");
  		}
  		$d = $s; # start all over again
  		$qv = TRUE;
  		goto dotted_decimal_version;
  	    }
  	    if ($d eq '_') {
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		}
  		if ( $alpha ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		}
  		if ( ! isDIGIT($d+1) ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  		}
  		$width = $j;
  		$d++;
  		$alpha = TRUE;
  	    }
  	}
      }
  
  version_prescan_finish:
      while (isSPACE($d)) {
  	$d++;
      }
  
      if ($d && !isDIGIT($d) && (! ($d eq ';' || $d eq '}') )) {
  	# trailing non-numeric data
  	return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
      }
  
      if (defined $sqv) {
  	$$sqv = $qv;
      }
      if (defined $swidth) {
  	$$swidth = $width;
      }
      if (defined $ssaw_decimal) {
  	$$ssaw_decimal = $saw_decimal;
      }
      if (defined $salpha) {
  	$$salpha = $alpha;
      }
      return $d;
  }
  
  sub scan_version {
      my ($s, $rv, $qv) = @_;
      my $start;
      my $pos;
      my $last;
      my $errstr;
      my $saw_decimal = 0;
      my $width = 3;
      my $alpha = FALSE;
      my $vinf = FALSE;
      my @av;
  
      $s = new charstar $s;
  
      while (isSPACE($s)) { # leading whitespace is OK
  	$s++;
      }
  
      $last = prescan_version($s, FALSE, \$errstr, \$qv, \$saw_decimal,
  	\$width, \$alpha);
  
      if ($errstr) {
  	# 'undef' is a special case and not an error
  	if ( $s ne 'undef') {
  	    use Carp;
  	    Carp::croak($errstr);
  	}
      }
  
      $start = $s;
      if ($s eq 'v') {
  	$s++;
      }
      $pos = $s;
  
      if ( $qv ) {
  	$$rv->{qv} = $qv;
      }
      if ( $alpha ) {
  	$$rv->{alpha} = $alpha;
      }
      if ( !$qv && $width < 3 ) {
  	$$rv->{width} = $width;
      }
  
      while (isDIGIT($pos)) {
  	$pos++;
      }
      if (!isALPHA($pos)) {
  	my $rev;
  
  	for (;;) {
  	    $rev = 0;
  	    {
    		# this is atoi() that delimits on underscores
    		my $end = $pos;
    		my $mult = 1;
  		my $orev;
  
  		#  the following if() will only be true after the decimal
  		#  point of a version originally created with a bare
  		#  floating point number, i.e. not quoted in any way
  		#
   		if ( !$qv && $s > $start && $saw_decimal == 1 ) {
  		    $mult *= 100;
   		    while ( $s < $end ) {
  			$orev = $rev;
   			$rev += $s * $mult;
   			$mult /= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version %d",
  					   $VERSION_MAX);
  			    $s = $end - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   			$s++;
  			if ( $s eq '_' ) {
  			    $s++;
  			}
   		    }
    		}
   		else {
   		    while (--$end >= $s) {
  			$orev = $rev;
   			$rev += $end * $mult;
   			$mult *= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version");
  			    $end = $s - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   		    }
   		}
    	    }
  
    	    # Append revision
  	    push @av, $rev;
  	    if ( $vinf ) {
  		$s = $last;
  		last;
  	    }
  	    elsif ( $pos eq '.' ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq '_' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq ',' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( isDIGIT($pos) ) {
  		$s = $pos;
  	    }
  	    else {
  		$s = $pos;
  		last;
  	    }
  	    if ( $qv ) {
  		while ( isDIGIT($pos) ) {
  		    $pos++;
  		}
  	    }
  	    else {
  		my $digits = 0;
  		while ( ( isDIGIT($pos) || $pos eq '_' ) && $digits < 3 ) {
  		    if ( $pos ne '_' ) {
  			$digits++;
  		    }
  		    $pos++;
  		}
  	    }
  	}
      }
      if ( $qv ) { # quoted versions always get at least three terms
  	my $len = $#av;
  	#  This for loop appears to trigger a compiler bug on OS X, as it
  	#  loops infinitely. Yes, len is negative. No, it makes no sense.
  	#  Compiler in question is:
  	#  gcc version 3.3 20030304 (Apple Computer, Inc. build 1640)
  	#  for ( len = 2 - len; len > 0; len-- )
  	#  av_push(MUTABLE_AV(sv), newSViv(0));
  	#
  	$len = 2 - $len;
  	while ($len-- > 0) {
  	    push @av, 0;
  	}
      }
  
      # need to save off the current version string for later
      if ( $vinf ) {
  	$$rv->{original} = "v.Inf";
  	$$rv->{vinf} = 1;
      }
      elsif ( $s > $start ) {
  	$$rv->{original} = $start->currstr($s);
  	if ( $qv && $saw_decimal == 1 && $start ne 'v' ) {
  	    # need to insert a v to be consistent
  	    $$rv->{original} = 'v' . $$rv->{original};
  	}
      }
      else {
  	$$rv->{original} = '0';
  	push(@av, 0);
      }
  
      # And finally, store the AV in the hash
      $$rv->{version} = \@av;
  
      # fix RT#19517 - special case 'undef' as string
      if ($s eq 'undef') {
  	$s += 5;
      }
  
      return $s;
  }
  
  sub new
  {
  	my ($class, $value) = @_;
  	unless (defined $class) {
  	    require Carp;
  	    Carp::croak('Usage: version::new(class, version)');
  	}
  	my $self = bless ({}, ref ($class) || $class);
  	my $qv = FALSE;
  
  	if ( ref($value) && eval('$value->isa("version")') ) {
  	    # Can copy the elements directly
  	    $self->{version} = [ @{$value->{version} } ];
  	    $self->{qv} = 1 if $value->{qv};
  	    $self->{alpha} = 1 if $value->{alpha};
  	    $self->{original} = ''.$value->{original};
  	    return $self;
  	}
  
  	my $currlocale = setlocale(LC_ALL);
  
  	# if the current locale uses commas for decimal points, we
  	# just replace commas with decimal places, rather than changing
  	# locales
  	if ( localeconv()->{decimal_point} eq ',' ) {
  	    $value =~ tr/,/./;
  	}
  
  	if ( not defined $value or $value =~ /^undef$/ ) {
  	    # RT #19517 - special case for undef comparison
  	    # or someone forgot to pass a value
  	    push @{$self->{version}}, 0;
  	    $self->{original} = "0";
  	    return ($self);
  	}
  
  	if ( $#_ == 2 ) { # must be CVS-style
  	    $value = $_[2];
  	    $qv = TRUE;
  	}
  
  	$value = _un_vstring($value);
  
  	# exponential notation
  	if ( $value =~ /\d+.?\d*e[-+]?\d+/ ) {
  	    $value = sprintf("%.9f",$value);
  	    $value =~ s/(0+)$//; # trim trailing zeros
  	}
  
  	my $s = scan_version($value, \$self, $qv);
  
  	if ($s) { # must be something left over
  	    warn("Version string '%s' contains invalid data; "
                         ."ignoring: '%s'", $value, $s);
  	}
  
  	return ($self);
  }
  
  *parse = \&new;
  
  sub numify
  {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      my $width = $self->{width} || 3;
      my $alpha = $self->{alpha} || "";
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("%d.", $digit );
  
      for ( my $i = 1 ; $i < $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	if ( $width < 3 ) {
  	    my $denom = 10**(3-$width);
  	    my $quot = int($digit/$denom);
  	    my $rem = $digit - ($quot * $denom);
  	    $string .= sprintf("%0".$width."d_%d", $quot, $rem);
  	}
  	else {
  	    $string .= sprintf("%03d", $digit);
  	}
      }
  
      if ( $len > 0 ) {
  	$digit = $self->{version}[$len];
  	if ( $alpha && $width == 3 ) {
  	    $string .= "_";
  	}
  	$string .= sprintf("%0".$width."d", $digit);
      }
      else # $len = 0
      {
  	$string .= sprintf("000");
      }
  
      return $string;
  }
  
  sub normal
  {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      my $alpha = $self->{alpha} || "";
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("v%d", $digit );
  
      for ( my $i = 1 ; $i < $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf(".%d", $digit);
      }
  
      if ( $len > 0 ) {
  	$digit = $self->{version}[$len];
  	if ( $alpha ) {
  	    $string .= sprintf("_%0d", $digit);
  	}
  	else {
  	    $string .= sprintf(".%0d", $digit);
  	}
      }
  
      if ( $len <= 2 ) {
  	for ( $len = 2 - $len; $len != 0; $len-- ) {
  	    $string .= sprintf(".%0d", 0);
  	}
      }
  
      return $string;
  }
  
  sub stringify
  {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      return exists $self->{original}
      	? $self->{original}
  	: exists $self->{qv}
  	    ? $self->normal
  	    : $self->numify;
  }
  
  sub vcmp
  {
      require UNIVERSAL;
      my ($left,$right,$swap) = @_;
      my $class = ref($left);
      unless ( UNIVERSAL::isa($right, $class) ) {
  	$right = $class->new($right);
      }
  
      if ( $swap ) {
  	($left, $right) = ($right, $left);
      }
      unless (_verify($left)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      unless (_verify($right)) {
  	require Carp;
  	Carp::croak("Invalid version format");
      }
      my $l = $#{$left->{version}};
      my $r = $#{$right->{version}};
      my $m = $l < $r ? $l : $r;
      my $lalpha = $left->is_alpha;
      my $ralpha = $right->is_alpha;
      my $retval = 0;
      my $i = 0;
      while ( $i <= $m && $retval == 0 ) {
  	$retval = $left->{version}[$i] <=> $right->{version}[$i];
  	$i++;
      }
  
      # tiebreaker for alpha with identical terms
      if ( $retval == 0
  	&& $l == $r
  	&& $left->{version}[$m] == $right->{version}[$m]
  	&& ( $lalpha || $ralpha ) ) {
  
  	if ( $lalpha && !$ralpha ) {
  	    $retval = -1;
  	}
  	elsif ( $ralpha && !$lalpha) {
  	    $retval = +1;
  	}
      }
  
      # possible match except for trailing 0's
      if ( $retval == 0 && $l != $r ) {
  	if ( $l < $r ) {
  	    while ( $i <= $r && $retval == 0 ) {
  		if ( $right->{version}[$i] != 0 ) {
  		    $retval = -1; # not a match after all
  		}
  		$i++;
  	    }
  	}
  	else {
  	    while ( $i <= $l && $retval == 0 ) {
  		if ( $left->{version}[$i] != 0 ) {
  		    $retval = +1; # not a match after all
  		}
  		$i++;
  	    }
  	}
      }
  
      return $retval;
  }
  
  sub vbool {
      my ($self) = @_;
      return vcmp($self,$self->new("0"),1);
  }
  
  sub vnoop {
      require Carp;
      Carp::croak("operation not supported with version object");
  }
  
  sub is_alpha {
      my ($self) = @_;
      return (exists $self->{alpha});
  }
  
  sub qv {
      my $value = shift;
      my $class = 'version';
      if (@_) {
  	$class = ref($value) || $value;
  	$value = shift;
      }
  
      $value = _un_vstring($value);
      $value = 'v'.$value unless $value =~ /(^v|\d+\.\d+\.\d)/;
      my $obj = version->new($value);
      return bless $obj, $class;
  }
  
  *declare = \&qv;
  
  sub is_qv {
      my ($self) = @_;
      return (exists $self->{qv});
  }
  
  
  sub _verify {
      my ($self) = @_;
      if ( ref($self)
  	&& eval { exists $self->{version} }
  	&& ref($self->{version}) eq 'ARRAY'
  	) {
  	return 1;
      }
      else {
  	return 0;
      }
  }
  
  sub _is_non_alphanumeric {
      my $s = shift;
      $s = new charstar $s;
      while ($s) {
  	return 0 if isSPACE($s); # early out
  	return 1 unless (isALPHA($s) || isDIGIT($s) || $s =~ /[.-]/);
  	$s++;
      }
      return 0;
  }
  
  sub _un_vstring {
      my $value = shift;
      # may be a v-string
      if ( length($value) >= 3 && $value !~ /[._]/
  	&& _is_non_alphanumeric($value)) {
  	my $tvalue;
  	if ( $] ge 5.008_001 ) {
  	    $tvalue = _find_magic_vstring($value);
  	    $value = $tvalue if length $tvalue;
  	}
  	elsif ( $] ge 5.006_000 ) {
  	    $tvalue = sprintf("v%vd",$value);
  	    if ( $tvalue =~ /^v\d+(\.\d+){2,}$/ ) {
  		# must be a v-string
  		$value = $tvalue;
  	    }
  	}
      }
      return $value;
  }
  
  sub _find_magic_vstring {
      my $value = shift;
      my $tvalue = '';
      require B;
      my $sv = B::svref_2object(\$value);
      my $magic = ref($sv) eq 'B::PVMG' ? $sv->MAGIC : undef;
      while ( $magic ) {
  	if ( $magic->TYPE eq 'V' ) {
  	    $tvalue = $magic->PTR;
  	    $tvalue =~ s/^v?(.+)$/v$1/;
  	    last;
  	}
  	else {
  	    $magic = $magic->MOREMAGIC;
  	}
      }
      return $tvalue;
  }
  
  sub _VERSION {
      my ($obj, $req) = @_;
      my $class = ref($obj) || $obj;
  
      no strict 'refs';
      if ( exists $INC{"$class.pm"} and not %{"$class\::"} and $] >= 5.008) {
  	 # file but no package
  	require Carp;
  	Carp::croak( "$class defines neither package nor VERSION"
  	    ."--version check failed");
      }
  
      my $version = eval "\$$class\::VERSION";
      if ( defined $version ) {
  	local $^W if $] <= 5.008;
  	$version = version::vpp->new($version);
      }
  
      if ( defined $req ) {
  	unless ( defined $version ) {
  	    require Carp;
  	    my $msg =  $] < 5.006
  	    ? "$class version $req required--this is only version "
  	    : "$class does not define \$$class\::VERSION"
  	      ."--version check failed";
  
  	    if ( $ENV{VERSION_DEBUG} ) {
  		Carp::confess($msg);
  	    }
  	    else {
  		Carp::croak($msg);
  	    }
  	}
  
  	$req = version::vpp->new($req);
  
  	if ( $req > $version ) {
  	    require Carp;
  	    if ( $req->is_qv ) {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->normal, $version->normal)
  		);
  	    }
  	    else {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->stringify, $version->stringify)
  		);
  	    }
  	}
      }
  
      return defined $version ? $version->stringify : undef;
  }
  
  1; #this line is important and will help the module return a true value
VERSION_VPP

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    if ($] < 5.008) {
      return sub {
        return 0 unless length $fat;
        $fat =~ s/^([^\n]*\n?)//;
        $_ = $1;
        return 1;
      };
    }
    open my $fh, '<', \$fat
      or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
    return $fh;
  }
  return
};

} # END OF FATPACK CODE

#!perl
use utf8;
use strict;
use warnings qw(FATAL utf8);
use open qw(:std :utf8);
use Carp;

use File::Next;
use File::stat;
use File::Basename;
use File::Copy;
use File::Slurp qw(read_file);
use File::Temp qw/ :seekable tempdir /;
use File::MimeInfo::Magic;
use Fcntl qw(:flock SEEK_END);
use IO::Handle;
use IO::File;
use Digest::MD5::File qw(file_md5_hex);
use Digest::MD5 qw(md5_hex);
use Cwd qw(abs_path);

use Encode;

use LWP::UserAgent::Determined;
use LWP::ConnCache;
use LWP::Protocol::connect;
use IO::Socket::SSL;
use URI;
use HTTP::Request::Common qw(GET PUT HEAD POST DELETE);
use HTTP::Request;
use JSON::PP qw(encode_json decode_json);

use Getopt::Long;
use Parallel::Fork::BossWorker;
use Try::Tiny;
use Time::HiRes qw(time);
use Perl6::Junction qw(all);
use Config::Any::INI;

our $CAN_DO_S3 = 0;
eval {
  require Net::Amazon::S3;
  Net::Amazon::S3->import;
  $CAN_DO_S3 = 1;
  1;
};

use bdatum::Constants ':all';
use bdatum::Util;

use version;

our $VERSION = qv('1.05');

our $util = bdatum::Util->new;

# ,=> to avoid fat comma stringification, the keys
# need to be integers
my %metadata_map = (
  UID
  , => 'meta-uid',
  GID
  , => 'meta-gid',
  UMASK
  , => 'meta-umask',
  SYMLINK
  ,      => 'meta-symlink',
  MTIME, => 'meta-mtime'
);

our ( $node_key, $partner_key, $path, @blacklist, $manifest, $backup_count,
  $backup_start_time, $ignore_schedule );
our ( $stage_dir, $configfile, $ua, $main_pid );
our ( $usage, $run_lock_fh, $PART_LIMIT_SIZE, $config );

our (
  $aws_config,             $aws_configfile,        $aws_access_key_id,
  $aws_storage_type,       $aws_access_key_secret, $aws_container,
  $aws_expiry_max_version, $aws_storage_backend
);

our $opt        = {};
our $parent_pid = $$;
our $_abort     = 0;

$SIG{USR1} = sub {
  $_abort = 1;
};

# stripped from List::MoreUtils source
sub pairwise (&\@\@) {
  my $op = shift;

  # Symbols for caller's input arrays
  use vars qw{ @A @B };
  local ( *A, *B ) = @_;

  # Localise $a, $b
  my ( $caller_a, $caller_b ) = do {
    my $pkg = caller();
    no strict 'refs';
    \*{ $pkg . '::a' }, \*{ $pkg . '::b' };
  };

  # Loop iteration limit
  my $limit = $#A > $#B ? $#A : $#B;

  # This map expression is also the return value
  local ( *$caller_a, *$caller_b );
  map {
    # Assign to $a, $b as refs to caller's array elements
    ( *$caller_a, *$caller_b ) = \( $A[$_], $B[$_] );

    # Perform the transformation
    $op->();
  } 0 .. $limit;
}

sub _unauthorized_abort {
  $util->log_error("*** ERROR: 401 http unauthorized");
  exit 77;    # EX_NOPERM
}

sub _check_if_has_s3 {
  return if $CAN_DO_S3;
  $util->log_error("*** ERROR: You need to install Net::Amazon::S3");
  exit 1;
}
&run;

sub run {
  &options;
  while (1) {
    get_schedule() if $opt->{remote_config};

    &setup_manifest;
    eval { &backup; };

    if ($@) {
      $util->log_error($@);
    }
    last unless $opt->{persistent} or $opt->{daemon};
    &check_alive;
    sleep( $opt->{persistent_time} );
  }

  &_remove_lock_running;
}

sub check_alive {
  $util->log_info("Sending alive to b-datum");

  my $uri = URI->new(BASE_URL);
  $uri->path('alive');

  my $req = GET $uri;
  my $res = _send_request($req);

  if ( !$res->is_success ) {
    $util->log_warn("WARNING: can't send alive to b-datum");
  }

}

sub _check_already_running {
  my $lock_file = $util->make_control_file('lock');
  if ( -f $lock_file ) {
    open( FHL, "<", $lock_file ) or die "Cannot open $lock_file - $!";
    flock( FHL, LOCK_EX | LOCK_NB ) or die "Already running.";
  }
  open( FHL, ">", $lock_file ) or die "Cannot open $lock_file - $!";
  flock( FHL, LOCK_EX | LOCK_NB );
}

sub _remove_lock_running {
  my $lock_file = $util->make_control_file('lock');
  unlink($lock_file);
  my $lastbackup_file = $util->make_control_file('lastbackup');
  unlink($lastbackup_file) if -e $lastbackup_file;
}

sub setup_manifest {
  $manifest = File::Temp->new( UNLINK => 0, )
    or die q{Couldn't create manifest file};
}

sub _create_local_dir {
  my $dir = shift;
  mkdir($dir) unless -d $dir;
  die "*** ERROR: Can't create directory $dir" unless -d $dir;
  return $dir;
}

sub show_version {
  print "bdatum-backup version $VERSION ($0)\n";
  print "perl version $] ($^X)\n\n";
  exit(0);
}

sub show_help {
  my $wrong_argv = shift;
  if ($wrong_argv) {
    print <<USAGE;
Usage: bdatum-backup [options] [...]

Try `bdatum-backup --help` for more options.
USAGE
    exit(1);
  }
  print <<HELP;
Usage: bdatum-backup [options] [...]

    -n,--node_key          node key
    -p,--partner_key       partner key
    --path                 target path

    -k,--nodelete          don't remove in remote storage files deleted
    -w,--workers           number of workers (default: 5)
    -d,--daemon            Daemon mode
    -c,--config            config file

    --use_own_storage      use your own storage backend (default config: /etc/amazon.conf)
    --storage-config       specify config for storage backend

    --profile              load profile
    --persistent           persistent mode
    --persistent_time      time in seconds for run again the scan in directory to do backup (default: 180)
    --retry_time           time to retry the request to bdatum if some request fails (default: 30)

    --proxy_scheme         Scheme, can be connect, http or https. (Default: connect)
    --proxy_server         Proxy server
    --proxy_port           Proxy port
    --proxy_username       Proxy username
    --proxy_password       Proxy password

    --part_size            Part size in megabytes of multipart upload (default: 5)

    --remote-config        Uses storage policy config, implies that --profile would never be evaluated (default: false)

    -v,--verbose           verbose mode
    --debug                debug mode
    -h,--help              print usage message and exit

  Examples:

    bdatum-backup -n 12345678901234567890 -p 12345678901234567890 --path /var
    bdatum-backup --proxy_server 10.0.0.1 --proxy_port 8080 --proxy_username foo --proxy_password bar
    bdatum-backup --persistent --daemon

HELP
  exit(0);
}

sub options {
  GetOptions(
    "node_key|n=s"    => \$opt->{node_key},
    "partner_key|p=s" => \$opt->{partner_key},
    "path=s"          => \$opt->{path},

    "nodelete|k"        => \$opt->{nodelete},
    "workers|w=i"       => \$opt->{workers},
    "daemon|d"          => \$opt->{daemon},
    "config|c=s"        => \$opt->{config},
    "profile=s"         => \$opt->{profile},
    "persistent"        => \$opt->{persistent},
    "persistent_time=i" => \$opt->{persistent_time},
    "retry_time=i"      => \$opt->{retry_time},

    "use_own_storage"  => \$opt->{use_own_storage},
    "storage_config=s" => \$opt->{aws_config},

    "proxy_scheme=s"   => \$opt->{proxy_scheme},
    "proxy_server=s"   => \$opt->{proxy_server},
    "proxy_port=i"     => \$opt->{proxy_port},
    "proxy_username=s" => \$opt->{proxy_username},
    "proxy_password=s" => \$opt->{proxy_password},

    "part_size=i"   => \$opt->{part_size},
    "remote-config" => \$opt->{remote_config},

    "version|v" => \$opt->{version},
    "verbose"   => \$opt->{verbose},
    "debug"     => \$opt->{debug},
    "help"      => \$opt->{help},
  ) or &show_help(1);

  &show_version if $opt->{version};
  &show_help    if $opt->{help};

  $util->set_debug(1)  if $opt->{debug};
  $util->set_daemon(1) if $opt->{daemon};

  $0 = "[bdatum-backup]";

  # Defaults
  $opt->{part_size}       ||= 5;
  $opt->{workers}         ||= 5;
  $opt->{persistent_time} ||= 180;
  $opt->{retry_time}      ||= 30;

  # Daemon
  if ( $opt->{daemon} ) {
    $main_pid = fork();
    die "cannot fork" unless defined $main_pid;
    exit 0 if $main_pid != 0;

    open my $fh, '>', '/var/run/bdatum-backup.pid';
    print $fh $$;
    close $fh;
  }

  # Check part_size
  if ( $opt->{part_size} < 5 or $opt->{part_size} > 500 ) {
    $util->log_error("part_size option need to be > 5 or < 500.");
    exit(0);
  }

  # Check for incompatible options used with "--remote-config"

  $util->log_warn(
"the path defined in --path will be ignored if remote configuration is set to be used"
  ) if $opt->{remote_config} && $opt->{path};

  $util->log_warn(
q{because of --remote-config the "path" defined in the specified profile will be ignored}
  ) if $opt->{remote_config} && $opt->{profile};

  $util->log_warn(
q{because of --remote-config the time defined in --persistent_time will be ignored if remote config is enabled}
  ) if $opt->{remote_config} && $opt->{persistent_time};

  # part size for multipart upload.
  $PART_LIMIT_SIZE = $opt->{part_size} * 1024 * 1024;

  # create base dir
  $stage_dir = join( '/', BASE_DIR, 'stage' );
  &_create_local_dir(BASE_DIR);
  &_create_local_dir($stage_dir);

  # get config file.
  $configfile = $opt->{config};

  if ( !$configfile and -r '/etc/bdatum/backup.conf' ) {
    $configfile = '/etc/bdatum/backup.conf';
  }

  if ( !$configfile and $ENV{'HOME'} ) {
    $configfile = join( '/', $ENV{'HOME'}, '.b-datum', 'backup.conf' );
    if ( !-r $configfile ) {
      $configfile = join( '/', $ENV{'HOME'}, '.bdatum', 'backup.conf' );
    }
  }

  if ( -r $configfile ) {
    my $st = stat $configfile;
    my $mode = sprintf( '%04o', $st->mode & 07777 );
    if ( $mode ne '0400' ) {
      $util->log_error( "Please run 'chmod 0400 $configfile'", 78 );
    }

    my $config_all = Config::Any::INI->load($configfile);
    my $profile    = $opt->{profile};

    $config =
      defined $profile && exists $config_all->{$profile}
      ? $config_all->{$profile}
      : $config_all;

    $node_key             = $config->{node_key};
    $partner_key          = $config->{partner_key};
    $path                 = $config->{path};
    $opt->{remote_config} = $config->{remote_config}
      if $config->{remote_config};

    @blacklist = map {
      my $r = $config->{blacklist}->{$_};
      eval { qr/$r/ }
        or die qq{Blacklist item "$_" is not a valid regex};
    } keys %{ $config->{blacklist} || {} };
  }

  $aws_configfile = $opt->{aws_config} || '/etc/amazon.conf';

  &_check_if_has_s3() if $opt->{use_own_storage};

  if ( $opt->{use_own_storage} && -r $aws_configfile ) {
    my $st = stat $aws_configfile;
    my $mode = sprintf( '%04o', $st->mode & 07777 );
    if ( $mode ne '0400' ) {
      $util->log_error( "Please run 'chmod 0400 $aws_configfile'", 78 );
    }

    my $config = Config::Any::INI->load($aws_configfile);

    $aws_storage_type = $config->{storage_type} || 's3';

    $aws_access_key_id = $config->{access_key_id}
      or $util->log_error( "Missing access_key_id", 78 ), exit(0);
    $aws_access_key_secret = $config->{access_key_secret}
      or $util->log_error( "Missing access_key_secret", 78 ), exit(0);
    $aws_container = $config->{container}
      or $util->log_error( "Missing container", 78 ), exit(0);
    $aws_expiry_max_version = $config->{expiry_max_version};

    if ( $aws_storage_type =~ /^s3$/i ) {
      &_check_if_has_s3;
      $aws_storage_backend = Net::Amazon::S3->new(
        {
          aws_access_key_id     => $aws_access_key_id,
          aws_secret_access_key => $aws_access_key_secret,
          retry                 => 1,
        }
      );
      $aws_storage_backend->bucket($aws_container);
    }
  }

  # skipping staging dir by blacklist
  my $b_datum_dir = BASE_DIR;  # PBP - Bareword constants can't be interpolated.
  push( @blacklist, qr/^$b_datum_dir/, qr/^$stage_dir/ );

  # for linux
  push( @blacklist, qr/^\/proc\//, qr/^\/sys\// );

  $node_key    = $opt->{node_key}    if $opt->{node_key};
  $partner_key = $opt->{partner_key} if $opt->{partner_key};
  $path        = $opt->{path}        if $opt->{path};

  if ( !$util->validate_key($node_key)
    or !$util->validate_key($partner_key) )
  {
    $util->log_error( "Required option missing: node_key or partner_key.", 64 );
  }

  $util->set_partner_key($partner_key);
  $util->set_node_key($node_key);

  &prepare_ua;

  if ( $opt->{remote_config} ) {
    get_schedule();
  }

  if ( !$util->validate_path($path) ) {
    $util->log_error( "Required option missing: path.", 64 );
  }

  $util->set_path($path);

}

sub _reset_blacklist {

  @blacklist = ();

  # skipping staging dir by blacklist
  my $b_datum_dir = BASE_DIR;  # PBP - Bareword constants can't be interpolated.
  push( @blacklist, qr/^$b_datum_dir/, qr/^$stage_dir/ );

  # for linux
  push( @blacklist, qr/^\/proc\//, qr/^\/sys\// );
  return @blacklist;
}

sub wait_if_needed {

  $ignore_schedule = 0, return
    if $ignore_schedule;       # don't wait, start right away

  return
    unless ( defined $backup_start_time )
    && ( $backup_start_time =~ /^\d{1,2}:\d{2}$/ );

  while (1) {
    my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst ) =
      localtime(time);
    my $current_time = "$hour:$min";
    sleep(10) if $backup_start_time ne $current_time;
  }
}

sub prepare_ua {
  my $ssl_cache = IO::Socket::SSL::Session_Cache->new(10);
  my $context   = IO::Socket::SSL::SSL_Context->new(
    SSL_verify_mode   => 0,
    SSL_session_cache => $ssl_cache
  );
  IO::Socket::SSL::set_default_context($context);
  IO::Socket::SSL::set_default_session_cache($ssl_cache);

  my $ua_cache = LWP::ConnCache->new();
  $ua_cache->total_capacity(10);

  my $OS = $^O || 'Linux';

  $ua = LWP::UserAgent::Determined->new(
    requests_redirectable => [qw(GET HEAD DELETE PUT POST)],
    agent                 => "bdatum-backup/$VERSION ($OS)",
  );

  if ( $config->{proxy_server} || $opt->{proxy_server} ) {
    my $scheme = $config->{proxy_scheme} || $opt->{proxy_scheme};
    $scheme ||= 'connect';
    my $server   = $config->{proxy_server}   || $opt->{proxy_server};
    my $port     = $config->{proxy_port}     || $opt->{proxy_port};
    my $username = $config->{proxy_username} || $opt->{proxy_username};
    my $password = $config->{proxy_password} || $opt->{proxy_password};

    $server .= ":$port" if $port;

    my $proxy_login;
    $proxy_login = "$username:$password\@" if $username;

    # For HTTP
    my $proxy = "$scheme://$proxy_login$server";
    $ua->protocols_allowed( [ 'http', 'https' ] );

    #$ua->proxy( ['http', 'https'], $proxy );

    # For basic authorization
    #if ($username) {
    #    $ua->credentials($server, 'domain', $username, $password);
    #}
    # For HTTPS
    $ENV{HTTPS_PROXY}          = $proxy;
    $ENV{HTTPS_PROXY_USERNAME} = $username;
    $ENV{HTTPS_PROXY_PASSWORD} = $password;
    $ENV{HTTP_PROXY}           = $proxy;
    $ENV{HTTP_PROXY_USERNAME}  = $username;
    $ENV{HTTP_PROXY_PASSWORD}  = $password;

    $ENV{PERL_LWP_SSL_VERIFY_HOSTNAME} = 0;
    $ua->env_proxy(1);

  }

  $ua->ssl_opts( verify_hostname => 0, SSL_verify_mode => 0, )
    if LWP::UserAgent::Determined->can('ssl_opts');
  $ua->timing( $opt->{retry_time} );
  $ua->conn_cache($ua_cache);
  $ua->add_handler( request_prepare =>
      sub { shift->authorization_basic( $node_key, $partner_key ); } );

  if ( $opt->{verbose} ) {
    $ua->add_handler( "request_send",  sub { shift->dump; return } );
    $ua->add_handler( "response_done", sub { shift->dump; return } );
  }
}

sub backup {

  wait_if_needed();

  $util->log_debug("Node key: $node_key");
  $util->log_debug("Partner key: $partner_key");
  $util->log_debug("Path: $path");

  &_check_already_running;
  &check_alive();

  start();

  _send_manifest();

  close($manifest);
  unlink($manifest);
}

sub get_schedule {
  my $seconds_in_day = 24 * 60 * 60;

  $util->log_info("Fetching storage config from b-datum");

  my $uri = URI->new(BASE_URL);
  $uri->path('storage/config');

  my $req = GET $uri;
  my $res = _send_request($req);

  if ( !$res->is_success ) {
    $util->log_warn("WARNING: can't fetch storage config from b-datum");
    exit(0);
  }

  my $conf = decode_json $res->content;

  # ignore options setted in remote config
  return
    unless $conf->{use_remote_config};

  $backup_count = $conf->{backup_repeat}
    if exists $conf->{backup_repeat} && defined $conf->{backup_repeat};

  # using included dirs in config as backup paths
  $path = join( q{;}, sort keys %{ $conf->{include} } )
    if exists $conf->{include} && ref $conf->{include} eq 'HASH'
    and scalar keys %{ $conf->{include} };

  # using excluded dirs in config as blacklist
  _reset_blacklist(), push @blacklist, keys %{ $conf->{exclude} }
    if exists $conf->{exclude} && ref $conf->{exclude} eq 'HASH'
    and scalar keys %{ $conf->{exclude} };

  if ( my $ignore_days = $conf->{ignore_schedule_after_days} ) {
    my $stat  = File::stat::stat( $util->make_control_file('lastbackup_file') );
    my $mtime = $stat->mtime;

    my $time_since_last_backup = time - $mtime;

    if ( $ignore_days <= $time_since_last_backup / $seconds_in_day ) {
      $ignore_schedule = 1;
    }
  }

  if ( my $repeat = $conf->{backup_repeat} ) {

    # calculate apropriate interval
    my $interval           = $seconds_in_day / $repeat;
    my $backup_repeat_file = $util->make_control_file('backuprepeat');
    my $fh                 = IO::File->new( $backup_repeat_file, 'w+' );
    print $fh $interval;
    $fh->close;
    $opt->{persistent_time} = $interval;
  }

  if ( my $backup_schedule_time = $conf->{backup_schedule_time} ) {

    # extracting hour, min e timezone from "hh:mm-z"
    my ( $hour, $min, $tz ) =
      $backup_schedule_time =~ /(\d{1,2}):(\d{2})((\-|\+?)\d{1,2})/;
    $hour              = $hour + $tz;    #calculate timezone;
    $backup_start_time = "$hour:$min";
  }
}

sub _get_files {

  my @paths = $path;

  @paths = split q{;}, $path if $path =~ /;/;

  return File::Next::everything(
    {
      error_handler => sub { $util->log_error(@_); },

      # show symlinks
      follow_symlinks => 1,

      sort_files => 1,

      # but ignore its descendants in case of being a link to dir
      file_filter => sub {

        -p $File::Next::name
          && $util->log_warn("SKIPPING: $File::Next::name is a named pipe")
          && return;

        -S $File::Next::name
          && $util->log_warn("SKIPPING: $File::Next::name is a socket")
          && return;

        -b $File::Next::name
          && $util->log_warn(
          "SKIPPING: $File::Next::name is a block special file")
          && return;

        -p $File::Next::name
          && $util->log_warn("SKIPPING: $File::Next::name is a named pipe")
          && return;

        -c $File::Next::name
          && $util->log_warn(
          "SKIPPING: $File::Next::name is a character special file")
          && return;

        -t $File::Next::name
          && $util->log_warn(
          "SKIPPING: $File::Next::name is is opened to a tty")
          && return;

             !-R $File::Next::name
          && !-l $File::Next::name
          && $util->log_warn("SKIPPING: $File::Next::name can't be read")
          && return;

        !_in_blacklist($File::Next::name)
          && !-l dirname($File::Next::name)
          && ( ( -d $File::Next::name && -x $File::Next::name )
          || ( -f $File::Next::name )
          || ( -l $File::Next::name ) );
      },
      descend_filter => sub {
        !-l dirname($File::Next::dir);
      },
    },
    @paths
  );
}

sub is_folder_empty {
  my $dirname = shift;
  opendir( my $dh, $dirname ) or die "Not a directory";
  return scalar( grep { $_ ne "." && $_ ne ".." } readdir($dh) ) == 0;
}

sub _get_lastbackup {
  my $lastbackup_file = $util->make_control_file('lastbackup');
  return unless -e $lastbackup_file;
  my $content = do { local ( @ARGV, $/ ) = $lastbackup_file; <> };
  return $content;
}

sub _write_lastbackup {
  my $file            = shift;
  my $lastbackup_file = $util->make_control_file('lastbackup');
  open my $fh, '>', $lastbackup_file;
  print $fh $file;
  close $fh;
}

sub start {
  my %cache = _read_cache();

  my $start           = time();
  my $files           = &_get_files();
  my $lastbackup_file = &_get_lastbackup;
  my $lastbackup_run  = $lastbackup_file ? 1 : 0;

  # Create new BossWorker instance
  my $bw = Parallel::Fork::BossWorker->new(
    worker_count => $opt->{workers},
    work_handler => sub {
      my ($job)          = @_;
      my $file           = $job->{file};
      my @previous_attrs = $job->{previous_attrs};
      my $change_specs   = $job->{change_specs};

      $util->log_info("Sending $file...");

      my $attempt = 0;
      my $error;
      do {
        try {
          if ( $previous_attrs[ETAG]
            && ( $previous_attrs[ETAG] eq $change_specs->{attributes}->[ETAG] )
            )
          {

            # no content changed but some metadata did
            if ( @{ $change_specs->{modified_fields} || [] } ) {
              send_patch(%$change_specs);
            }
          }
          else {
            send_file( $file, $change_specs->{attributes}, $change_specs );
          }
        }

        catch { $error = $_; sleep(3); };
        if ($error) {
          $util->log_warn("Error sending $file trying again... $attempt");
          $util->log_warn("\t\t$error");
        }
      } while ( $error && ( $attempt++ < 3 ) );

      ( unlink( $change_specs->{stage_file} )
          || die
          qq{Could not unlink tempfile "$change_specs->{stage_file}": $!} )
        if exists $change_specs->{stage_file}
        && -e $change_specs->{stage_file}
        && !-l $change_specs->{stage_file};

    }
  );

FILE: while ( defined( my $file = $files->() ) ) {

    # abort backup if we receive unauthorized response from bdatum.
    _unauthorized_abort() if $_abort;

    # fast way to do backup in the "second-first job",
    # if the first-first backup not finish completely.
    my $cache_file = $util->make_control_file('cache');
    if ( !-e $cache_file && $lastbackup_run ) {
      if ( $lastbackup_file eq $file ) {
        $lastbackup_run = 0;
      }
      next;
    }
    elsif ( !-e $cache_file ) {
      &_write_lastbackup($file);
    }

    # here, we go.
    $util->log_info("queuing: $file");

    if ( -d $file ) {
      $cache{"$file/"} = [];
      if ( is_folder_empty($file) ) {
        _mkdir($file);
        next;
      }
    }

    next if !-l $file && -d $file;

    my @previous_attrs = @{ $cache{$file} || [] };

    my $change_specs = get_changes( $file, \@previous_attrs );

    $cache{$file} = $change_specs->{attributes};

    # The limit to send a file to bdatum is $PART_LIMIT_SIZE*1000 or 5TB.
    my $file_size = -s $file;
    if ( ( $file_size > $PART_LIMIT_SIZE * LIMIT_PARTS )
      or $file_size > ( 5 * 1024 * 1024 * 1024 * 1025 ) )
    {
      $util->log_error(
"Skipping $file, because the size ($file_size) is >5TB or >PART_SIZE*10000"
      );
      next;
    }

    $bw->add_work(
      {
        file           => $file,
        previous_attrs => \@previous_attrs,
        change_specs   => $change_specs
      }
    );

  }

  $bw->process();
  my $end = time();
  $util->log_info("*\n*\n*\n* Started: $start");
  $util->log_info("* Completed: $end");

  _write_cache(%cache);

}

sub _in_blacklist {
  my $file = shift;
  my $yes = grep { $file =~ $_ } @blacklist;
  $util->log_warn("SKIPPING: $file is in blacklist") if $yes;
  return $yes;
}

sub get_changes {
  my ( $file, $attrs ) = @_;

  return unless defined $attrs && ( ref $attrs eq 'ARRAY' );
  my $stat = ( -l $file ? File::stat::lstat($file) : File::stat::stat($file) )
    or return;

  my $sfile =
    -l $file
    ? $file
    : _link_to_stage($file);    # no need to move the symlink itself
  my $etag = -l $file ? md5_hex('') : file_md5_hex($sfile);
  my @modified_fields = ();

  my $new_attrs = [
    $stat->mtime, $etag, $stat->uid, $stat->gid,
    sprintf( '%04o', $stat->mode ),
    ( -l $file ? abs_path( readlink $file ) : '' )
  ];

  my $changes = {
    stage_file      => $sfile,
    file            => $file,
    attributes      => $new_attrs,
    modified_fields => undef,
  };

  return $changes unless scalar @$attrs;    # new file, no changes

  push @modified_fields,
    grep { $attrs->[$_] ne $new_attrs->[$_] }
    ( MTIME, ETAG, UID, GID, UMASK, SYMLINK );

  {
    no warnings qw(once);

    # nothing changed
    return $changes
      if all( pairwise { $a eq $b } @$attrs, @$new_attrs ) == 1;
  }

  # symlinks read with readlink get its MTIME changed, we can ignore if
  # the file it's a link
  return $changes
    if -l $file && scalar @$attrs == 1 && defined $attrs->[MTIME];

  $changes->{modified_fields} = [@modified_fields];

  return $changes;

}

sub send_patch {
  my (%change_specs) = @_;

  my $uri = URI->new(BASE_URL);
  $uri->path('storage');

  $uri->query_form(
    path => $change_specs{file},
    map { $metadata_map{$_} => $change_specs{attributes}->[$_] }
      @{ $change_specs{modified_fields} || [] }
  );

  my $req = HTTP::Request->new( 'PATCH', $uri );
  $req->header( ETag => $change_specs{attributes}->[ETAG] );

  _send_request($req);

}

sub send_file {
  my ( $file, $attr ) = @_;

  return _send_default(@_) if -l $file;

  if ( -s $file < $PART_LIMIT_SIZE ) {
    return _send_default(@_);
  }
  else {
    return _send_default(@_) if $opt->{use_own_storage};
    return _send_multipart(@_);
  }

  $util->log_info("DONE");

}

sub _send_manifest {
  my $uri = URI->new(BASE_URL);
  $uri->path('storage/manifest');

  my $etag = file_md5_hex( $manifest->filename );

  my $req = PUT $uri,
    Etag    => $etag,
    Content => scalar read_file( $manifest->filename );
  my $res = _send_request($req);
}

sub _aws_backend_send_multipart {
  my ( $file, $attrs, $changes ) = @_;

  my $client = Net::Amazon::S3::Client->new( s3 => $aws_storage_backend );

  my $path = $file;
  $path =~ s/^\///;

  my $bucket = $client->bucket( name => $aws_container );
  my $object = $bucket->object( key => $path );

  my $sfile = $changes->{stage_file};

  my $fh = IO::File->new( $sfile, 'r', ':unix' )
    or die "Cannot open $file";

  my $upload_id = $object->initiate_multipart_upload;

  my $i = 1;
  my $buffer;
  my @parts;
  my @etags;

  while ( read( $fh, $buffer, $PART_LIMIT_SIZE ) ) {
    $util->log_info("sending part $i of $file");

    push @etags, md5_hex($buffer);
    push @parts, $i;

    my $response = $object->put_part(
      upload_id   => $upload_id,
      part_number => $i++,
      value       => $buffer
    );

    $util->log_info("finish upload part $i of $file.");
  }

  $fh->close;
  $object->complete_multipart_upload(
    upload_id    => $upload_id,
    etags        => \@etags,
    part_numbers => \@parts
  );
}

sub _send_multipart {
  my ( $file, $attrs, $changes ) = @_;

  my $etag = $attrs->[ETAG];
  $util->log_info("init multipart upload to $file");

  my $uri = URI->new(BASE_URL);
  $uri->path('storage');

  return 1
    if _check_duplicate( $uri, $file, $etag, $node_key, $partner_key, $attrs );

  # init
  my $full_etag = $etag;
  my $sfile     = $changes->{stage_file};

  $uri->query_form( path => "$file", multipart => 1 );
  my $req       = POST $uri, Etag => $full_etag;
  my $res       = _send_request($req);
  my $object    = decode_json( $res->content );
  my $upload_id = $object->{upload_id};

  # parts
  my $buffer;

  my $fh = IO::File->new( $sfile, 'r', ':unix' )
    or die "Cannot open $file";

  my $i = 1;
  my @parts;

  while ( read( $fh, $buffer, $PART_LIMIT_SIZE ) ) {
    $util->log_info("sending part $i of $file");

    my $uri = URI->new(BASE_URL);
    $uri->path('storage');

    my $etag = md5_hex($buffer);

    push @parts, [ $i, $etag ];

    $uri->query_form(
      path      => "$file",
      upload_id => $upload_id,
      part      => $i++
    );

    my $req = PUT $uri,
      Etag    => $etag,
      Content => $buffer;

    my $res = _send_request($req);

    $util->log_info("finish upload part $i of $file.");
  }
  $fh->close;

  #finalize
  $uri = URI->new(BASE_URL);
  $uri->path('/storage');
  $uri->query_form( path => "$file", upload_id => $upload_id );

  $req = POST $uri,
    Content_type => 'application/json',
    Accept       => 'application/json',
    Etag         => $full_etag,
    Content      => encode_json(
    {
      parts        => \@parts,
      content_type => mimetype($sfile) || 'application/octet-stream',
      _get_metadata( $file, $attrs )
    }
    );
  _send_request($req);
  $util->log_info("finish upload multipart to $file");

  _write_to_manifest( $manifest, "+$file\n+${\(-s $sfile)}\n+$full_etag\n\n" );

  return 1;

}

sub _write_to_manifest {
  my ( $manifest_file, $line ) = @_;
  lock($manifest_file);
  print $manifest_file $line;
  unlock($manifest_file);
}

sub _get_metadata {
  my ( $file, $attrs ) = @_;
  map { $metadata_map{$_} => $attrs->[$_] }
    grep { defined $attrs->[$_] && length $attrs->[$_] }
    map { int($_) } keys %metadata_map;
}

sub _mkdir {
  my ( $file, $attrs ) = @_;
  my $uri = URI->new(BASE_URL);

  $file = "$file/";
  $util->log_info("$file is an empty dir");

  $uri->path('/storage');

  my $etag = $attrs->[ETAG];

  return 1
    if _check_duplicate( $uri, $file, $etag, $node_key, $partner_key, $attrs );

  my $req = POST $uri,
    Content_Type => 'form-data',
    Content      => [ _get_metadata( $file, $attrs ), path => $file, ];
  _send_request($req);
  return 1;

}

sub _delete {
  my ($file) = @_;

  if ( $opt->{use_own_storage} ) {
    my $bucket = $aws_storage_backend->bucket($aws_container);

    $bucket->add_key( $file, '' )
      or die $aws_storage_backend->err . ": " . $aws_storage_backend->errstr
      if $opt->{use_own_storage};

  }

  my $uri = URI->new(BASE_URL);
  $uri->path('storage');
  $uri->query_form( path => $file );
  my $req = DELETE $uri;
  $util->log_info("deleting $file");
  my $res = $ua->request($req);

  _write_to_manifest( $manifest, "-$file\n\n" );

  return $res->is_success;
}

sub _send_default {
  my ( $file, $attrs, $changes ) = @_;
  my $uri = URI->new(BASE_URL);
  $uri->path('/storage');

  my $etag  = -l $file ? md5_hex('') : $attrs->[ETAG];
  my $_size = -l $file ? 0           : -s $file;

  return 1
    if _check_duplicate( $uri, $file, $etag, $node_key, $partner_key, $attrs );

  my $sfile = $changes->{stage_file};

  my %metadata = _get_metadata( $file, $attrs );

  my $metadata_ref = +{%metadata};

  if ( $opt->{use_own_storage} ) {

    my $bucket = $aws_storage_backend->bucket($aws_container);

    if ( -s $file < $PART_LIMIT_SIZE ) {
      my $path = $file;
      $path =~ s/^\///;
      $bucket->add_key(
        $path,
        ( -l $file ? '' : \$sfile ),
        _make_header( $metadata_ref, $file )
        )
        or die $aws_storage_backend->err . ": " . $aws_storage_backend->errstr;
    }
    else {
      _aws_backend_send_multipart( $file, $attrs, $changes );
    }
  }

  my $req = POST $uri,
    Content_Type => 'form-data',
    Etag         => $etag,
    Content      => [
    %metadata,
    path  => "$file",
    _size => $_size,
    (
      !-l $file
      ? ( $opt->{use_own_storage} ? () : ( value => [$sfile] ) )
      : ()
    )
    ];
  _send_request($req);

  my $stat = -l $file ? File::stat::lstat($file) : File::stat::stat($file);
  _write_to_manifest( $manifest, "+$file\n+${\$stat->size}\n+$etag\n\n" );

  return 1;

}

sub _check_duplicate {
  my ( $uri, $file, $etag, $node_key, $partner_key, $attrs ) = @_;
  my $req = POST $uri,
    Content_Type => 'form-data',
    Etag         => $etag,
    Content      => [
    etag  => $etag,
    check => 1,
    path  => "$file",
    _get_metadata( $file, $attrs )
    ];
  my $res = $ua->request($req);
  if ( $res->code == 201 ) {
    my $stat = -l $file ? File::stat::lstat($file) : File::stat::stat($file);
    _write_to_manifest( $manifest, "+$file\n+${\$stat->size}\n+$etag\n\n" );
  }
  return $res->is_success;
}

sub _send_request {

  my $req = shift;
  my $res = $ua->request($req);
  if ( !$res->is_success ) {
    if ( $res->code == 401 ) {
      $util->log_error("*** ERROR: 401 http unauthorized");
      kill USR1 => $parent_pid if $parent_pid;
      kill USR1 => $main_pid   if $main_pid;
      exit;
    }
    print "[failed] ", $res->status_line, "\n";
    print $res->headers_as_string;

    exit -1;
  }
  return $res;

}

sub _delete_files {
  my (@to_delete) = @_;

  my $bw = Parallel::Fork::BossWorker->new(
    worker_count => $opt->{workers},
    work_handler => \&_delete,
  );

  foreach my $delete_this (@to_delete) {
    $bw->add_work($delete_this);
  }

  $bw->process();
}

sub _read_cache {
  #
  # Slurp cache File
  #

  my $cache_file = $util->make_control_file('cache');
  my %cache;
  my $cache_file_version = &_filename_cache_version($cache_file);

  my $cache_version = &_read_cache_version($cache_file_version);
  if ( version->parse($cache_version) != version->parse($VERSION) ) {
    $util->log_info("Remove cache version file: $cache_file_version");
    $util->log_info("Remove cache file: $cache_file");
    unlink($cache_file_version);
    unlink($cache_file);
  }

  return () unless -e $cache_file;

  open( my $fh, '<:unix:encoding(UTF-8)', $cache_file )
    or die "Cannot open $cache_file";

  my $t = time;
  my @to_delete;
  while ( my $line = $fh->getline ) {
    chomp($line);
    my $attrs = [ split /,/, $line ];
    my $file = shift @$attrs;
    chomp($file);
    my $stat = -l $file ? File::stat::lstat($file) : File::stat::stat($file);
    if ( !$stat ) {
      if ( !$opt->{nodelete} ) {
        push( @to_delete, $file );
      }
      next;
    }

    $cache{$file} = $attrs;
  }
  $util->log_info(
    'Cache read took: ' . sprintf( "%.9f", ( time - $t ) ) . "s" );

  close($fh);
  undef($fh);

  if ( !$opt->{nodelete} && @to_delete ) {
    _delete_files(@to_delete);
  }

  return %cache;
}

sub _filename_cache_version {
  join( '.', shift, 'version' );
}

sub _update_cache_version {
  my $filename = shift;
  my $fh = IO::File->new( $filename, 'w', ':unix' )
    or die "Cannot open $filename";
  print $fh $VERSION;
}

sub _read_cache_version {
  my $filename = shift;
  return qv(0) unless -r $filename;
  my $content = do { local ( @ARGV, $/ ) = $filename; <> };
  return $content if qv($content)->is_qv;
  return qv(0);
}

sub _write_cache {
  my (%cache)            = @_;
  my $t                  = time;
  my $cache_file         = $util->make_control_file('cache');
  my $cache_file_version = &_filename_cache_version($cache_file);
  &_update_cache_version($cache_file_version);

  open( my $fh, '>:unix', $cache_file )
    or die "Cannot open $cache_file";

  print {$fh}
    map {
    my $attrs = $cache{$_};
    Encode::encode_utf8( join( q{,}, $_, @$attrs ) . "\n" );
    }
    keys %cache;

  # $cache_file->close;
  $util->log_info(
    '* Cache write took: ' . sprintf( "%.9f", ( time - $t ) ) . "s" );
}

sub lock {
  my ($fh) = @_;
  flock( $fh, LOCK_EX ) or die "Cannot lock file - $!\n";
  seek( $fh, 0, SEEK_END ) or die "Cannot seek - $!\n";
}

sub unlock {
  my ($fh) = @_;
  flock( $fh, LOCK_UN ) or die "Cannot unlock file - $!\n";
}

sub _stage_file {
  join( '/', $stage_dir, md5_hex( $node_key . $partner_key . $path . shift ) );
}

sub _link_to_stage {
  my $file       = shift;
  my $stage_file = _stage_file($file);
  copy( $file, $stage_file ) or die "Copy failed: $!";
  return $stage_file;
}

sub _make_metaname {
  return join( '-', 'x-amz-meta-b-datum', @_ );
}

sub _make_header () {
  my ( $hash, $key, $version ) = @_;
  $hash = keys( %{$hash} ) ? $hash : {};

  foreach my $item ( keys %{$hash} ) {
    next if $item =~ /^content/;
    my $value = encode( 'MIME-Header', delete $hash->{$item} );
    $value =~ s/\r?\n//g;
    $hash->{ _make_metaname($item) } = $value;

  }

  my $hash_version = {
    ( $version ? ( _make_metaname('version') => $version ) : () ),
    'content-disposition' => basename($key)
  };

  return { %$hash, %$hash_version };
}

